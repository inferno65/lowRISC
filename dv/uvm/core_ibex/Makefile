# Copyright lowRISC contributors.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

.SUFFIXES:

GEN_DIR             := $(realpath ../../../vendor/google_riscv-dv)
TOOLCHAIN           := ${RISCV_TOOLCHAIN}
export IBEX_ROOT    := $(realpath ../../../)

ifeq ($(COSIM),1)
ifndef IBEX_COSIM_ISS_ROOT
$(error IBEX_COSIM_ISS_ROOT must be set to the root of a suitable spike build if COSIM=1)
else
# Spike builds a libsoftfloat.so shared library that the simulator binary needs.
# Set LD_LIBRARY_PATH so it can be found.
export LD_LIBRARY_PATH := $(IBEX_COSIM_ISS_ROOT)/lib/:${LD_LIBRARY_PATH}
endif
endif

# Explicitly ask for the bash shell
SHELL                := bash

# Seed for instruction generator and RTL simulation
#
# By default, SEED is set to a different value on each run by picking a random
# value in the Makefile. For overnight testing, a sensible seed might be
# something like the output of "date +%y%m%d". For regression testing, you'll
# need to make sure that a the seed for a failed test "sticks" (so we don't
# start passing again without fixing the bug).
SEED                := $(shell echo $$RANDOM)

# This is the top-level output directory. Everything we generate goes in
# here. Most generated stuff actually goes in $(OUT)/seed-$(SEED), which allows
# us to run multiple times without deleting existing results.
OUT      := out
OUT-SEED := $(OUT)/seed-$(SEED)

# Needed for tcl files that are used with Cadence tools.
export dv_root := $(realpath ../../../vendor/lowrisc_ip/dv)
export DUT_TOP := dut

# Enable waveform dumping
WAVES               := 1
# Enable coverage dump
COV                 := 0
# RTL simulator
SIMULATOR           := vcs
# ISS (spike, ovpsim)
ISS                 := spike
# ISA
ISA                 := rv32imcb
ISA_ISS             := rv32imc_Zba_Zbb_Zbc_Zbs_Xbitmanip
# Test name (default: full regression)
TEST                := all
TESTLIST            := riscv_dv_extension/testlist.yaml
# Verbose logging
VERBOSE             :=
# Number of iterations for each test, assign a non-zero value to override the
# iteration count in the test list
ITERATIONS          := 0
# Generator timeout limit in seconds
TIMEOUT             := 1800
# Privileged CSR YAML description file
CSR_FILE            := riscv_dv_extension/csr_description.yaml
# Pass/fail signature address at the end of test
SIGNATURE_ADDR      := 8ffffffc

### Ibex top level parameters ###
### Required by RISCV-DV, some ISS, and RTL ###
# PMP Regions
PMP_REGIONS         := 16
# PMP Granularity
PMP_GRANULARITY     := 0

IBEX_CONFIG         := opentitan

# A version of $(OUT) with a trailing '/'. The point is that this will
# never match the name of a phony targets like "sim" (which causes
# strange rebuilds otherwise). The call to $(dir ) avoids adding
# another trailing slash if $(OUT) had one already.
OUT-DIR := $(dir $(OUT)/)

# This expands to '@' if VERBOSE is 0 or not set, and to the empty
# string otherwise. Prefix commands with it in order that they only
# get printed when VERBOSE.
verb = $(if $(filter-out 0,$(VERBOSE)),,@)

# Like verb, but expands to --verbose if we're in verbose mode (used
# for running sub-commands)
verb-arg = $(if $(filter-out 0,$(VERBOSE)),--verbose,)

SHELL=/bin/bash

export PRJ_DIR        := $(realpath ../../..)
export LOWRISC_IP_DIR := $(realpath ${PRJ_DIR}/vendor/lowrisc_ip)

all: sim

instr: iss_sim

sim: post_compare $(if $(filter 1,$(COV)),merge_cov,)

.PHONY: clean
clean:
	rm -rf $(OUT-DIR)

# Options used for privileged CSR test generation
CSR_OPTS=--csr_yaml=${CSR_FILE} \
         --isa="${ISA}" \
         --end_signature_addr=${SIGNATURE_ADDR}

# To avoid cluttering the output directory with stamp files, we place them in
# $(metadata).
metadata := $(OUT-SEED)/.metadata

# This is a list of directories that are automatically generated by some
# targets. To ensure the directory has been built, add a order-only dependency
# (with the pipe symbol before it) on the directory name and add the directory
# to this list.
gen-dirs :=                                         \
  $(OUT-DIR) $(OUT-SEED)                            \
  $(metadata) $(OUT-DIR)rtl_sim $(OUT-DIR)instr_gen \
  $(OUT-SEED)/$(ISS)

$(gen-dirs): %:
	mkdir -p $@

###############################################################################
# Utility functions.
#
# If VS is a list of variable names, P is a path and X is a string, then $(call
# dump-vars,P,X,VS) will expand to a list of 'file' commands that write each
# variable to P in Makefile syntax, but with "last-X-" prepended. At the start
# of the file, we also define last-X-vars-loaded to 1. You can use this to
# check whether there was a dump file at all.
#
# Note that this doesn't work by expanding to a command. Instead, *evaluating*
# dump-vars causes the variables to be dumped.
dump-var  = $(file >>$(1),last-$(2)-$(3) := $($(3)))
dump-vars = $(file >$(1),last-$(2)-vars-loaded := .) \
            $(foreach name,$(3),$(call dump-var,$(1),$(2),$(name)))

# equal checks whether two strings are equal, evaluating to '.' if they are and
# '' otherwise.
both-empty = $(if $(1),,$(if $(2),,.))
find-find = $(if $(and $(findstring $(1),$(2)),$(findstring $(2),$(1))),.,)
equal = $(or $(call both-empty,$(1),$(2)),$(call find-find,$(1),$(2)))

# var-differs is used to check whether a variable has changed since it was
# dumped. If it has changed, the function evaluates to '.' (with some
# whitespace) and prints a message to the console; if not, it evaluates to ''.
#
# Call it as $(call var-differs,X,TGT,V).
var-differs = \
  $(if $(call equal,$(strip $($(3))),$(strip $(last-$(1)-$(3)))),,\
       .$(info Repeating $(2) because variable $(3) has changed value.))

# vars-differ is used to check whether several variables have the same value as
# they had when they were dumped. If we haven't loaded the dumpfile, it
# silently evaluates to '!'. Otherwise, if all the variables match, it
# evaluates to '.'. If not, it evaluates to '.' and prints some messages to the
# console explaining why a rebuild is happening.
#
# Call it as $(call vars-differ,X,TGT,VS).
vars-differ-lst = $(foreach v,$(3),$(call var-differs,$(1),$(2),$(v)))
vars-differ-sp = \
  $(if $(last-$(1)-vars-loaded),\
       $(if $(strip $(call vars-differ-lst,$(1),$(2),$(3))),.,),\
       !)
vars-differ = $(strip $(call vars-differ-sp,$(1),$(2),$(3)))

# A phony target which can be used to force recompilation.
.PHONY: FORCE
FORCE:

# vars-prereq is empty if every variable in VS matches the last run (loaded
# with tag X), otherwise it is set to FORCE (which will force a recompile and
# might print a message to the console explaining why we're rebuilding TGT).
#
# Call it as $(call vars-prereq,X,TGT,VS)
vars-prereq = $(if $(call vars-differ,$(call strip,$(1)),$(2),$(3)),FORCE,)

###############################################################################
# Get a list of tests and seeds
#
# Run list_tests.py to list the things we need to run in the format
# TESTNAME.SEED and store it in a variable.
tests-and-seeds := \
  $(shell ./list_tests.py \
            --start_seed $(SEED) \
            --test "$(TEST)" \
            --iterations $(ITERATIONS) \
            --ibex-config $(IBEX_CONFIG))

###############################################################################
###############################################################################
# Build the Random Instruction Generator
#
# This depends on the vendored in code in $(GEN_DIR). It also depends on the
# values of the following Makefile variables (we want to regenerate things if,
# for example, the simulator changes).
instr-gen-build-var-deps := SIMULATOR ISA CSR_OPTS \
                            SIGNATURE_ADDR PMP_REGIONS PMP_GRANULARITY
# To achieve this variable tracking, we dump each of the variables to a Makefile
# fragment and try to load it up the next time around. This done with the
# utility function "dump-vars" at the end of the recipe.
#
# To create the dependency, we must do the following two things before each
# target:
#
# First, load up the saved variable values from the last time around. If this
# fails, it's no problem: we'll assume that the previous run either doesn't
# exist or something went wrong.
ig-build-vars-path := $(OUT-DIR).instr-gen-build.vars.mk
-include $(ig-build-vars-path)

# Next, compare the current variables to those we just loaded. This uses the
# utility function "vars-prereq". It creates a variable which evaluates to the
# (phony) FORCE if the two sets of variables do not match.
#
# Note that we define it with '=', not ':=', so we don't evaluate if we're not
# trying to run the instr_gen_build target.
instr-gen-build-vars-prereq = \
  $(call vars-prereq, \
     gen, \
     building instruction generator, \
     $(instr-gen-build-var-deps))

# Finally, $(instr-gen-build-vars-prereq) becomes a dependency of our target.

riscv-dv-files := $(shell find $(GEN_DIR) -type f)
# A variable containing a file list for the riscv-dv vendored-in module.
# Depending on these files gives a safe over-approximation that will ensure we
# rebuild things if that module changes.
# Note that this is defined with ":=". As a result, we'll always run the find
# command exactly once. Wasteful if we're trying to make clean, but much better
# than running it for every target otherwise.

$(OUT-DIR)instr_gen/.compile.stamp: \
  $(instr-gen-build-vars-prereq) \
  $(riscv-dv-files) scripts/build-instr-gen.py | $(OUT-DIR)instr_gen
	$(verb)scripts/build-instr-gen.py        \
	  $(verb-arg)                            \
	  --simulator $(SIMULATOR)               \
	  --end-signature-addr $(SIGNATURE_ADDR) \
	  --output $(OUT-DIR)instr_gen           \
	  --isa $(ISA)
	$(call dump-vars,$(ig-build-vars-path),gen,$(instr-gen-build-var-deps))
	@touch $@

.PHONY: instr_gen_build
instr_gen_build: $(OUT-DIR)instr_gen/.compile.stamp

###############################################################################
# Run the random instruction generator
#
test-asms := $(foreach ts,$(tests-and-seeds),$(OUT-SEED)/instr_gen/$(ts).S)

$(test-asms): \
  $(OUT-SEED)/instr_gen/%.S: \
  $(OUT-DIR)instr_gen/.compile.stamp \
  $(TESTLIST) \
  scripts/run-instr-gen.py | $(metadata)
	$(verb)scripts/run-instr-gen.py          \
	  $(verb-arg)                            \
	  --simulator $(SIMULATOR)               \
	  --end-signature-addr $(SIGNATURE_ADDR) \
	  --output-dir $(@D)                     \
	  --gen-build-dir $(OUT-DIR)instr_gen    \
	  --isa $(ISA)                           \
	  --test-dot-seed $*                     \
	  --pmp-num-regions $(PMP_REGIONS)       \
	  --pmp-granularity $(PMP_GRANULARITY)

.PHONY: instr_gen_run
instr_gen_run: $(test-asms)

###############################################################################
# Compile the generated assembly programs
#
# We don't explicitly track dependencies on the RISCV toolchain, so this
# doesn't depend on anything more than the instr_gen stage did.
#
# Note that the compilation step generates a .o file and then uses
# objcopy to create a .bin. The ISS run uses the .o and the RTL run
# uses the .bin. In the Makefile, we just track the .bin to represent
# both.

test-bins := $(foreach ts,$(tests-and-seeds),$(OUT-SEED)/instr_gen/$(ts).bin)

$(test-bins): \
  $(OUT-SEED)/instr_gen/%.bin: \
  $(OUT-SEED)/instr_gen/%.S \
  scripts/compile-generated-test.py
	$(verb)scripts/compile-generated-test.py \
	  $(verb-arg)                            \
	  --output $@                            \
	  --isa $(ISA)                           \
	  --input-dir $(OUT-SEED)/instr_gen      \
	  --test-dot-seed $*

.PHONY: instr_gen_compile
instr_gen_compile: $(test-bins)

###############################################################################
# Run the instruction set simulator
#
# This (obviously) depends on having compiled the generated programs, so we
# don't have to worry about variables that affect the 'gen' stage. The only
# other variable that's going to affect things is the actual choice of ISS. We
# cheat and include it in the path.

iss-sim-logs := $(foreach ts,$(tests-and-seeds),$(OUT-SEED)/$(ISS)/$(ts).log)

$(iss-sim-logs): \
  $(OUT-SEED)/$(ISS)/%.log: \
  $(OUT-SEED)/instr_gen/%.bin \
  $(TESTLIST) scripts/run-iss.py | $(OUT-SEED)/$(ISS)
	$(verb)scripts/run-iss.py              \
	  $(verb-arg)                          \
	  --iss=$(ISS)                         \
	  --input=$(OUT-SEED)/instr_gen/$*.o   \
	  --output=$@                          \
	  --isa=$(ISA_ISS)

.PHONY: iss_run
iss_run: $(iss-sim-logs)


###############################################################################
# Compile ibex core TB
#
# Note that this doesn't depend on the seed: the DUT doesn't depend on which
# test we're running!
#
# It does, however, depend on various variables. These are listed in
# tb-compile-var-deps. See the 'gen' stage for more verbose explanations of how
# the variable dumping works.
#
# The compiled ibex testbench (obviously!) also depends on the design and the
# DV code. The clever way of doing this would be to look at a dependency
# listing generated by the simulator as a side-effect of doing the compile (a
# bit like using the -M flags with a C compiler). Unfortunately, that doesn't
# look like it's particularly easy, so we'll just depend on every .v, .sv or
# .svh file in the dv or rtl directories. Note that this variable is set with
# '=', rather than ':='. This means that we don't bother running the find
# commands unless we need the compiled testbench.
all-verilog = \
  $(shell find ../../../rtl -name '*.v' -o -name '*.sv' -o -name '*.svh') \
  $(shell find ../.. -name '*.v' -o -name '*.sv' -o -name '*.svh')

tb-compile-var-deps := SIMULATOR COV WAVES COSIM
-include $(OUT-DIR)rtl_sim/.rtl.tb_compile.vars.mk
tb-compile-vars-prereq = $(call vars-prereq,comp,compiling TB,$(tb-compile-var-deps))

$(call dump-vars-match,$(tb-compile-var-deps),comp)

cov-arg := $(if $(call equal,$(COV),1),--en_cov,)
wave-arg := $(if $(call equal,$(WAVES),1),--en_wave,)
cosim-arg := $(if $(call equal,$(COSIM),1),--en_cosim,)

$(OUT-DIR)rtl_sim/.rtl.tb_compile.stamp: \
  $(tb-compile-vars-prereq) $(all-verilog) $(risc-dv-files) \
  scripts/compile-tb.py yaml/rtl_simulation.yaml \
  | $(OUT-DIR)rtl_sim
	$(verb)scripts/compile-tb.py           \
	  $(verb-arg)                          \
	  --ibex-config $(IBEX_CONFIG)         \
	  --output=$(OUT-DIR)                  \
	  --simulator=$(SIMULATOR)             \
	  $(cov-arg) $(wave-arg) $(cosim-arg)
	$(call dump-vars,$(OUT-DIR)rtl_sim/.rtl.tb_compile.vars.mk,comp,$(tb-compile-var-deps))
	@touch $@

.PHONY: rtl_tb_compile
rtl_tb_compile: $(OUT-DIR)rtl_sim/.rtl.tb_compile.stamp

###############################################################################
# Run ibex RTL simulation with generated programs

rtl-sim-dirs := $(addprefix $(OUT-SEED)/rtl_sim/,$(tests-and-seeds))
rtl-sim-logs := $(addsuffix /sim.log,$(rtl-sim-dirs))

$(rtl-sim-logs): \
  $(OUT-SEED)/rtl_sim/%/sim.log:          \
  $(OUT-DIR)rtl_sim/.rtl.tb_compile.stamp \
  $(OUT-SEED)/instr_gen/%.bin             \
  scripts/run-rtl.py
	@echo Running RTL simulation at $@
	$(verb)mkdir -p $(@D)
	$(verb)scripts/run-rtl.py               \
	  --ibex-config $(IBEX_CONFIG)          \
	  --simulator $(SIMULATOR)              \
	  $(cov-arg) $(wave-arg)                \
	  --signature-addr $(SIGNATURE_ADDR)    \
	  --test-dot-seed $*                    \
	  --binary $(OUT-SEED)/instr_gen/$*.bin \
	  --rtl-sim-dir $(OUT-DIR)rtl_sim       \
	  --out-dir $(OUT-SEED)/rtl_sim/$*

.PHONY: rtl_sim_run
rtl_sim_run: $(rtl-sim-logs)

###############################################################################
# Compare ISS and RTL sim results
#
# For a given TEST/SEED pair, the ISS and RTL logs appear at:
#
#   $(OUT-SEED)/$(ISS)/$(TEST).$(SEED).log
#   $(OUT-SEED)/rtl_sim/$(TEST).$(SEED)/trace_core_00000000.log
#
# The comparison script compares these and writes to a result file at
#
#   $(OUT-SEED)/rtl_sim/$(TEST).$(SEED)/test-result.yml
#
# with PASSED or FAILED, depending.

comp-results := $(addsuffix /test-result.yml,$(rtl-sim-dirs))

$(comp-results): \
  %/test-result.yml: \
  $(iss-sim-logs) \
  $(rtl-sim-logs) compare.py
	@echo Comparing traces for $*
	$(verb)./compare.py \
	         --instr-gen-bin-dir $(OUT-SEED)/instr_gen/asm_test \
	         --iss $(ISS) \
	         --iss-log-dir $(OUT-SEED)/$(ISS) \
	         --start-seed $(SEED) \
	         --test-dot-seed "$(notdir $*)" \
	         --output $@ \
	         --rtl-log-dir $(OUT-SEED)/rtl_sim/$(notdir $*)

$(OUT-SEED)/regr.log: collect_results.py $(comp-results)
	@echo "Collecting up results (report at $@)"
	$(verb)./collect_results.py -o $(@D) $(comp-results)

.PHONY: post_compare
post_compare: $(OUT-SEED)/regr.log

###############################################################################
# Generate RISCV-DV functional coverage
# TODO(udi) - add B extension
$(metadata)/.cov.gen_fcov.stamp: $(rtl-sim-logs)
	$(verb)python3 ${GEN_DIR}/cov.py \
	       --core ibex \
	       --dir ${OUT-SEED}/rtl_sim \
	       -o ${OUT-SEED}/fcov \
	       --simulator "${SIMULATOR}" \
	       --opts "--gen_timeout 1000" \
	       --isa rv32imcb \
	       --custom_target riscv_dv_extension
	@ # Bookkeeping
	@touch $@

.PHONY: riscv_dv_fcov
riscv_dv_fcov: $(metadata)/.cov.gen_fcov.stamp

###############################################################################
# Merge all output coverage directories into the <out>/rtl_sim directory
#
# Any coverage databases generated from the riscv_dv_fcov target will be merged
# as well.
$(metadata)/.cov.merge.stamp: \
  $(metadata)/.cov.gen_fcov.stamp \
  scripts/merge-cov.py
	$(verb)scripts/merge-cov.py    \
	  $(verb-arg)                  \
	  --working-dir=$(OUT-SEED)    \
	  --simulator=$(SIMULATOR)
	@ # Bookkeeping
	@touch $@

.PHONY: merge_cov
merge_cov: $(metadata)/.cov.merge.stamp
