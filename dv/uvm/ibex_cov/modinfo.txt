===============================================================================
Module : uvm_pkg
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 33.33 --     --     --     --      33.33 

Source File(s) : 

/edascratch/ms_edatools/synopsys/vcs/2019.06-1/etc/uvm-1.2/uvm_pkg.sv

Module self-instances :

SCORE LINE TOGGLE FSM BRANCH ASSERT NAME 



-------------------------------------------------------------------------------
Assert Coverage for Module : uvm_pkg
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       3     1         33.33   1                 33.33   
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            3     1         33.33   1                 33.33   



-------------------------------------------------------------------------------

Assertion Details

Name                                                  Attempts Real Successes Failures Incomplete 
\uvm_component_name_check_visitor::visit .unnamed$$_0 35020    35020          0        0          
\uvm_reg_map::do_read .unnamed$$_0.unnamed$$_1        0        0              0        0          
\uvm_reg_map::do_write .unnamed$$_0.unnamed$$_1       0        0              0        0          


===============================================================================
Module : ibex_tracer
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 78.06  57.26 --     --      98.86 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_tracer.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                  
--     --     --     --     --     --     core_ibex_tb_top.dut.u_ibex_tracer(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_tracer

             Line No.   Total   Covered  Percent
TOTAL                      489      280    57.26
ROUTINE            94       23       23   100.00
ROUTINE           140        3        3   100.00
ROUTINE           149      242       36    14.88
ROUTINE           395        1        1   100.00
ROUTINE           399        2        2   100.00
ROUTINE           404        2        2   100.00
ROUTINE           412        3        3   100.00
ROUTINE           419        2        2   100.00
ROUTINE           425        2        2   100.00
ROUTINE           431        2        2   100.00
ROUTINE           440        4        4   100.00
ROUTINE           451        7        7   100.00
ROUTINE           465        7        7   100.00
ROUTINE           482        3        3   100.00
ROUTINE           489        3        3   100.00
ROUTINE           496        3        3   100.00
ROUTINE           503        3        3   100.00
ROUTINE           510        3        3   100.00
ROUTINE           518        3        3   100.00
ROUTINE           525        3        3   100.00
ROUTINE           533       12        9    75.00
ROUTINE           553        2        2   100.00
ROUTINE           558        3        3   100.00
ROUTINE           568        5        5   100.00
ROUTINE           581        5        5   100.00
ROUTINE           613       15       15   100.00
ROUTINE           638       10       10   100.00
ROUTINE           660        9        9   100.00
ROUTINE           678        3        3   100.00
ALWAYS            685        3        3   100.00
INITIAL           694        2        2   100.00
ALWAYS            701        2        2   100.00
ALWAYS            707       97       97   100.00

93                      
94         1/1              if (file_handle == 32'h0) begin
95                            string file_name_base = "trace_core";
96         1/1                $value$plusargs("ibex_tracer_file_base=%s", file_name_base);
97         1/1                $sformat(file_name, "%s_%h.log", file_name_base, hart_id_i);
98                      
99         1/1                $display("%m: Writing execution trace to %s", file_name);
100        1/1                file_handle = $fopen(file_name, "w");
101        1/1                $fwrite(file_handle, "Time\tCycle\tPC\tInsn\tDecoded instruction\tRegister and memory contents\n");
102                         end
                        MISSING_ELSE
103                     
104                         // Write compressed instructions as four hex digits (16 bit word), and
105                         // uncompressed ones as 8 hex digits (32 bit words).
106        1/1              if (insn_is_compressed) begin
107        1/1                rvfi_insn_str = $sformatf("%h", rvfi_insn[15:0]);
108                         end else begin
109        1/1                rvfi_insn_str = $sformatf("%h", rvfi_insn);
110                         end
111                     
112        1/1              $fwrite(file_handle, "%15t\t%d\t%h\t%s\t%s\t", $time, cycle, rvfi_pc_rdata, rvfi_insn_str, decoded_str);
113                     
114        1/1              if ((data_accessed & RS1) != 0) begin
115        1/1                $fwrite(file_handle, " %s:0x%08x", reg_addr_to_str(rvfi_rs1_addr), rvfi_rs1_rdata);
116                         end
                        MISSING_ELSE
117        1/1              if ((data_accessed & RS2) != 0) begin
118        1/1                $fwrite(file_handle, " %s:0x%08x", reg_addr_to_str(rvfi_rs2_addr), rvfi_rs2_rdata);
119                         end
                        MISSING_ELSE
120        1/1              if ((data_accessed & RD) != 0) begin
121        1/1                $fwrite(file_handle, " %s=0x%08x", reg_addr_to_str(rvfi_rd_addr), rvfi_rd_wdata);
122                         end
                        MISSING_ELSE
123        1/1              if ((data_accessed & MEM) != 0) begin
124        1/1                $fwrite(file_handle, " PA:0x%08x", rvfi_mem_addr);
125                     
126        1/1                if (rvfi_mem_rmask != 4'b000) begin
127        1/1                  $fwrite(file_handle, " store:0x%08x", rvfi_mem_wdata);
128                           end
                   ==>  MISSING_ELSE
129        1/1                if (rvfi_mem_wmask != 4'b000) begin
130        1/1                  $fwrite(file_handle, " load:0x%08x", rvfi_mem_rdata);
131                           end
                        MISSING_ELSE
132                         end
                        MISSING_ELSE
133                     
134        1/1              $fwrite(file_handle, "\n");
135                       endfunction
136                     
137                     
138                       // Format register address with "x" prefix, left-aligned to a fixed width of 3 characters.
139                       function string reg_addr_to_str(input logic [4:0] addr);
140        1/1              if (addr < 10) begin
141        1/1                return $sformatf(" x%0d", addr);
142                         end else begin
143        1/1                return $sformatf("x%0d", addr);
144                         end
145                       endfunction
146                     
147                       // Get a CSR name for a CSR address.
148                       function string get_csr_name(input logic [11:0] csr_addr);
149        1/1              unique case (csr_addr)
150        0/1     ==>        12'd0: return "ustatus";
151        0/1     ==>        12'd4: return "uie";
152        0/1     ==>        12'd5: return "utvec";
153        0/1     ==>        12'd64: return "uscratch";
154        0/1     ==>        12'd65: return "uepc";
155        0/1     ==>        12'd66: return "ucause";
156        0/1     ==>        12'd67: return "utval";
157        0/1     ==>        12'd68: return "uip";
158        0/1     ==>        12'd1: return "fflags";
159        0/1     ==>        12'd2: return "frm";
160        0/1     ==>        12'd3: return "fcsr";
161        0/1     ==>        12'd3072: return "cycle";
162        0/1     ==>        12'd3073: return "time";
163        0/1     ==>        12'd3074: return "instret";
164        0/1     ==>        12'd3075: return "hpmcounter3";
165        0/1     ==>        12'd3076: return "hpmcounter4";
166        0/1     ==>        12'd3077: return "hpmcounter5";
167        0/1     ==>        12'd3078: return "hpmcounter6";
168        0/1     ==>        12'd3079: return "hpmcounter7";
169        0/1     ==>        12'd3080: return "hpmcounter8";
170        0/1     ==>        12'd3081: return "hpmcounter9";
171        0/1     ==>        12'd3082: return "hpmcounter10";
172        0/1     ==>        12'd3083: return "hpmcounter11";
173        0/1     ==>        12'd3084: return "hpmcounter12";
174        0/1     ==>        12'd3085: return "hpmcounter13";
175        0/1     ==>        12'd3086: return "hpmcounter14";
176        0/1     ==>        12'd3087: return "hpmcounter15";
177        0/1     ==>        12'd3088: return "hpmcounter16";
178        0/1     ==>        12'd3089: return "hpmcounter17";
179        0/1     ==>        12'd3090: return "hpmcounter18";
180        0/1     ==>        12'd3091: return "hpmcounter19";
181        0/1     ==>        12'd3092: return "hpmcounter20";
182        0/1     ==>        12'd3093: return "hpmcounter21";
183        0/1     ==>        12'd3094: return "hpmcounter22";
184        0/1     ==>        12'd3095: return "hpmcounter23";
185        0/1     ==>        12'd3096: return "hpmcounter24";
186        0/1     ==>        12'd3097: return "hpmcounter25";
187        0/1     ==>        12'd3098: return "hpmcounter26";
188        0/1     ==>        12'd3099: return "hpmcounter27";
189        0/1     ==>        12'd3100: return "hpmcounter28";
190        0/1     ==>        12'd3101: return "hpmcounter29";
191        0/1     ==>        12'd3102: return "hpmcounter30";
192        0/1     ==>        12'd3103: return "hpmcounter31";
193        0/1     ==>        12'd3200: return "cycleh";
194        0/1     ==>        12'd3201: return "timeh";
195        0/1     ==>        12'd3202: return "instreth";
196        0/1     ==>        12'd3203: return "hpmcounter3h";
197        0/1     ==>        12'd3204: return "hpmcounter4h";
198        0/1     ==>        12'd3205: return "hpmcounter5h";
199        0/1     ==>        12'd3206: return "hpmcounter6h";
200        0/1     ==>        12'd3207: return "hpmcounter7h";
201        0/1     ==>        12'd3208: return "hpmcounter8h";
202        0/1     ==>        12'd3209: return "hpmcounter9h";
203        0/1     ==>        12'd3210: return "hpmcounter10h";
204        0/1     ==>        12'd3211: return "hpmcounter11h";
205        0/1     ==>        12'd3212: return "hpmcounter12h";
206        0/1     ==>        12'd3213: return "hpmcounter13h";
207        0/1     ==>        12'd3214: return "hpmcounter14h";
208        0/1     ==>        12'd3215: return "hpmcounter15h";
209        0/1     ==>        12'd3216: return "hpmcounter16h";
210        0/1     ==>        12'd3217: return "hpmcounter17h";
211        0/1     ==>        12'd3218: return "hpmcounter18h";
212        0/1     ==>        12'd3219: return "hpmcounter19h";
213        0/1     ==>        12'd3220: return "hpmcounter20h";
214        0/1     ==>        12'd3221: return "hpmcounter21h";
215        0/1     ==>        12'd3222: return "hpmcounter22h";
216        0/1     ==>        12'd3223: return "hpmcounter23h";
217        0/1     ==>        12'd3224: return "hpmcounter24h";
218        0/1     ==>        12'd3225: return "hpmcounter25h";
219        0/1     ==>        12'd3226: return "hpmcounter26h";
220        0/1     ==>        12'd3227: return "hpmcounter27h";
221        0/1     ==>        12'd3228: return "hpmcounter28h";
222        0/1     ==>        12'd3229: return "hpmcounter29h";
223        0/1     ==>        12'd3230: return "hpmcounter30h";
224        0/1     ==>        12'd3231: return "hpmcounter31h";
225        0/1     ==>        12'd256: return "sstatus";
226        0/1     ==>        12'd258: return "sedeleg";
227        0/1     ==>        12'd259: return "sideleg";
228        0/1     ==>        12'd260: return "sie";
229        0/1     ==>        12'd261: return "stvec";
230        0/1     ==>        12'd262: return "scounteren";
231        0/1     ==>        12'd320: return "sscratch";
232        0/1     ==>        12'd321: return "sepc";
233        0/1     ==>        12'd322: return "scause";
234        0/1     ==>        12'd323: return "stval";
235        0/1     ==>        12'd324: return "sip";
236        0/1     ==>        12'd384: return "satp";
237        0/1     ==>        12'd3857: return "mvendorid";
238        0/1     ==>        12'd3858: return "marchid";
239        0/1     ==>        12'd3859: return "mimpid";
240        0/1     ==>        12'd3860: return "mhartid";
241        1/1                12'd768: return "mstatus";
242        1/1                12'd769: return "misa";
243        0/1     ==>        12'd770: return "medeleg";
244        0/1     ==>        12'd771: return "mideleg";
245        1/1                12'd772: return "mie";
246        1/1                12'd773: return "mtvec";
247        0/1     ==>        12'd774: return "mcounteren";
248        1/1                12'd832: return "mscratch";
249        1/1                12'd833: return "mepc";
250        1/1                12'd834: return "mcause";
251        1/1                12'd835: return "mtval";
252        1/1                12'd836: return "mip";
253        0/1     ==>        12'd928: return "pmpcfg0";
254        0/1     ==>        12'd929: return "pmpcfg1";
255        0/1     ==>        12'd930: return "pmpcfg2";
256        0/1     ==>        12'd931: return "pmpcfg3";
257        0/1     ==>        12'd944: return "pmpaddr0";
258        0/1     ==>        12'd945: return "pmpaddr1";
259        0/1     ==>        12'd946: return "pmpaddr2";
260        0/1     ==>        12'd947: return "pmpaddr3";
261        0/1     ==>        12'd948: return "pmpaddr4";
262        0/1     ==>        12'd949: return "pmpaddr5";
263        0/1     ==>        12'd950: return "pmpaddr6";
264        0/1     ==>        12'd951: return "pmpaddr7";
265        0/1     ==>        12'd952: return "pmpaddr8";
266        0/1     ==>        12'd953: return "pmpaddr9";
267        0/1     ==>        12'd954: return "pmpaddr10";
268        0/1     ==>        12'd955: return "pmpaddr11";
269        0/1     ==>        12'd956: return "pmpaddr12";
270        0/1     ==>        12'd957: return "pmpaddr13";
271        0/1     ==>        12'd958: return "pmpaddr14";
272        0/1     ==>        12'd959: return "pmpaddr15";
273        1/1                12'd2816: return "mcycle";
274        1/1                12'd2818: return "minstret";
275        1/1                12'd2819: return "mhpmcounter3";
276        1/1                12'd2820: return "mhpmcounter4";
277        1/1                12'd2821: return "mhpmcounter5";
278        1/1                12'd2822: return "mhpmcounter6";
279        1/1                12'd2823: return "mhpmcounter7";
280        1/1                12'd2824: return "mhpmcounter8";
281        1/1                12'd2825: return "mhpmcounter9";
282        1/1                12'd2826: return "mhpmcounter10";
283        0/1     ==>        12'd2827: return "mhpmcounter11";
284        0/1     ==>        12'd2828: return "mhpmcounter12";
285        0/1     ==>        12'd2829: return "mhpmcounter13";
286        0/1     ==>        12'd2830: return "mhpmcounter14";
287        0/1     ==>        12'd2831: return "mhpmcounter15";
288        0/1     ==>        12'd2832: return "mhpmcounter16";
289        0/1     ==>        12'd2833: return "mhpmcounter17";
290        0/1     ==>        12'd2834: return "mhpmcounter18";
291        0/1     ==>        12'd2835: return "mhpmcounter19";
292        0/1     ==>        12'd2836: return "mhpmcounter20";
293        0/1     ==>        12'd2837: return "mhpmcounter21";
294        0/1     ==>        12'd2838: return "mhpmcounter22";
295        0/1     ==>        12'd2839: return "mhpmcounter23";
296        0/1     ==>        12'd2840: return "mhpmcounter24";
297        0/1     ==>        12'd2841: return "mhpmcounter25";
298        0/1     ==>        12'd2842: return "mhpmcounter26";
299        0/1     ==>        12'd2843: return "mhpmcounter27";
300        0/1     ==>        12'd2844: return "mhpmcounter28";
301        0/1     ==>        12'd2845: return "mhpmcounter29";
302        0/1     ==>        12'd2846: return "mhpmcounter30";
303        0/1     ==>        12'd2847: return "mhpmcounter31";
304        1/1                12'd2944: return "mcycleh";
305        1/1                12'd2946: return "minstreth";
306        1/1                12'd2947: return "mhpmcounter3h";
307        1/1                12'd2948: return "mhpmcounter4h";
308        1/1                12'd2949: return "mhpmcounter5h";
309        1/1                12'd2950: return "mhpmcounter6h";
310        1/1                12'd2951: return "mhpmcounter7h";
311        1/1                12'd2952: return "mhpmcounter8h";
312        1/1                12'd2953: return "mhpmcounter9h";
313        1/1                12'd2954: return "mhpmcounter10h";
314        0/1     ==>        12'd2955: return "mhpmcounter11h";
315        0/1     ==>        12'd2956: return "mhpmcounter12h";
316        1/1                12'd2957: return "mhpmcounter13h";
317        0/1     ==>        12'd2958: return "mhpmcounter14h";
318        0/1     ==>        12'd2959: return "mhpmcounter15h";
319        0/1     ==>        12'd2960: return "mhpmcounter16h";
320        0/1     ==>        12'd2961: return "mhpmcounter17h";
321        0/1     ==>        12'd2962: return "mhpmcounter18h";
322        0/1     ==>        12'd2963: return "mhpmcounter19h";
323        0/1     ==>        12'd2964: return "mhpmcounter20h";
324        0/1     ==>        12'd2965: return "mhpmcounter21h";
325        0/1     ==>        12'd2966: return "mhpmcounter22h";
326        0/1     ==>        12'd2967: return "mhpmcounter23h";
327        0/1     ==>        12'd2968: return "mhpmcounter24h";
328        0/1     ==>        12'd2969: return "mhpmcounter25h";
329        0/1     ==>        12'd2970: return "mhpmcounter26h";
330        0/1     ==>        12'd2971: return "mhpmcounter27h";
331        0/1     ==>        12'd2972: return "mhpmcounter28h";
332        0/1     ==>        12'd2973: return "mhpmcounter29h";
333        0/1     ==>        12'd2974: return "mhpmcounter30h";
334        0/1     ==>        12'd2975: return "mhpmcounter31h";
335        0/1     ==>        12'd803: return "mhpmevent3";
336        0/1     ==>        12'd804: return "mhpmevent4";
337        0/1     ==>        12'd805: return "mhpmevent5";
338        0/1     ==>        12'd806: return "mhpmevent6";
339        0/1     ==>        12'd807: return "mhpmevent7";
340        0/1     ==>        12'd808: return "mhpmevent8";
341        0/1     ==>        12'd809: return "mhpmevent9";
342        0/1     ==>        12'd810: return "mhpmevent10";
343        0/1     ==>        12'd811: return "mhpmevent11";
344        0/1     ==>        12'd812: return "mhpmevent12";
345        0/1     ==>        12'd813: return "mhpmevent13";
346        0/1     ==>        12'd814: return "mhpmevent14";
347        0/1     ==>        12'd815: return "mhpmevent15";
348        0/1     ==>        12'd816: return "mhpmevent16";
349        0/1     ==>        12'd817: return "mhpmevent17";
350        0/1     ==>        12'd818: return "mhpmevent18";
351        0/1     ==>        12'd819: return "mhpmevent19";
352        0/1     ==>        12'd820: return "mhpmevent20";
353        0/1     ==>        12'd821: return "mhpmevent21";
354        0/1     ==>        12'd822: return "mhpmevent22";
355        0/1     ==>        12'd823: return "mhpmevent23";
356        0/1     ==>        12'd824: return "mhpmevent24";
357        0/1     ==>        12'd825: return "mhpmevent25";
358        0/1     ==>        12'd826: return "mhpmevent26";
359        0/1     ==>        12'd827: return "mhpmevent27";
360        0/1     ==>        12'd828: return "mhpmevent28";
361        0/1     ==>        12'd829: return "mhpmevent29";
362        0/1     ==>        12'd830: return "mhpmevent30";
363        0/1     ==>        12'd831: return "mhpmevent31";
364        0/1     ==>        12'd1952: return "tselect";
365        0/1     ==>        12'd1953: return "tdata1";
366        0/1     ==>        12'd1954: return "tdata2";
367        0/1     ==>        12'd1955: return "tdata3";
368        1/1                12'd1968: return "dcsr";
369        1/1                12'd1969: return "dpc";
370        1/1                12'd1970: return "dscratch";
371        0/1     ==>        12'd512: return "hstatus";
372        0/1     ==>        12'd514: return "hedeleg";
373        0/1     ==>        12'd515: return "hideleg";
374        0/1     ==>        12'd516: return "hie";
375        0/1     ==>        12'd517: return "htvec";
376        1/1                12'd576: return "hscratch";
377        0/1     ==>        12'd577: return "hepc";
378        0/1     ==>        12'd578: return "hcause";
379        0/1     ==>        12'd579: return "hbadaddr";
380        0/1     ==>        12'd580: return "hip";
381        0/1     ==>        12'd896: return "mbase";
382        0/1     ==>        12'd897: return "mbound";
383        0/1     ==>        12'd898: return "mibase";
384        0/1     ==>        12'd899: return "mibound";
385        0/1     ==>        12'd900: return "mdbase";
386        0/1     ==>        12'd901: return "mdbound";
387        0/1     ==>        12'd800: return "mucounteren";
388        0/1     ==>        12'd801: return "mscounteren";
389        0/1     ==>        12'd802: return "mhcounteren";
390        1/1                default: return $sformatf("0x%x", csr_addr);
391                         endcase
392                       endfunction
393                     
394                       function void decode_mnemonic(input string mnemonic);
395        1/1              decoded_str = mnemonic;
396                       endfunction
397                     
398                       function void decode_r_insn(input string mnemonic);
399        1/1              data_accessed = RS1 | RS2 | RD;
400        1/1              decoded_str = $sformatf("%s\tx%0d,x%0d,x%0d", mnemonic, rvfi_rd_addr, rvfi_rs1_addr, rvfi_rs2_addr);
401                       endfunction
402                     
403                       function void decode_i_insn(input string mnemonic);
404        1/1              data_accessed = RS1 | RD;
405        1/1              decoded_str = $sformatf("%s\tx%0d,x%0d,%0d", mnemonic, rvfi_rd_addr, rvfi_rs1_addr,
406                                         $signed({{20 {rvfi_insn[31]}}, rvfi_insn[31:20]}));
407                       endfunction
408                     
409                       function void decode_i_shift_insn(input string mnemonic);
410                         // SLLI, SRLI, SRAI
411                         logic [4:0] shamt;
412        1/1              shamt = {rvfi_insn[24:20]};
413        1/1              data_accessed = RS1 | RD;
414        1/1              decoded_str = $sformatf("%s\tx%0d,x%0d,0x%0x", mnemonic, rvfi_rd_addr, rvfi_rs1_addr, shamt);
415                       endfunction
416                     
417                       function void decode_i_jalr_insn(input string mnemonic);
418                         // JALR
419        1/1              data_accessed = RS1 | RD;
420        1/1              decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)", mnemonic, rvfi_rd_addr,
421                             $signed({{20 {rvfi_insn[31]}}, rvfi_insn[31:20]}), rvfi_rs1_addr);
422                       endfunction
423                     
424                       function void decode_u_insn(input string mnemonic);
425        1/1              data_accessed = RD;
426        1/1              decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rd_addr, {rvfi_insn[31:12]});
427                       endfunction
428                     
429                       function void decode_j_insn(input string mnemonic);
430                         // JAL
431        1/1              data_accessed = RD;
432        1/1              decoded_str = $sformatf("%s\tx%0d,%0x", mnemonic, rvfi_rd_addr, rvfi_pc_wdata);
433                       endfunction
434                     
435                       function void decode_b_insn(input string mnemonic);
436                         logic [31:0] branch_target;
437                         logic [31:0] imm;
438                     
439                         // We cannot use rvfi_pc_wdata for conditional jumps.
440        1/1              imm = $signed({ {19 {rvfi_insn[31]}}, rvfi_insn[31], rvfi_insn[7],
441                                  rvfi_insn[30:25], rvfi_insn[11:8], 1'b0 });
442        1/1              branch_target = rvfi_pc_rdata + imm;
443                     
444        1/1              data_accessed = RS1 | RS2 | RD;
445        1/1              decoded_str = $sformatf("%s\tx%0d,x%0d,%0x", mnemonic, rvfi_rs1_addr, rvfi_rs2_addr, branch_target);
446                       endfunction
447                     
448                       function void decode_csr_insn(input string mnemonic);
449                         logic [11:0] csr;
450                         string csr_name;
451        1/1              csr = rvfi_insn[31:20];
452        1/1              csr_name = get_csr_name(csr);
453                     
454        1/1              data_accessed = RD;
455                     
456        1/1              if (!rvfi_insn[14]) begin
457        1/1                data_accessed |= RS1;
458        1/1                decoded_str = $sformatf("%s\tx%0d,%s,x%0d", mnemonic, rvfi_rd_addr, csr_name, rvfi_rs1_addr);
459                         end else begin
460        1/1                decoded_str = $sformatf("%s\tx%0d,%s,%0d", mnemonic, rvfi_rd_addr, csr_name, { 27'b0, rvfi_insn[19:15]});
461                         end
462                       endfunction
463                     
464                       function void decode_cr_insn(input string mnemonic);
465        1/1              if (rvfi_rs2_addr == 5'b0) begin
466        1/1                if (rvfi_insn[12] == 1'b1) begin
467                             // C.JALR
468        1/1                  data_accessed = RS1 | RD;
469                           end else begin
470                             // C.JR
471        1/1                  data_accessed = RS1;
472                           end
473        1/1                decoded_str = $sformatf("%s\tx%0d", mnemonic, rvfi_rs1_addr);
474                         end else begin
475        1/1                data_accessed = RS1 | RS2 | RD; // RS1 == RD
476        1/1                decoded_str = $sformatf("%s\tx%0d,x%0d", mnemonic, rvfi_rd_addr, rvfi_rs2_addr);
477                         end
478                       endfunction
479                     
480                       function void decode_ci_cli_insn(input string mnemonic);
481                         logic [5:0] imm;
482        1/1              imm = {rvfi_insn[12], rvfi_insn[6:2]};
483        1/1              data_accessed = RD;
484        1/1              decoded_str = $sformatf("%s\tx%0d,%0d", mnemonic, rvfi_rd_addr, $signed(imm));
485                       endfunction
486                     
487                       function void decode_ci_caddi_insn(input string mnemonic);
488                         logic [5:0] nzimm;
489        1/1              nzimm = {rvfi_insn[12], rvfi_insn[6:2]};
490        1/1              data_accessed = RS1 | RD;
491        1/1              decoded_str = $sformatf("%s\tx%0d,%0d", mnemonic, rvfi_rd_addr, $signed(nzimm));
492                       endfunction
493                     
494                       function void decode_ci_caddi16sp_insn(input string mnemonic);
495                         logic [9:0] nzimm;
496        1/1              nzimm = {rvfi_insn[12], rvfi_insn[4:3], rvfi_insn[5], rvfi_insn[2], rvfi_insn[6], 4'b0};
497        1/1              data_accessed = RS1 | RD;
498        1/1              decoded_str = $sformatf("%s\tx%0d,%0d", mnemonic, rvfi_rd_addr, $signed(nzimm));
499                       endfunction
500                     
501                       function void decode_ci_clui_insn(input string mnemonic);
502                         logic [5:0] nzimm;
503        1/1              nzimm = {rvfi_insn[12], rvfi_insn[6:2]};
504        1/1              data_accessed = RD;
505        1/1              decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rd_addr, 20'($signed(nzimm)));
506                       endfunction
507                     
508                       function void decode_ci_cslli_insn(input string mnemonic);
509                         logic [5:0] shamt;
510        1/1              shamt = {rvfi_insn[12], rvfi_insn[6:2]};
511        1/1              data_accessed = RS1 | RD;
512        1/1              decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rd_addr, shamt);
513                       endfunction
514                     
515                       function void decode_ciw_insn(input string mnemonic);
516                         // C.ADDI4SPN
517                         logic [9:0] nzuimm;
518        1/1              nzuimm = {rvfi_insn[10:7], rvfi_insn[12:11], rvfi_insn[5], rvfi_insn[6], 2'b00};
519        1/1              data_accessed = RD;
520        1/1              decoded_str = $sformatf("%s\tx%0d,x2,%0d", mnemonic, rvfi_rd_addr, nzuimm);
521                       endfunction
522                     
523                       function void decode_cb_sr_insn(input string mnemonic);
524                         logic [5:0] shamt;
525        1/1              shamt = {rvfi_insn[12], rvfi_insn[6:2]};
526        1/1              data_accessed = RS1 | RD;
527        1/1              decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rs1_addr, shamt);
528                       endfunction
529                     
530                       function void decode_cb_insn(input string mnemonic);
531                         logic [7:0] imm;
532                         logic [31:0] jump_target;
533        1/1              if (rvfi_insn[15:13] == 3'b110 || rvfi_insn[15:13] == 3'b111) begin
534                           // C.BNEZ and C.BEQZ
535                           // We cannot use rvfi_pc_wdata for conditional jumps.
536        1/1                imm = {rvfi_insn[12], rvfi_insn[6:5], rvfi_insn[2], rvfi_insn[11:10], rvfi_insn[4:3]};
537        1/1                jump_target = rvfi_pc_rdata + 32'($signed({imm, 1'b0}));
538        1/1                data_accessed = RS1;
539        1/1                decoded_str = $sformatf("%s\tx%0d,%0x", mnemonic, rvfi_rs1_addr, jump_target);
540        1/1              end else if (rvfi_insn[15:13] == 3'b100) begin
541                           // C.ANDI
542        1/1                imm = {{2{rvfi_insn[12]}}, rvfi_insn[12], rvfi_insn[6:2]};
543        1/1                data_accessed = RS1 | RD; // RS1 == RD
544        1/1                decoded_str = $sformatf("%s\tx%0d,%0d", mnemonic, rvfi_rd_addr, $signed(imm));
545                         end else begin
546        0/1     ==>        imm = {rvfi_insn[12], rvfi_insn[6:2], 2'b00};
547        0/1     ==>        data_accessed = RS1;
548        0/1     ==>        decoded_str = $sformatf("%s\tx%0d,0x%0x", mnemonic, rvfi_rs1_addr, imm);
549                         end
550                       endfunction
551                     
552                       function void decode_cs_insn(input string mnemonic);
553        1/1              data_accessed = RS1 | RS2 | RD; // RS1 == RD
554        1/1              decoded_str = $sformatf("%s\tx%0d,x%0d", mnemonic, rvfi_rd_addr, rvfi_rs2_addr);
555                       endfunction
556                     
557                       function void decode_cj_insn(input string mnemonic);
558        1/1              if (rvfi_insn[15:13] == 3'b001) begin
559                           // C.JAL
560        1/1                data_accessed = RD;
561                         end
                        MISSING_ELSE
562        1/1              decoded_str = $sformatf("%s\t%0x", mnemonic, rvfi_pc_wdata);
563                       endfunction
564                     
565                       function void decode_compressed_load_insn(input string mnemonic);
566                         logic [7:0] imm;
567                     
568        1/1              if (rvfi_insn[1:0] == OPCODE_C0) begin
569                           // C.LW
570        1/1                imm = {1'b0, rvfi_insn[5], rvfi_insn[12:10], rvfi_insn[6], 2'b00};
571                         end else begin
572                           // C.LWSP
573        1/1                imm = {rvfi_insn[3:2], rvfi_insn[12], rvfi_insn[6:4], 2'b00};
574                         end
575        1/1              data_accessed = RS1 | RD | MEM;
576        1/1              decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)", mnemonic, rvfi_rd_addr, imm, rvfi_rs1_addr);
577                       endfunction
578                     
579                       function void decode_compressed_store_insn(input string mnemonic);
580                         logic [7:0] imm;
581        1/1              if (rvfi_insn[1:0] == OPCODE_C0) begin
582                           // C.SW
583        1/1                imm = {1'b0, rvfi_insn[5], rvfi_insn[12:10], rvfi_insn[6], 2'b00};
584                         end else begin
585                           // C.SWSP
586        1/1                imm = {rvfi_insn[8:7], rvfi_insn[12:9], 2'b00};
587                         end
588        1/1              data_accessed = RS1 | RS2 | MEM;
589        1/1              decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)", mnemonic, rvfi_rs2_addr, imm, rvfi_rs1_addr);
590                       endfunction
591                     
592                       function void decode_load_insn();
593                         string      mnemonic;
594                     
595                         /*
596                         Gives wrong results in Verilator < 4.020.
597                         See https://github.com/lowRISC/ibex/issues/372 and
598                         https://www.veripool.org/issues/1536-Verilator-Misoptimization-in-if-and-case-with-default-statement-inside-a-function
599                     
600                         unique case (rvfi_insn[14:12])
601                           3'b000: mnemonic = "lb";
602                           3'b001: mnemonic = "lh";
603                           3'b010: mnemonic = "lw";
604                           3'b100: mnemonic = "lbu";
605                           3'b101: mnemonic = "lhu";
606                           default: begin
607                             decode_mnemonic("INVALID");
608                             return;
609                           end
610                         endcase
611                         */
612                         logic [2:0] size;
613        1/1              size = rvfi_insn[14:12];
614        1/1              if (size == 3'b000) begin
615        1/1                mnemonic = "lb";
616        1/1              end else if (size == 3'b001) begin
617        1/1                mnemonic = "lh";
618        1/1              end else if (size == 3'b010) begin
619        1/1                mnemonic = "lw";
620        1/1              end else if (size == 3'b100) begin
621        1/1                mnemonic = "lbu";
622        1/1              end else if (size == 3'b101) begin
623        1/1                mnemonic = "lhu";
624                         end else begin
625        1/1                decode_mnemonic("INVALID");
626        1/1                return;
627                         end
628                     
629                     
630        1/1              data_accessed = RD | RS1 | MEM;
631        1/1              decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)", mnemonic, rvfi_rd_addr,
632                                         $signed({{20 {rvfi_insn[31]}}, rvfi_insn[31:20]}), rvfi_rs1_addr);
633                       endfunction
634                     
635                       function void decode_store_insn();
636                         string    mnemonic;
637                     
638        1/1              unique case (rvfi_insn[13:12])
639        1/1                2'b00:  mnemonic = "sb";
640        1/1                2'b01:  mnemonic = "sh";
641        1/1                2'b10:  mnemonic = "sw";
642                           default: begin
643        1/1                  decode_mnemonic("INVALID");
644        1/1                  return;
645                           end
646                         endcase
647                     
648        1/1              if (!rvfi_insn[14]) begin
649                           // regular store
650        1/1                data_accessed = RS1 | RS2 | MEM;
651        1/1                decoded_str = $sformatf("%s\tx%0d,%0d(x%0d)", mnemonic, rvfi_rs2_addr,
652                                           $signed({ {20 {rvfi_insn[31]}}, rvfi_insn[31:25], rvfi_insn[11:7] }), rvfi_rs1_addr);
653                         end else begin
654        1/1                decode_mnemonic("INVALID");
655                         end
656                       endfunction
657                     
658                       function string get_fence_description(logic [3:0] bits);
659                         string desc = "";
660        1/1              if (bits[3]) begin
661        1/1                desc = {desc, "i"};
662                         end
                        MISSING_ELSE
663        1/1              if (bits[2]) begin
664        1/1                desc = {desc, "o"};
665                         end
                        MISSING_ELSE
666        1/1              if (bits[1]) begin
667        1/1                desc = {desc, "r"};
668                         end
                        MISSING_ELSE
669        1/1              if (bits[0]) begin
670        1/1                desc = {desc, "w"};
671                         end
                        MISSING_ELSE
672        1/1              return desc;
673                       endfunction
674                     
675                       function void decode_fence();
676                         string predecessor;
677                         string successor;
678        1/1              predecessor = get_fence_description(rvfi_insn[27:24]);
679        1/1              successor = get_fence_description(rvfi_insn[23:20]);
680        1/1              decoded_str = $sformatf("fence\t%s,%s", predecessor, successor);
681                       endfunction
682                     
683                       // cycle counter
684                       always_ff @(posedge clk_i or negedge rst_ni) begin
685        1/1              if (!rst_ni) begin
686        1/1                cycle <= 0;
687                         end else begin
688        1/1                cycle <= cycle + 1;
689                         end
690                       end
691                     
692                       // close output file for writing
693                       final begin
694        1/1              if (file_handle != 32'h0) begin
695        1/1                $fclose(file_handle);
696                         end
                   ==>  MISSING_ELSE
697                       end
698                     
699                       // log execution
700                       always_ff @(posedge clk_i) begin
701        1/1              if (rvfi_valid) begin
702        1/1                printbuffer_dumpline();
703                         end
                        MISSING_ELSE
704                       end
705                     
706                       always_comb begin
707        1/1              decoded_str = "";
708        1/1              data_accessed = 4'h0;
709        1/1              insn_is_compressed = 0;
710                     
711                         // Check for compressed instructions
712        1/1              if (rvfi_insn[1:0] != 2'b11) begin
713        1/1                insn_is_compressed = 1;
714                           // Separate case to avoid overlapping decoding
715        1/1                if (rvfi_insn[15:13] == 3'b100 && rvfi_insn[1:0] == 2'b10) begin
716        1/1                  if (rvfi_insn[12]) begin
717        1/1                    if (rvfi_insn[11:2] == 10'h0) begin
718        1/1                      decode_mnemonic("c.ebreak");
719        1/1                    end else if (rvfi_insn[6:2] == 5'b0) begin
720        1/1                      decode_cr_insn("c.jalr");
721                               end else begin
722        1/1                      decode_cr_insn("c.add");
723                               end
724                             end else begin
725        1/1                    if (rvfi_insn[6:2] == 5'h0) begin
726        1/1                      decode_cr_insn("c.jr");
727                               end else begin
728        1/1                      decode_cr_insn("c.mv");
729                               end
730                             end
731                           end else begin
732        1/1                  unique casez (rvfi_insn[15:0])
733                               // C0 Opcodes
734                               INSN_CADDI4SPN: begin
735        1/1                      if (rvfi_insn[12:2] == 11'h0) begin
736                                   // Align with pseudo-mnemonic used by GNU binutils and LLVM's MC layer
737        1/1                        decode_mnemonic("c.unimp");
738                                 end else begin
739        1/1                        decode_ciw_insn("c.addi4spn");
740                                 end
741                               end
742        1/1                    INSN_CLW:        decode_compressed_load_insn("c.lw");
743        1/1                    INSN_CSW:        decode_compressed_store_insn("c.sw");
744                               // C1 Opcodes
745        1/1                    INSN_CADDI:      decode_ci_caddi_insn("c.addi");
746        1/1                    INSN_CJAL:       decode_cj_insn("c.jal");
747        1/1                    INSN_CJ:         decode_cj_insn("c.j");
748        1/1                    INSN_CLI:        decode_ci_cli_insn("c.li");
749                               INSN_CLUI: begin
750                                 // These two instructions share opcode
751        1/1                      if (rvfi_insn[11:7] == 5'd2) begin
752        1/1                        decode_ci_caddi16sp_insn("c.addi16sp");
753                                 end else begin
754        1/1                        decode_ci_clui_insn("c.lui");
755                                 end
756                               end
757        1/1                    INSN_CSRLI:      decode_cb_sr_insn("c.srli");
758        1/1                    INSN_CSRAI:      decode_cb_sr_insn("c.srai");
759        1/1                    INSN_CANDI:      decode_cb_insn("c.andi");
760        1/1                    INSN_CSUB:       decode_cs_insn("c.sub");
761        1/1                    INSN_CXOR:       decode_cs_insn("c.xor");
762        1/1                    INSN_COR:        decode_cs_insn("c.or");
763        1/1                    INSN_CAND:       decode_cs_insn("c.and");
764        1/1                    INSN_CBEQZ:      decode_cb_insn("c.beqz");
765        1/1                    INSN_CBNEZ:      decode_cb_insn("c.bnez");
766                               // C2 Opcodes
767        1/1                    INSN_CSLLI:      decode_ci_cslli_insn("c.slli");
768        1/1                    INSN_CLWSP:      decode_compressed_load_insn("c.lwsp");
769        1/1                    INSN_SWSP:       decode_compressed_store_insn("c.swsp");
770        1/1                    default:         decode_mnemonic("INVALID");
771                             endcase
772                           end
773                         end else begin
774        1/1                unique casez (rvfi_insn)
775                             // Regular opcodes
776        1/1                  INSN_LUI:        decode_u_insn("lui");
777        1/1                  INSN_AUIPC:      decode_u_insn("auipc");
778        1/1                  INSN_JAL:        decode_j_insn("jal");
779        1/1                  INSN_JALR:       decode_i_jalr_insn("jalr");
780                             // BRANCH
781        1/1                  INSN_BEQ:        decode_b_insn("beq");
782        1/1                  INSN_BNE:        decode_b_insn("bne");
783        1/1                  INSN_BLT:        decode_b_insn("blt");
784        1/1                  INSN_BGE:        decode_b_insn("bge");
785        1/1                  INSN_BLTU:       decode_b_insn("bltu");
786        1/1                  INSN_BGEU:       decode_b_insn("bgeu");
787                             // OPIMM
788                             INSN_ADDI: begin
789        1/1                    if (rvfi_insn == 32'h00_00_00_13) begin
790                                 // TODO: objdump doesn't decode this as nop currently, even though it would be helpful
791                                 // Decide what to do here: diverge from objdump, or make the trace less readable to
792                                 // users.
793                                 //decode_mnemonic("nop");
794        1/1                      decode_i_insn("addi");
795                               end else begin
796        1/1                      decode_i_insn("addi");
797                               end
798                             end
799        1/1                  INSN_SLTI:       decode_i_insn("slti");
800        1/1                  INSN_SLTIU:      decode_i_insn("sltiu");
801        1/1                  INSN_XORI:       decode_i_insn("xori");
802        1/1                  INSN_ORI:        decode_i_insn("ori");
803        1/1                  INSN_ANDI:       decode_i_insn("andi");
804        1/1                  INSN_SLLI:       decode_i_shift_insn("slli");
805        1/1                  INSN_SRLI:       decode_i_shift_insn("srli");
806        1/1                  INSN_SRAI:       decode_i_shift_insn("srai");
807                             // OP
808        1/1                  INSN_ADD:        decode_r_insn("add");
809        1/1                  INSN_SUB:        decode_r_insn("sub");
810        1/1                  INSN_SLL:        decode_r_insn("sll");
811        1/1                  INSN_SLT:        decode_r_insn("slt");
812        1/1                  INSN_SLTU:       decode_r_insn("sltu");
813        1/1                  INSN_XOR:        decode_r_insn("xor");
814        1/1                  INSN_SRL:        decode_r_insn("srl");
815        1/1                  INSN_SRA:        decode_r_insn("sra");
816        1/1                  INSN_OR:         decode_r_insn("or");
817        1/1                  INSN_AND:        decode_r_insn("and");
818                             // SYSTEM (CSR manipulation)
819        1/1                  INSN_CSRRW:      decode_csr_insn("csrrw");
820        1/1                  INSN_CSRRS:      decode_csr_insn("csrrs");
821        1/1                  INSN_CSRRC:      decode_csr_insn("csrrc");
822        1/1                  INSN_CSRRWI:     decode_csr_insn("csrrwi");
823        1/1                  INSN_CSRRSI:     decode_csr_insn("csrrsi");
824        1/1                  INSN_CSRRCI:     decode_csr_insn("csrrci");
825                             // SYSTEM (others)
826        1/1                  INSN_ECALL:      decode_mnemonic("ecall");
827        1/1                  INSN_EBREAK:     decode_mnemonic("ebreak");
828        1/1                  INSN_MRET:       decode_mnemonic("mret");
829        1/1                  INSN_DRET:       decode_mnemonic("dret");
830        1/1                  INSN_WFI:        decode_mnemonic("wfi");
831                             // RV32M
832        1/1                  INSN_PMUL:       decode_r_insn("mul");
833        1/1                  INSN_PMUH:       decode_r_insn("mulh");
834        1/1                  INSN_PMULHSU:    decode_r_insn("mulhsu");
835        1/1                  INSN_PMULHU:     decode_r_insn("mulhu");
836        1/1                  INSN_DIV:        decode_r_insn("div");
837        1/1                  INSN_DIVU:       decode_r_insn("divu");
838        1/1                  INSN_REM:        decode_r_insn("rem");
839        1/1                  INSN_REMU:       decode_r_insn("remu");
840                             // LOAD & STORE
841        1/1                  INSN_LOAD:       decode_load_insn();
842        1/1                  INSN_STORE:      decode_store_insn();
843                             // MISC-MEM
844        1/1                  INSN_FENCE:      decode_fence();
845        1/1                  INSN_FENCEI:     decode_mnemonic("fence.i");
846        1/1                  default:         decode_mnemonic("INVALID");

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_tracer
         Line No. Total Covered Percent 
Branches          88    87      98.86   
IF       685      2     2       100.00  
IF       694      2     1       50.00   
IF       701      2     2       100.00  
IF       712      82    82      100.00  


685            if (!rst_ni) begin
               -1-  
686              cycle <= 0;
                 ==>
687            end else begin
688              cycle <= cycle + 1;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


694            if (file_handle != 32'h0) begin
               -1-  
695              $fclose(file_handle);
                 ==>
696            end
               MISSING_ELSE
               ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


701            if (rvfi_valid) begin
               -1-  
702              printbuffer_dumpline();
                 ==>
703            end
               MISSING_ELSE
               ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


712            if (rvfi_insn[1:0] != 2'b11) begin
               -1-  
713              insn_is_compressed = 1;
714              // Separate case to avoid overlapping decoding
715              if (rvfi_insn[15:13] == 3'b100 && rvfi_insn[1:0] == 2'b10) begin
                 -2-  
716                if (rvfi_insn[12]) begin
                   -3-  
717                  if (rvfi_insn[11:2] == 10'h0) begin
                     -4-  
718                    decode_mnemonic("c.ebreak");
                       ==>
719                  end else if (rvfi_insn[6:2] == 5'b0) begin
                              -5-  
720                    decode_cr_insn("c.jalr");
                       ==>
721                  end else begin
722                    decode_cr_insn("c.add");
                       ==>
723                  end
724                end else begin
725                  if (rvfi_insn[6:2] == 5'h0) begin
                     -6-  
726                    decode_cr_insn("c.jr");
                       ==>
727                  end else begin
728                    decode_cr_insn("c.mv");
                       ==>
729                  end
730                end
731              end else begin
732                unique casez (rvfi_insn[15:0])
                          -7-  
733                  // C0 Opcodes
734                  INSN_CADDI4SPN: begin
735                    if (rvfi_insn[12:2] == 11'h0) begin
                       -8-  
736                      // Align with pseudo-mnemonic used by GNU binutils and LLVM's MC layer
737                      decode_mnemonic("c.unimp");
                         ==>
738                    end else begin
739                      decode_ciw_insn("c.addi4spn");
                         ==>
740                    end
741                  end
742                  INSN_CLW:        decode_compressed_load_insn("c.lw");
                     ==>
743                  INSN_CSW:        decode_compressed_store_insn("c.sw");
                     ==>
744                  // C1 Opcodes
745                  INSN_CADDI:      decode_ci_caddi_insn("c.addi");
                     ==>
746                  INSN_CJAL:       decode_cj_insn("c.jal");
                     ==>
747                  INSN_CJ:         decode_cj_insn("c.j");
                     ==>
748                  INSN_CLI:        decode_ci_cli_insn("c.li");
                     ==>
749                  INSN_CLUI: begin
750                    // These two instructions share opcode
751                    if (rvfi_insn[11:7] == 5'd2) begin
                       -9-  
752                      decode_ci_caddi16sp_insn("c.addi16sp");
                         ==>
753                    end else begin
754                      decode_ci_clui_insn("c.lui");
                         ==>
755                    end
756                  end
757                  INSN_CSRLI:      decode_cb_sr_insn("c.srli");
                     ==>
758                  INSN_CSRAI:      decode_cb_sr_insn("c.srai");
                     ==>
759                  INSN_CANDI:      decode_cb_insn("c.andi");
                     ==>
760                  INSN_CSUB:       decode_cs_insn("c.sub");
                     ==>
761                  INSN_CXOR:       decode_cs_insn("c.xor");
                     ==>
762                  INSN_COR:        decode_cs_insn("c.or");
                     ==>
763                  INSN_CAND:       decode_cs_insn("c.and");
                     ==>
764                  INSN_CBEQZ:      decode_cb_insn("c.beqz");
                     ==>
765                  INSN_CBNEZ:      decode_cb_insn("c.bnez");
                     ==>
766                  // C2 Opcodes
767                  INSN_CSLLI:      decode_ci_cslli_insn("c.slli");
                     ==>
768                  INSN_CLWSP:      decode_compressed_load_insn("c.lwsp");
                     ==>
769                  INSN_SWSP:       decode_compressed_store_insn("c.swsp");
                     ==>
770                  default:         decode_mnemonic("INVALID");
                     ==>
771                endcase
772              end
773            end else begin
774              unique casez (rvfi_insn)
                        -10-  
775                // Regular opcodes
776                INSN_LUI:        decode_u_insn("lui");
                   ==>
777                INSN_AUIPC:      decode_u_insn("auipc");
                   ==>
778                INSN_JAL:        decode_j_insn("jal");
                   ==>
779                INSN_JALR:       decode_i_jalr_insn("jalr");
                   ==>
780                // BRANCH
781                INSN_BEQ:        decode_b_insn("beq");
                   ==>
782                INSN_BNE:        decode_b_insn("bne");
                   ==>
783                INSN_BLT:        decode_b_insn("blt");
                   ==>
784                INSN_BGE:        decode_b_insn("bge");
                   ==>
785                INSN_BLTU:       decode_b_insn("bltu");
                   ==>
786                INSN_BGEU:       decode_b_insn("bgeu");
                   ==>
787                // OPIMM
788                INSN_ADDI: begin
789                  if (rvfi_insn == 32'h00_00_00_13) begin
                     -11-  
790                    // TODO: objdump doesn't decode this as nop currently, even though it would be helpful
791                    // Decide what to do here: diverge from objdump, or make the trace less readable to
792                    // users.
793                    //decode_mnemonic("nop");
794                    decode_i_insn("addi");
                       ==>
795                  end else begin
796                    decode_i_insn("addi");
                       ==>
797                  end
798                end
799                INSN_SLTI:       decode_i_insn("slti");
                   ==>
800                INSN_SLTIU:      decode_i_insn("sltiu");
                   ==>
801                INSN_XORI:       decode_i_insn("xori");
                   ==>
802                INSN_ORI:        decode_i_insn("ori");
                   ==>
803                INSN_ANDI:       decode_i_insn("andi");
                   ==>
804                INSN_SLLI:       decode_i_shift_insn("slli");
                   ==>
805                INSN_SRLI:       decode_i_shift_insn("srli");
                   ==>
806                INSN_SRAI:       decode_i_shift_insn("srai");
                   ==>
807                // OP
808                INSN_ADD:        decode_r_insn("add");
                   ==>
809                INSN_SUB:        decode_r_insn("sub");
                   ==>
810                INSN_SLL:        decode_r_insn("sll");
                   ==>
811                INSN_SLT:        decode_r_insn("slt");
                   ==>
812                INSN_SLTU:       decode_r_insn("sltu");
                   ==>
813                INSN_XOR:        decode_r_insn("xor");
                   ==>
814                INSN_SRL:        decode_r_insn("srl");
                   ==>
815                INSN_SRA:        decode_r_insn("sra");
                   ==>
816                INSN_OR:         decode_r_insn("or");
                   ==>
817                INSN_AND:        decode_r_insn("and");
                   ==>
818                // SYSTEM (CSR manipulation)
819                INSN_CSRRW:      decode_csr_insn("csrrw");
                   ==>
820                INSN_CSRRS:      decode_csr_insn("csrrs");
                   ==>
821                INSN_CSRRC:      decode_csr_insn("csrrc");
                   ==>
822                INSN_CSRRWI:     decode_csr_insn("csrrwi");
                   ==>
823                INSN_CSRRSI:     decode_csr_insn("csrrsi");
                   ==>
824                INSN_CSRRCI:     decode_csr_insn("csrrci");
                   ==>
825                // SYSTEM (others)
826                INSN_ECALL:      decode_mnemonic("ecall");
                   ==>
827                INSN_EBREAK:     decode_mnemonic("ebreak");
                   ==>
828                INSN_MRET:       decode_mnemonic("mret");
                   ==>
829                INSN_DRET:       decode_mnemonic("dret");
                   ==>
830                INSN_WFI:        decode_mnemonic("wfi");
                   ==>
831                // RV32M
832                INSN_PMUL:       decode_r_insn("mul");
                   ==>
833                INSN_PMUH:       decode_r_insn("mulh");
                   ==>
834                INSN_PMULHSU:    decode_r_insn("mulhsu");
                   ==>
835                INSN_PMULHU:     decode_r_insn("mulhu");
                   ==>
836                INSN_DIV:        decode_r_insn("div");
                   ==>
837                INSN_DIVU:       decode_r_insn("divu");
                   ==>
838                INSN_REM:        decode_r_insn("rem");
                   ==>
839                INSN_REMU:       decode_r_insn("remu");
                   ==>
840                // LOAD & STORE
841                INSN_LOAD:       decode_load_insn();
                   ==>
842                INSN_STORE:      decode_store_insn();
                   ==>
843                // MISC-MEM
844                INSN_FENCE:      decode_fence();
                   ==>
845                INSN_FENCEI:     decode_mnemonic("fence.i");
                   ==>
846                default:         decode_mnemonic("INVALID");
                   ==>

Branches:

-1- -2- -3- -4- -5- -6- -7-                              -8- -9- -10-                           -11- Status  
1   1   1   1   -   -   -                                -   -   -                              -    Covered 
1   1   1   0   1   -   -                                -   -   -                              -    Covered 
1   1   1   0   0   -   -                                -   -   -                              -    Covered 
1   1   0   -   -   1   -                                -   -   -                              -    Covered 
1   1   0   -   -   0   -                                -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CADDI4SPN  1   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CADDI4SPN  0   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLW        -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSW        -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CADDI      -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CJAL       -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CJ         -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLI        -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLUI       -   1   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLUI       -   0   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSRLI      -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSRAI      -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CANDI      -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSUB       -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CXOR       -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_COR        -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CAND       -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CBEQZ      -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CBNEZ      -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CSLLI      -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_CLWSP      -   -   -                              -    Covered 
1   0   -   -   -   -   ibex_tracer_pkg::INSN_SWSP       -   -   -                              -    Covered 
1   0   -   -   -   -   default                          -   -   -                              -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_LUI      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_AUIPC    -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_JAL      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_JALR     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BEQ      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BNE      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BLT      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BGE      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BLTU     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_BGEU     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ADDI     1    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ADDI     0    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLTI     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLTIU    -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_XORI     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ORI      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ANDI     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLLI     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SRLI     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SRAI     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ADD      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SUB      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLL      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLT      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SLTU     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_XOR      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SRL      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_SRA      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_OR       -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_AND      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRW    -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRS    -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRC    -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRWI   -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRSI   -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_CSRRCI   -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_ECALL    -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_EBREAK   -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_MRET     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_DRET     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_WFI      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PMUL     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PMUH     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PMULHSU  -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_PMULHU   -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_DIV      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_DIVU     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_REM      -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_REMU     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_LOAD     -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_STORE    -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_FENCE    -    Covered 
0   -   -   -   -   -   -                                -   -   ibex_tracer_pkg::INSN_FENCEI   -    Covered 
0   -   -   -   -   -   -                                -   -   default                        -    Covered 


===============================================================================
Module : ibex_controller
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 85.13  98.07 --      66.67  90.67 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_controller.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                                     
 85.13  98.07 --      66.67  90.67 --     core_ibex_tb_top.dut.u_ibex_core.id_stage_i.controller_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_controller

             Line No.   Total   Covered  Percent
TOTAL                      207      203    98.07
ALWAYS            140        0        0
ALWAYS            218       31       30    96.77
ALWAYS            244      161      158    98.14
ALWAYS            620       15       15   100.00

139                         // print warning in case of decoding errors
140        unreachable      if ((ctrl_fsm_cs == DECODE) && instr_valid_i && !instr_fetch_err_i && illegal_insn_d) begin
141        unreachable        $display("%t: Illegal instruction (hart %0x) at PC 0x%h: 0x%h", $time, ibex_core.hart_id_i,
142                                    ibex_id_stage.pc_id_i, ibex_id_stage.instr_rdata_i);
143                         end
                   ==>  MISSING_ELSE
144                       end
145                       // synopsys translate_on
146                     `endif
147                     
148                       ////////////////
149                       // Exceptions //
150                       ////////////////
151                     
152                       assign load_err_d  = load_err_i;
153                       assign store_err_d = store_err_i;
154                     
155                       // Decoder doesn't take instr_valid into account, factor it in here.
156                       assign ecall_insn      = ecall_insn_i      & instr_valid_i;
157                       assign mret_insn       = mret_insn_i       & instr_valid_i;
158                       assign dret_insn       = dret_insn_i       & instr_valid_i;
159                       assign wfi_insn        = wfi_insn_i        & instr_valid_i;
160                       assign ebrk_insn       = ebrk_insn_i       & instr_valid_i;
161                       assign csr_pipe_flush  = csr_pipe_flush_i  & instr_valid_i;
162                       assign instr_fetch_err = instr_fetch_err_i & instr_valid_i;
163                     
164                       // "Executing DRET outside of Debug Mode causes an illegal instruction exception."
165                       // [Debug Spec v0.13.2, p.41]
166                       assign illegal_dret = dret_insn & ~debug_mode_q;
167                     
168                       // Some instructions can only be executed in M-Mode
169                       assign illegal_umode = (priv_mode_i != PRIV_LVL_M) &
170                                              // MRET must be in M-Mode. TW means trap WFI to M-Mode.
171                                              (mret_insn | (csr_mstatus_tw_i & wfi_insn));
172                     
173                       // This is recorded in the illegal_insn_q flop to help timing.  Specifically
174                       // it is needed to break the path from ibex_cs_registers/illegal_csr_insn_o
175                       // to pc_set_o.  Clear when controller is in FLUSH so it won't remain set
176                       // once illegal instruction is handled.
177                       assign illegal_insn_d = (illegal_insn_i | illegal_dret | illegal_umode) & (ctrl_fsm_cs != FLUSH);
178                     
179                       // exception requests
180                       // requests are flopped in exc_req_q.  This is cleared when controller is in
181                       // the FLUSH state so the cycle following exc_req_q won't remain set for an
182                       // exception request that has just been handled.
183                       assign exc_req_d = (ecall_insn | ebrk_insn | illegal_insn_d | instr_fetch_err) &
184                                          (ctrl_fsm_cs != FLUSH);
185                     
186                       // LSU exception requests
187                       assign exc_req_lsu = store_err_i | load_err_i;
188                     
189                       // special requests: special instructions, pipeline flushes, exceptions...
190                       assign special_req = mret_insn | dret_insn | wfi_insn | csr_pipe_flush |
191                           exc_req_d | exc_req_lsu;
192                     
193                       ////////////////
194                       // Interrupts //
195                       ////////////////
196                     
197                       // Enter debug mode due to an external debug_req_i or because the core is in
198                       // single step mode (dcsr.step == 1). Single step must be qualified with
199                       // instruction valid otherwise the core will immediately enter debug mode
200                       // due to a recently flushed IF (or a delay in an instruction returning from
201                       // memory) before it has had anything to single step.
202                       // Also enter debug mode on a trigger match (hardware breakpoint)
203                       assign enter_debug_mode = (debug_req_i | (debug_single_step_i & instr_valid_i) |
204                                                  trigger_match_i) & ~debug_mode_q;
205                     
206                       // Set when an ebreak should enter debug mode rather than jump to exception
207                       // handler
208                       assign ebreak_into_debug = priv_mode_i == PRIV_LVL_M ? debug_ebreakm_i :
209                                                  priv_mode_i == PRIV_LVL_U ? debug_ebreaku_i :
210                                                                              1'b0;
211                     
212                       // interrupts including NMI are ignored while in debug mode [Debug Spec v0.13.2, p.39]
213                       assign handle_irq       = ~debug_mode_q &
214                           ((irq_nm_i & ~nmi_mode_q) | (irq_pending_i & csr_mstatus_mie_i));
215                     
216                       // generate ID of fast interrupts, highest priority to highest ID
217                       always_comb begin : gen_mfip_id
218        2/2              if      (csr_mfip_i[14]) mfip_id = 4'd14;
219        2/2              else if (csr_mfip_i[13]) mfip_id = 4'd13;
220        2/2              else if (csr_mfip_i[12]) mfip_id = 4'd12;
221        2/2              else if (csr_mfip_i[11]) mfip_id = 4'd11;
222        2/2              else if (csr_mfip_i[10]) mfip_id = 4'd10;
223        2/2              else if (csr_mfip_i[ 9]) mfip_id = 4'd9;
224        2/2              else if (csr_mfip_i[ 8]) mfip_id = 4'd8;
225        2/2              else if (csr_mfip_i[ 7]) mfip_id = 4'd7;
226        2/2              else if (csr_mfip_i[ 6]) mfip_id = 4'd6;
227        2/2              else if (csr_mfip_i[ 5]) mfip_id = 4'd5;
228        1/2     ==>      else if (csr_mfip_i[ 5]) mfip_id = 4'd5;
229        2/2              else if (csr_mfip_i[ 4]) mfip_id = 4'd4;
230        2/2              else if (csr_mfip_i[ 3]) mfip_id = 4'd3;
231        2/2              else if (csr_mfip_i[ 2]) mfip_id = 4'd2;
232        2/2              else if (csr_mfip_i[ 1]) mfip_id = 4'd1;
233        1/1              else                     mfip_id = 4'd0;
234                       end
235                     
236                       assign unused_csr_mtip = csr_mtip_i;
237                     
238                       /////////////////////
239                       // Core controller //
240                       /////////////////////
241                     
242                       always_comb begin
243                         // Default values
244        1/1              instr_req_o           = 1'b1;
245                     
246        1/1              csr_save_if_o         = 1'b0;
247        1/1              csr_save_id_o         = 1'b0;
248        1/1              csr_restore_mret_id_o = 1'b0;
249        1/1              csr_restore_dret_id_o = 1'b0;
250        1/1              csr_save_cause_o      = 1'b0;
251        1/1              csr_mtval_o           = '0;
252                     
253        1/1              pc_mux_o              = PC_BOOT;
254        1/1              pc_set_o              = 1'b0;
255                     
256        1/1              exc_pc_mux_o          = EXC_PC_IRQ;
257        1/1              exc_cause_o           = EXC_CAUSE_INSN_ADDR_MISA; // = 6'h00
258                     
259        1/1              ctrl_fsm_ns           = ctrl_fsm_cs;
260                     
261        1/1              ctrl_busy_o           = 1'b1;
262                     
263        1/1              halt_if               = 1'b0;
264        1/1              flush_id              = 1'b0;
265                     
266        1/1              debug_csr_save_o      = 1'b0;
267        1/1              debug_cause_o         = DBG_CAUSE_EBREAK;
268        1/1              debug_mode_d          = debug_mode_q;
269        1/1              nmi_mode_d            = nmi_mode_q;
270                     
271        1/1              perf_tbranch_o        = 1'b0;
272        1/1              perf_jump_o           = 1'b0;
273                     
274        1/1              unique case (ctrl_fsm_cs)
275                           RESET: begin
276                             // just wait for fetch_enable
277        1/1                  instr_req_o   = 1'b0;
278        1/1                  pc_mux_o      = PC_BOOT;
279        1/1                  pc_set_o      = 1'b1;
280        1/1                  if (fetch_enable_i) begin
281        1/1                    ctrl_fsm_ns = BOOT_SET;
282                             end
                        MISSING_ELSE
283                           end
284                     
285                           BOOT_SET: begin
286                             // copy boot address to instr fetch address
287        1/1                  instr_req_o   = 1'b1;
288        1/1                  pc_mux_o      = PC_BOOT;
289        1/1                  pc_set_o      = 1'b1;
290                     
291        1/1                  ctrl_fsm_ns = FIRST_FETCH;
292                           end
293                     
294                           WAIT_SLEEP: begin
295        1/1                  ctrl_busy_o   = 1'b0;
296        1/1                  instr_req_o   = 1'b0;
297        1/1                  halt_if       = 1'b1;
298        1/1                  flush_id      = 1'b1;
299        1/1                  ctrl_fsm_ns   = SLEEP;
300                           end
301                     
302                           SLEEP: begin
303                             // instruction in IF stage is already valid
304                             // we begin execution when an interrupt has arrived
305        1/1                  instr_req_o   = 1'b0;
306        1/1                  halt_if       = 1'b1;
307        1/1                  flush_id      = 1'b1;
308                     
309                             // normal execution flow
310                             // in debug mode or single step mode we leave immediately (wfi=nop)
311        1/1                  if (irq_nm_i || irq_pending_i || debug_req_i || debug_mode_q || debug_single_step_i) begin
312        1/1                    ctrl_fsm_ns = FIRST_FETCH;
313                             end else begin
314                               // Make sure clock remains disabled.
315        1/1                    ctrl_busy_o = 1'b0;
316                             end
317                           end
318                     
319                           FIRST_FETCH: begin
320                             // Stall because of IF miss
321        1/1                  if (id_in_ready_o) begin
322        1/1                    ctrl_fsm_ns = DECODE;
323                             end
                        MISSING_ELSE
324                     
325                             // handle interrupts
326        1/1                  if (handle_irq) begin
327                               // This assumes that the pipeline is always flushed before
328                               // going to sleep.
329        1/1                    ctrl_fsm_ns = IRQ_TAKEN;
330        1/1                    halt_if     = 1'b1;
331        1/1                    flush_id    = 1'b1;
332                             end
                        MISSING_ELSE
333                     
334                             // enter debug mode
335        1/1                  if (enter_debug_mode) begin
336        0/1     ==>            ctrl_fsm_ns = DBG_TAKEN_IF;
337                               // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the
338                               // ID state is needed for correct debug mode entry
339        0/1     ==>            halt_if     = 1'b1;
340                             end
                        MISSING_ELSE
341                           end
342                     
343                           DECODE: begin
344                             // normal operating mode of the ID stage, in case of debug and interrupt requests,
345                             // priorities are as follows (lower number == higher priority)
346                             // 1. currently running (multicycle) instructions and exceptions caused by these
347                             // 2. debug requests
348                             // 3. interrupt requests
349                     
350        1/1                  if (instr_valid_i) begin
351                     
352                               // get ready for special instructions, exceptions, pipeline flushes
353        1/1                    if (special_req) begin
354                                 // Halt IF but don't flush ID. This leaves a valid instruction in
355                                 // ID so controller can determine appropriate action in the
356                                 // FLUSH state.
357        1/1                      ctrl_fsm_ns = FLUSH;
358        1/1                      halt_if     = 1'b1;
359                               // set PC in IF stage to branch or jump target
360        1/1                    end else if (branch_set_i || jump_set_i) begin
361        1/1                      pc_mux_o       = PC_JUMP;
362        1/1                      pc_set_o       = 1'b1;
363                     
364        1/1                      perf_tbranch_o = branch_set_i;
365        1/1                      perf_jump_o    = jump_set_i;
366                               end
                        MISSING_ELSE
367                     
368                               // If entering debug mode or handling an IRQ the core needs to wait
369                               // until the current instruction has finished executing. Stall IF
370                               // during that time.
371        1/1                    if ((enter_debug_mode || handle_irq) && stall) begin
372        1/1                      halt_if = 1'b1;
373                               end
                        MISSING_ELSE
374                             end // instr_valid_i
                        MISSING_ELSE
375                     
376        1/1                  if (!stall && !special_req) begin
377        1/1                    if (enter_debug_mode) begin
378                                 // enter debug mode
379        1/1                      ctrl_fsm_ns = DBG_TAKEN_IF;
380                                 // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the
381                                 // ID state is needed for correct debug mode entry
382        1/1                      halt_if     = 1'b1;
383        1/1                    end else if (handle_irq) begin
384                                 // handle interrupt (not in debug mode)
385        1/1                      ctrl_fsm_ns = IRQ_TAKEN;
386        1/1                      halt_if     = 1'b1;
387        1/1                      flush_id    = 1'b1;
388                               end
                        MISSING_ELSE
389                             end
                        MISSING_ELSE
390                     
391                           end // DECODE
392                     
393                           IRQ_TAKEN: begin
394        1/1                  if (handle_irq) begin
395        1/1                    pc_mux_o         = PC_EXC;
396        1/1                    pc_set_o         = 1'b1;
397        1/1                    exc_pc_mux_o     = EXC_PC_IRQ;
398                     
399        1/1                    csr_save_if_o    = 1'b1;
400        1/1                    csr_save_cause_o = 1'b1;
401                     
402                               // interrupt priorities according to Privileged Spec v1.11 p.31
403        1/1                    if (irq_nm_i && !nmi_mode_q) begin
404        1/1                      exc_cause_o = EXC_CAUSE_IRQ_NM;
405        1/1                      nmi_mode_d  = 1'b1; // enter NMI mode
406        1/1                    end else if (csr_mfip_i != 15'b0) begin
407                                 // generate exception cause ID from fast interrupt ID:
408                                 // - first bit distinguishes interrupts from exceptions,
409                                 // - second bit adds 16 to fast interrupt ID
410                                 // for example EXC_CAUSE_IRQ_FAST_0 = {1'b1, 5'd16}
411        1/1                      exc_cause_o = exc_cause_e'({2'b11, mfip_id});
412        1/1                    end else if (csr_meip_i) begin
413        1/1                      exc_cause_o = EXC_CAUSE_IRQ_EXTERNAL_M;
414        1/1                    end else if (csr_msip_i) begin
415        1/1                      exc_cause_o = EXC_CAUSE_IRQ_SOFTWARE_M;
416                               end else begin // csr_mtip_i
417        0/1     ==>              exc_cause_o = EXC_CAUSE_IRQ_TIMER_M;
418                               end
419                             end
                   ==>  MISSING_ELSE
420                     
421        1/1                  ctrl_fsm_ns = DECODE;
422                           end
423                     
424                           DBG_TAKEN_IF: begin
425                             // enter debug mode and save PC in IF to dpc
426                             // jump to debug exception handler in debug memory
427        1/1                  if (debug_single_step_i || debug_req_i || trigger_match_i) begin
428        1/1                    flush_id         = 1'b1;
429        1/1                    pc_mux_o         = PC_EXC;
430        1/1                    pc_set_o         = 1'b1;
431        1/1                    exc_pc_mux_o     = EXC_PC_DBD;
432                     
433        1/1                    csr_save_if_o    = 1'b1;
434        1/1                    debug_csr_save_o = 1'b1;
435                     
436        1/1                    csr_save_cause_o = 1'b1;
437        1/1                    if (trigger_match_i) begin
438        unreachable              debug_cause_o = DBG_CAUSE_TRIGGER;
439        1/1                    end else if (debug_single_step_i) begin
440        1/1                      debug_cause_o = DBG_CAUSE_STEP;
441                               end else begin
442        1/1                      debug_cause_o = DBG_CAUSE_HALTREQ;
443                               end
444                     
445                               // enter debug mode
446        1/1                    debug_mode_d = 1'b1;
447                             end
                        MISSING_ELSE
448                     
449        1/1                  ctrl_fsm_ns  = DECODE;
450                           end
451                     
452                           DBG_TAKEN_ID: begin
453                             // enter debug mode and save PC in ID to dpc, used when encountering
454                             // 1. EBREAK during debug mode
455                             // 2. EBREAK with forced entry into debug mode (ebreakm or ebreaku set).
456                             // regular ebreak's go through FLUSH.
457                             //
458                             // for 1. do not update dcsr and dpc, for 2. do so [Debug Spec v0.13.2, p.39]
459                             // jump to debug exception handler in debug memory
460        1/1                  flush_id     = 1'b1;
461        1/1                  pc_mux_o     = PC_EXC;
462        1/1                  pc_set_o     = 1'b1;
463        1/1                  exc_pc_mux_o = EXC_PC_DBD;
464                     
465                             // update dcsr and dpc
466        1/1                  if (ebreak_into_debug && !debug_mode_q) begin // ebreak with forced entry
467                     
468                               // dpc (set to the address of the EBREAK, i.e. set to PC in ID stage)
469        1/1                    csr_save_cause_o = 1'b1;
470        1/1                    csr_save_id_o    = 1'b1;
471                     
472                               // dcsr
473        1/1                    debug_csr_save_o = 1'b1;
474        1/1                    debug_cause_o    = DBG_CAUSE_EBREAK;
475                             end
                   ==>  MISSING_ELSE
476                     
477                             // enter debug mode
478        1/1                  debug_mode_d = 1'b1;
479                     
480        1/1                  ctrl_fsm_ns  = DECODE;
481                           end
482                     
483                           FLUSH: begin
484                             // flush the pipeline
485        1/1                  halt_if     = 1'b1;
486        1/1                  flush_id    = 1'b1;
487        1/1                  ctrl_fsm_ns = DECODE;
488                     
489                             // exceptions: set exception PC, save PC and exception cause
490                             // exc_req_lsu is high for one clock cycle only (in DECODE)
491        1/1                  if (exc_req_q || store_err_q || load_err_q) begin
492        1/1                    pc_set_o         = 1'b1;
493        1/1                    pc_mux_o         = PC_EXC;
494        1/1                    exc_pc_mux_o     = debug_mode_q ? EXC_PC_DBG_EXC : EXC_PC_EXC;
495        1/1                    csr_save_id_o    = 1'b1;
496        1/1                    csr_save_cause_o = 1'b1;
497                     
498                               // set exception registers, priorities according to Table 3.7 of Privileged Spec v1.11
499        1/1                    if (instr_fetch_err) begin
500        1/1                      exc_cause_o = EXC_CAUSE_INSTR_ACCESS_FAULT;
501        1/1                      csr_mtval_o = pc_id_i;
502                     
503        1/1                    end else if (illegal_insn_q) begin
504        1/1                      exc_cause_o = EXC_CAUSE_ILLEGAL_INSN;
505        1/1                      csr_mtval_o = instr_is_compressed_i ? {16'b0, instr_compressed_i} : instr_i;
506                     
507        1/1                    end else if (ecall_insn) begin
508        1/1                      exc_cause_o = (priv_mode_i == PRIV_LVL_M) ? EXC_CAUSE_ECALL_MMODE :
509                                                                             EXC_CAUSE_ECALL_UMODE;
510                     
511        1/1                    end else if (ebrk_insn) begin
512        1/1                      if (debug_mode_q | ebreak_into_debug) begin
513                                   /*
514                                    * EBREAK in debug mode re-enters debug mode
515                                    *
516                                    * "The only exception is EBREAK. When that is executed in Debug
517                                    * Mode, it halts the hart again but without updating dpc or
518                                    * dcsr." [Debug Spec v0.13.2, p.39]
519                                    */
520                     
521                                   /*
522                                    * dcsr.ebreakm == 1:
523                                    * "EBREAK instructions in M-mode enter Debug Mode."
524                                    * [Debug Spec v0.13.2, p.42]
525                                    */
526        1/1                        pc_set_o         = 1'b0;
527        1/1                        csr_save_id_o    = 1'b0;
528        1/1                        csr_save_cause_o = 1'b0;
529        1/1                        ctrl_fsm_ns      = DBG_TAKEN_ID;
530        1/1                        flush_id         = 1'b0;
531                                 end else begin
532                                   /*
533                                    * "The EBREAK instruction is used by debuggers to cause control
534                                    * to be transferred back to a debugging environment. It
535                                    * generates a breakpoint exception and performs no other
536                                    * operation. [...] ECALL and EBREAK cause the receiving
537                                    * privilege mode's epc register to be set to the address of the
538                                    * ECALL or EBREAK instruction itself, not the address of the
539                                    * following instruction." [Privileged Spec v1.11, p.40]
540                                    */
541        1/1                        exc_cause_o      = EXC_CAUSE_BREAKPOINT;
542                                 end
543                     
544        1/1                    end else if (store_err_q) begin
545        1/1                      exc_cause_o = EXC_CAUSE_STORE_ACCESS_FAULT;
546        1/1                      csr_mtval_o = lsu_addr_last_i;
547                     
548                               end else begin // load_err_q
549        1/1                      exc_cause_o = EXC_CAUSE_LOAD_ACCESS_FAULT;
550        1/1                      csr_mtval_o = lsu_addr_last_i;
551                               end
552                     
553                             end else begin
554                               // special instructions and pipeline flushes
555        1/1                    if (mret_insn) begin
556        1/1                      pc_mux_o              = PC_ERET;
557        1/1                      pc_set_o              = 1'b1;
558        1/1                      csr_restore_mret_id_o = 1'b1;
559        1/1                      if (nmi_mode_q) begin
560        1/1                        nmi_mode_d          = 1'b0; // exit NMI mode
561                                 end
                        MISSING_ELSE
562        1/1                    end else if (dret_insn) begin
563        1/1                      pc_mux_o              = PC_DRET;
564        1/1                      pc_set_o              = 1'b1;
565        1/1                      debug_mode_d          = 1'b0;
566        1/1                      csr_restore_dret_id_o = 1'b1;
567        1/1                    end else if (wfi_insn) begin
568        1/1                      ctrl_fsm_ns           = WAIT_SLEEP;
569        1/1                    end else if (csr_pipe_flush && handle_irq) begin
570                                 // start handling IRQs when doing CSR-related pipeline flushes
571        1/1                      ctrl_fsm_ns           = IRQ_TAKEN;
572                               end
                        MISSING_ELSE
573                             end // exc_req_q
574                     
575                             // Entering debug mode due to either single step or debug_req. Ensure
576                             // registers are set for exception but then enter debug handler rather
577                             // than exception handler [Debug Spec v0.13.2, p.44]
578                             // Leave all other signals as is to ensure CSRs and PC get set as if
579                             // core was entering exception handler, entry to debug mode will then
580                             // see the appropriate state and setup dpc correctly.
581        1/1                  if (enter_debug_mode) begin
582        1/1                    ctrl_fsm_ns = DBG_TAKEN_IF;
583                             end
                        MISSING_ELSE
584                           end // FLUSH
585                     
586                           default: begin
587        1/1                  instr_req_o = 1'b0;
588        1/1                  ctrl_fsm_ns = RESET;
589                           end
590                         endcase
591                       end
592                     
593                       // signal to CSR when in debug mode
594                       assign debug_mode_o = debug_mode_q;
595                     
596                       // signal to CSR when in an NMI handler (for nested exception handling)
597                       assign nmi_mode_o = nmi_mode_q;
598                     
599                       ///////////////////
600                       // Stall control //
601                       ///////////////////
602                     
603                       // if high, current instr needs at least one more cycle to finish after the current cycle
604                       // if low, current instr finishes in current cycle
605                       // multicycle instructions have this set except during the last cycle
606                       assign stall = stall_lsu_i | stall_multdiv_i | stall_jump_i | stall_branch_i;
607                     
608                       // signal to IF stage that ID stage is ready for next instr
609                       assign id_in_ready_o       = ~stall & ~halt_if;
610                     
611                       // kill instr in IF-ID pipeline reg that are done, or if a
612                       // multicycle instr causes an exception for example
613                       // halt_if is another kind of stall, where the instr_valid bit must remain
614                       // set (unless flush_id is set also). It cannot be factored directly into
615                       // stall as this causes a combinational loop.
616                       assign instr_valid_clear_o = ~(stall | halt_if) | flush_id;
617                     
618                       // update registers
619                       always_ff @(posedge clk_i or negedge rst_ni) begin : update_regs
620        1/1              if (!rst_ni) begin
621        1/1                ctrl_fsm_cs    <= RESET;
622        1/1                nmi_mode_q     <= 1'b0;
623        1/1                debug_mode_q   <= 1'b0;
624        1/1                load_err_q     <= 1'b0;
625        1/1                store_err_q    <= 1'b0;
626        1/1                exc_req_q      <= 1'b0;
627        1/1                illegal_insn_q <= 1'b0;
628                         end else begin
629        1/1                ctrl_fsm_cs    <= ctrl_fsm_ns;
630        1/1                nmi_mode_q     <= nmi_mode_d;
631        1/1                debug_mode_q   <= debug_mode_d;
632        1/1                load_err_q     <= load_err_d;
633        1/1                store_err_q    <= store_err_d;
634        1/1                exc_req_q      <= exc_req_d;
635        1/1                illegal_insn_q <= illegal_insn_d;

-------------------------------------------------------------------------------
FSM Coverage for Module : ibex_controller
Summary for FSM :: ctrl_fsm_cs
            Total Covered Percent                         
States      10    10      100.00  (Not included in score) 
Transitions 27    18      66.67                           
Sequences   0     0                                       

State, Transition and Sequence Details for FSM :: ctrl_fsm_cs
-------------------------------------------------------------------------------
states       Line No. Covered 
BOOT_SET     281      Covered 
DBG_TAKEN_ID 529      Covered 
DBG_TAKEN_IF 336      Covered 
DECODE       322      Covered 
FIRST_FETCH  291      Covered 
FLUSH        357      Covered 
IRQ_TAKEN    329      Covered 
RESET        621      Covered 
SLEEP        299      Covered 
WAIT_SLEEP   568      Covered 

transitions               Line No. Covered     
BOOT_SET->FIRST_FETCH     291      Covered     
BOOT_SET->RESET           621      Not Covered 
DBG_TAKEN_ID->DECODE      480      Covered     
DBG_TAKEN_ID->RESET       621      Not Covered 
DBG_TAKEN_IF->DECODE      449      Covered     
DBG_TAKEN_IF->RESET       621      Not Covered 
DECODE->DBG_TAKEN_IF      379      Covered     
DECODE->FLUSH             357      Covered     
DECODE->IRQ_TAKEN         385      Covered     
DECODE->RESET             621      Covered     
FIRST_FETCH->DBG_TAKEN_IF 336      Not Covered 
FIRST_FETCH->DECODE       322      Covered     
FIRST_FETCH->IRQ_TAKEN    329      Covered     
FIRST_FETCH->RESET        621      Not Covered 
FLUSH->DBG_TAKEN_ID       529      Covered     
FLUSH->DBG_TAKEN_IF       582      Covered     
FLUSH->DECODE             487      Covered     
FLUSH->IRQ_TAKEN          571      Covered     
FLUSH->RESET              621      Not Covered 
FLUSH->WAIT_SLEEP         568      Covered     
IRQ_TAKEN->DECODE         421      Covered     
IRQ_TAKEN->RESET          621      Not Covered 
RESET->BOOT_SET           281      Covered     
SLEEP->FIRST_FETCH        312      Covered     
SLEEP->RESET              621      Not Covered 
WAIT_SLEEP->RESET         621      Not Covered 
WAIT_SLEEP->SLEEP         299      Covered     


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_controller
         Line No. Total Covered Percent 
Branches          75    68      90.67   
TERNARY  208      3     2       66.67   
IF       218      16    15      93.75   
CASE     274      54    49      90.74   
IF       620      2     2       100.00  


208          assign ebreak_into_debug = priv_mode_i == PRIV_LVL_M ? debug_ebreakm_i :
                                                                  -1-  
                                                                  ==>  
209                                     priv_mode_i == PRIV_LVL_U ? debug_ebreaku_i :
                                                                  -2-  
                                                                  ==>  
                                                                  ==>  

Branches:

-1- -2- Status      
1   -   Covered     
0   1   Covered     
0   0   Not Covered 


218            if      (csr_mfip_i[14]) mfip_id = 4'd14;
               -1-  
               ==>
219            else if (csr_mfip_i[13]) mfip_id = 4'd13;
                    -2-  
               ==>
220            else if (csr_mfip_i[12]) mfip_id = 4'd12;
                    -3-  
               ==>
221            else if (csr_mfip_i[11]) mfip_id = 4'd11;
                    -4-  
               ==>
222            else if (csr_mfip_i[10]) mfip_id = 4'd10;
                    -5-  
               ==>
223            else if (csr_mfip_i[ 9]) mfip_id = 4'd9;
                    -6-  
               ==>
224            else if (csr_mfip_i[ 8]) mfip_id = 4'd8;
                    -7-  
               ==>
225            else if (csr_mfip_i[ 7]) mfip_id = 4'd7;
                    -8-  
               ==>
226            else if (csr_mfip_i[ 6]) mfip_id = 4'd6;
                    -9-  
               ==>
227            else if (csr_mfip_i[ 5]) mfip_id = 4'd5;
                    -10-  
               ==>
228            else if (csr_mfip_i[ 5]) mfip_id = 4'd5;
                    -11-  
               ==>
229            else if (csr_mfip_i[ 4]) mfip_id = 4'd4;
                    -12-  
               ==>
230            else if (csr_mfip_i[ 3]) mfip_id = 4'd3;
                    -13-  
               ==>
231            else if (csr_mfip_i[ 2]) mfip_id = 4'd2;
                    -14-  
               ==>
232            else if (csr_mfip_i[ 1]) mfip_id = 4'd1;
                    -15-  
               ==>
233            else                     mfip_id = 4'd0;
               ==>

Branches:

-1- -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- -12- -13- -14- -15- Status      
1   -   -   -   -   -   -   -   -   -    -    -    -    -    -    Covered     
0   1   -   -   -   -   -   -   -   -    -    -    -    -    -    Covered     
0   0   1   -   -   -   -   -   -   -    -    -    -    -    -    Covered     
0   0   0   1   -   -   -   -   -   -    -    -    -    -    -    Covered     
0   0   0   0   1   -   -   -   -   -    -    -    -    -    -    Covered     
0   0   0   0   0   1   -   -   -   -    -    -    -    -    -    Covered     
0   0   0   0   0   0   1   -   -   -    -    -    -    -    -    Covered     
0   0   0   0   0   0   0   1   -   -    -    -    -    -    -    Covered     
0   0   0   0   0   0   0   0   1   -    -    -    -    -    -    Covered     
0   0   0   0   0   0   0   0   0   1    -    -    -    -    -    Covered     
0   0   0   0   0   0   0   0   0   0    1    -    -    -    -    Not Covered 
0   0   0   0   0   0   0   0   0   0    0    1    -    -    -    Covered     
0   0   0   0   0   0   0   0   0   0    0    0    1    -    -    Covered     
0   0   0   0   0   0   0   0   0   0    0    0    0    1    -    Covered     
0   0   0   0   0   0   0   0   0   0    0    0    0    0    1    Covered     
0   0   0   0   0   0   0   0   0   0    0    0    0    0    0    Covered     


274            unique case (ctrl_fsm_cs)
                      -1-  
275              RESET: begin
276                // just wait for fetch_enable
277                instr_req_o   = 1'b0;
278                pc_mux_o      = PC_BOOT;
279                pc_set_o      = 1'b1;
280                if (fetch_enable_i) begin
                   -2-  
281                  ctrl_fsm_ns = BOOT_SET;
                     ==>
282                end
                   MISSING_ELSE
                   ==>
283              end
284        
285              BOOT_SET: begin
286                // copy boot address to instr fetch address
287                instr_req_o   = 1'b1;
                   ==>
288                pc_mux_o      = PC_BOOT;
289                pc_set_o      = 1'b1;
290        
291                ctrl_fsm_ns = FIRST_FETCH;
292              end
293        
294              WAIT_SLEEP: begin
295                ctrl_busy_o   = 1'b0;
                   ==>
296                instr_req_o   = 1'b0;
297                halt_if       = 1'b1;
298                flush_id      = 1'b1;
299                ctrl_fsm_ns   = SLEEP;
300              end
301        
302              SLEEP: begin
303                // instruction in IF stage is already valid
304                // we begin execution when an interrupt has arrived
305                instr_req_o   = 1'b0;
306                halt_if       = 1'b1;
307                flush_id      = 1'b1;
308        
309                // normal execution flow
310                // in debug mode or single step mode we leave immediately (wfi=nop)
311                if (irq_nm_i || irq_pending_i || debug_req_i || debug_mode_q || debug_single_step_i) begin
                   -3-  
312                  ctrl_fsm_ns = FIRST_FETCH;
                     ==>
313                end else begin
314                  // Make sure clock remains disabled.
315                  ctrl_busy_o = 1'b0;
                     ==>
316                end
317              end
318        
319              FIRST_FETCH: begin
320                // Stall because of IF miss
321                if (id_in_ready_o) begin
                   -4-  
322                  ctrl_fsm_ns = DECODE;
                     ==>
323                end
                   MISSING_ELSE
                   ==>
324        
325                // handle interrupts
326                if (handle_irq) begin
                   -5-  
327                  // This assumes that the pipeline is always flushed before
328                  // going to sleep.
329                  ctrl_fsm_ns = IRQ_TAKEN;
                     ==>
330                  halt_if     = 1'b1;
331                  flush_id    = 1'b1;
332                end
                   MISSING_ELSE
                   ==>
333        
334                // enter debug mode
335                if (enter_debug_mode) begin
                   -6-  
336                  ctrl_fsm_ns = DBG_TAKEN_IF;
                     ==>
337                  // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the
338                  // ID state is needed for correct debug mode entry
339                  halt_if     = 1'b1;
340                end
                   MISSING_ELSE
                   ==>
341              end
342        
343              DECODE: begin
344                // normal operating mode of the ID stage, in case of debug and interrupt requests,
345                // priorities are as follows (lower number == higher priority)
346                // 1. currently running (multicycle) instructions and exceptions caused by these
347                // 2. debug requests
348                // 3. interrupt requests
349        
350                if (instr_valid_i) begin
                   -7-  
351        
352                  // get ready for special instructions, exceptions, pipeline flushes
353                  if (special_req) begin
                     -8-  
354                    // Halt IF but don't flush ID. This leaves a valid instruction in
355                    // ID so controller can determine appropriate action in the
356                    // FLUSH state.
357                    ctrl_fsm_ns = FLUSH;
                       ==>
358                    halt_if     = 1'b1;
359                  // set PC in IF stage to branch or jump target
360                  end else if (branch_set_i || jump_set_i) begin
                              -9-  
361                    pc_mux_o       = PC_JUMP;
                       ==>
362                    pc_set_o       = 1'b1;
363        
364                    perf_tbranch_o = branch_set_i;
365                    perf_jump_o    = jump_set_i;
366                  end
                     MISSING_ELSE
                     ==>
367        
368                  // If entering debug mode or handling an IRQ the core needs to wait
369                  // until the current instruction has finished executing. Stall IF
370                  // during that time.
371                  if ((enter_debug_mode || handle_irq) && stall) begin
                     -10-  
372                    halt_if = 1'b1;
                       ==>
373                  end
                     MISSING_ELSE
                     ==>
374                end // instr_valid_i
                   MISSING_ELSE
                   ==>
375        
376                if (!stall && !special_req) begin
                   -11-  
377                  if (enter_debug_mode) begin
                     -12-  
378                    // enter debug mode
379                    ctrl_fsm_ns = DBG_TAKEN_IF;
                       ==>
380                    // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the
381                    // ID state is needed for correct debug mode entry
382                    halt_if     = 1'b1;
383                  end else if (handle_irq) begin
                              -13-  
384                    // handle interrupt (not in debug mode)
385                    ctrl_fsm_ns = IRQ_TAKEN;
                       ==>
386                    halt_if     = 1'b1;
387                    flush_id    = 1'b1;
388                  end
                     MISSING_ELSE
                     ==>
389                end
                   MISSING_ELSE
                   ==>
390        
391              end // DECODE
392        
393              IRQ_TAKEN: begin
394                if (handle_irq) begin
                   -14-  
395                  pc_mux_o         = PC_EXC;
396                  pc_set_o         = 1'b1;
397                  exc_pc_mux_o     = EXC_PC_IRQ;
398        
399                  csr_save_if_o    = 1'b1;
400                  csr_save_cause_o = 1'b1;
401        
402                  // interrupt priorities according to Privileged Spec v1.11 p.31
403                  if (irq_nm_i && !nmi_mode_q) begin
                     -15-  
404                    exc_cause_o = EXC_CAUSE_IRQ_NM;
                       ==>
405                    nmi_mode_d  = 1'b1; // enter NMI mode
406                  end else if (csr_mfip_i != 15'b0) begin
                              -16-  
407                    // generate exception cause ID from fast interrupt ID:
408                    // - first bit distinguishes interrupts from exceptions,
409                    // - second bit adds 16 to fast interrupt ID
410                    // for example EXC_CAUSE_IRQ_FAST_0 = {1'b1, 5'd16}
411                    exc_cause_o = exc_cause_e'({2'b11, mfip_id});
                       ==>
412                  end else if (csr_meip_i) begin
                              -17-  
413                    exc_cause_o = EXC_CAUSE_IRQ_EXTERNAL_M;
                       ==>
414                  end else if (csr_msip_i) begin
                              -18-  
415                    exc_cause_o = EXC_CAUSE_IRQ_SOFTWARE_M;
                       ==>
416                  end else begin // csr_mtip_i
417                    exc_cause_o = EXC_CAUSE_IRQ_TIMER_M;
                       ==>
418                  end
419                end
                   MISSING_ELSE
                   ==>
420        
421                ctrl_fsm_ns = DECODE;
422              end
423        
424              DBG_TAKEN_IF: begin
425                // enter debug mode and save PC in IF to dpc
426                // jump to debug exception handler in debug memory
427                if (debug_single_step_i || debug_req_i || trigger_match_i) begin
                   -19-  
428                  flush_id         = 1'b1;
429                  pc_mux_o         = PC_EXC;
430                  pc_set_o         = 1'b1;
431                  exc_pc_mux_o     = EXC_PC_DBD;
432        
433                  csr_save_if_o    = 1'b1;
434                  debug_csr_save_o = 1'b1;
435        
436                  csr_save_cause_o = 1'b1;
437                  if (trigger_match_i) begin
                     -20-  
438                    debug_cause_o = DBG_CAUSE_TRIGGER;
                       ==>
439                  end else if (debug_single_step_i) begin
                              -21-  
440                    debug_cause_o = DBG_CAUSE_STEP;
                       ==>
441                  end else begin
442                    debug_cause_o = DBG_CAUSE_HALTREQ;
                       ==>
443                  end
444        
445                  // enter debug mode
446                  debug_mode_d = 1'b1;
447                end
                   MISSING_ELSE
                   ==>
448        
449                ctrl_fsm_ns  = DECODE;
450              end
451        
452              DBG_TAKEN_ID: begin
453                // enter debug mode and save PC in ID to dpc, used when encountering
454                // 1. EBREAK during debug mode
455                // 2. EBREAK with forced entry into debug mode (ebreakm or ebreaku set).
456                // regular ebreak's go through FLUSH.
457                //
458                // for 1. do not update dcsr and dpc, for 2. do so [Debug Spec v0.13.2, p.39]
459                // jump to debug exception handler in debug memory
460                flush_id     = 1'b1;
461                pc_mux_o     = PC_EXC;
462                pc_set_o     = 1'b1;
463                exc_pc_mux_o = EXC_PC_DBD;
464        
465                // update dcsr and dpc
466                if (ebreak_into_debug && !debug_mode_q) begin // ebreak with forced entry
                   -22-  
467        
468                  // dpc (set to the address of the EBREAK, i.e. set to PC in ID stage)
469                  csr_save_cause_o = 1'b1;
                     ==>
470                  csr_save_id_o    = 1'b1;
471        
472                  // dcsr
473                  debug_csr_save_o = 1'b1;
474                  debug_cause_o    = DBG_CAUSE_EBREAK;
475                end
                   MISSING_ELSE
                   ==>
476        
477                // enter debug mode
478                debug_mode_d = 1'b1;
479        
480                ctrl_fsm_ns  = DECODE;
481              end
482        
483              FLUSH: begin
484                // flush the pipeline
485                halt_if     = 1'b1;
486                flush_id    = 1'b1;
487                ctrl_fsm_ns = DECODE;
488        
489                // exceptions: set exception PC, save PC and exception cause
490                // exc_req_lsu is high for one clock cycle only (in DECODE)
491                if (exc_req_q || store_err_q || load_err_q) begin
                   -23-  
492                  pc_set_o         = 1'b1;
493                  pc_mux_o         = PC_EXC;
494                  exc_pc_mux_o     = debug_mode_q ? EXC_PC_DBG_EXC : EXC_PC_EXC;
                                                     -24-  
                                                     ==>  
                                                     ==>  
495                  csr_save_id_o    = 1'b1;
496                  csr_save_cause_o = 1'b1;
497        
498                  // set exception registers, priorities according to Table 3.7 of Privileged Spec v1.11
499                  if (instr_fetch_err) begin
                     -25-  
500                    exc_cause_o = EXC_CAUSE_INSTR_ACCESS_FAULT;
                       ==>
501                    csr_mtval_o = pc_id_i;
502        
503                  end else if (illegal_insn_q) begin
                              -26-  
504                    exc_cause_o = EXC_CAUSE_ILLEGAL_INSN;
505                    csr_mtval_o = instr_is_compressed_i ? {16'b0, instr_compressed_i} : instr_i;
                                                           -27-  
                                                           ==>  
                                                           ==>  
506        
507                  end else if (ecall_insn) begin
                              -28-  
508                    exc_cause_o = (priv_mode_i == PRIV_LVL_M) ? EXC_CAUSE_ECALL_MMODE :
                                                                 -29-  
                                                                 ==>  
                                                                 ==>  
509                                                                EXC_CAUSE_ECALL_UMODE;
510        
511                  end else if (ebrk_insn) begin
                              -30-  
512                    if (debug_mode_q | ebreak_into_debug) begin
                       -31-  
513                      /*
514                       * EBREAK in debug mode re-enters debug mode
515                       *
516                       * "The only exception is EBREAK. When that is executed in Debug
517                       * Mode, it halts the hart again but without updating dpc or
518                       * dcsr." [Debug Spec v0.13.2, p.39]
519                       */
520        
521                      /*
522                       * dcsr.ebreakm == 1:
523                       * "EBREAK instructions in M-mode enter Debug Mode."
524                       * [Debug Spec v0.13.2, p.42]
525                       */
526                      pc_set_o         = 1'b0;
                         ==>
527                      csr_save_id_o    = 1'b0;
528                      csr_save_cause_o = 1'b0;
529                      ctrl_fsm_ns      = DBG_TAKEN_ID;
530                      flush_id         = 1'b0;
531                    end else begin
532                      /*
533                       * "The EBREAK instruction is used by debuggers to cause control
534                       * to be transferred back to a debugging environment. It
535                       * generates a breakpoint exception and performs no other
536                       * operation. [...] ECALL and EBREAK cause the receiving
537                       * privilege mode's epc register to be set to the address of the
538                       * ECALL or EBREAK instruction itself, not the address of the
539                       * following instruction." [Privileged Spec v1.11, p.40]
540                       */
541                      exc_cause_o      = EXC_CAUSE_BREAKPOINT;
                         ==>
542                    end
543        
544                  end else if (store_err_q) begin
                              -32-  
545                    exc_cause_o = EXC_CAUSE_STORE_ACCESS_FAULT;
                       ==>
546                    csr_mtval_o = lsu_addr_last_i;
547        
548                  end else begin // load_err_q
549                    exc_cause_o = EXC_CAUSE_LOAD_ACCESS_FAULT;
                       ==>
550                    csr_mtval_o = lsu_addr_last_i;
551                  end
552        
553                end else begin
554                  // special instructions and pipeline flushes
555                  if (mret_insn) begin
                     -33-  
556                    pc_mux_o              = PC_ERET;
557                    pc_set_o              = 1'b1;
558                    csr_restore_mret_id_o = 1'b1;
559                    if (nmi_mode_q) begin
                       -34-  
560                      nmi_mode_d          = 1'b0; // exit NMI mode
                         ==>
561                    end
                       MISSING_ELSE
                       ==>
562                  end else if (dret_insn) begin
                              -35-  
563                    pc_mux_o              = PC_DRET;
                       ==>
564                    pc_set_o              = 1'b1;
565                    debug_mode_d          = 1'b0;
566                    csr_restore_dret_id_o = 1'b1;
567                  end else if (wfi_insn) begin
                              -36-  
568                    ctrl_fsm_ns           = WAIT_SLEEP;
                       ==>
569                  end else if (csr_pipe_flush && handle_irq) begin
                              -37-  
570                    // start handling IRQs when doing CSR-related pipeline flushes
571                    ctrl_fsm_ns           = IRQ_TAKEN;
                       ==>
572                  end
                     MISSING_ELSE
                     ==>
573                end // exc_req_q
574        
575                // Entering debug mode due to either single step or debug_req. Ensure
576                // registers are set for exception but then enter debug handler rather
577                // than exception handler [Debug Spec v0.13.2, p.44]
578                // Leave all other signals as is to ensure CSRs and PC get set as if
579                // core was entering exception handler, entry to debug mode will then
580                // see the appropriate state and setup dpc correctly.
581                if (enter_debug_mode) begin
                   -38-  
582                  ctrl_fsm_ns = DBG_TAKEN_IF;
                     ==>
583                end
                   MISSING_ELSE
                   ==>
584              end // FLUSH
585        
586              default: begin
587                instr_req_o = 1'b0;
                   ==>

Branches:

-1-           -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- -12- -13- -14- -15- -16- -17- -18- -19- -20- -21- -22- -23- -24- -25- -26- -27- -28- -29- -30- -31- -32- -33- -34- -35- -36- -37- -38- Status      
RESET         1   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
RESET         0   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
BOOT_SET      -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
WAIT_SLEEP    -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
SLEEP         -   1   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
SLEEP         -   0   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
FIRST_FETCH   -   -   1   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
FIRST_FETCH   -   -   0   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
FIRST_FETCH   -   -   -   1   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
FIRST_FETCH   -   -   -   0   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
FIRST_FETCH   -   -   -   -   1   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Not Covered 
FIRST_FETCH   -   -   -   -   0   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   1   1   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   1   0   1   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   1   0   0   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   1   -   -   1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   1   -   -   0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   0   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   -   -   -   -    1    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   -   -   -   -    1    0    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   -   -   -   -    1    0    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DECODE        -   -   -   -   -   -   -   -   -    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    1    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    1    0    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    1    0    0    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    1    0    0    0    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    1    0    0    0    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Not Covered 
IRQ_TAKEN     -   -   -   -   -   -   -   -   -    -    -    -    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Not Covered 
DBG_TAKEN_IF  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    1    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Not Covered 
DBG_TAKEN_IF  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    1    0    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DBG_TAKEN_IF  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    1    0    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DBG_TAKEN_IF  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DBG_TAKEN_ID  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
DBG_TAKEN_ID  -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Not Covered 
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    1    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    0    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    1    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    0    1    1    -    -    -    -    -    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    0    1    0    -    -    -    -    -    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    0    0    -    1    1    -    -    -    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    0    0    -    1    0    -    -    -    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    0    0    -    0    -    1    1    -    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    0    0    -    0    -    1    0    -    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    0    0    -    0    -    0    -    1    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    1    -    0    0    -    0    -    0    -    0    -    -    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -    -    -    -    -    -    -    1    1    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -    -    -    -    -    -    -    1    0    -    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -    -    -    -    -    -    -    0    -    1    -    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -    -    -    -    -    -    -    0    -    0    1    -    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -    -    -    -    -    -    -    0    -    0    0    1    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    0    -    -    -    -    -    -    -    -    -    0    -    0    0    0    -    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    1    Covered     
FLUSH         -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    0    Covered     
default       -   -   -   -   -   -   -   -   -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    -    Covered     


620            if (!rst_ni) begin
               -1-  
621              ctrl_fsm_cs    <= RESET;
                 ==>
622              nmi_mode_q     <= 1'b0;
623              debug_mode_q   <= 1'b0;
624              load_err_q     <= 1'b0;
625              store_err_q    <= 1'b0;
626              exc_req_q      <= 1'b0;
627              illegal_insn_q <= 1'b0;
628            end else begin
629              ctrl_fsm_cs    <= ctrl_fsm_ns;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.id_stage_i.controller_i
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 85.13  98.07 --      66.67  90.67 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 85.13  98.07 --      66.67  90.67 --     


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME            
 85.13  98.07 --      66.67  90.67 --     ibex_controller 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME       
100.00 100.00 --     --     100.00 100.00 id_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_compressed_decoder
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 91.17  92.86 --     --      89.47 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_compressed_decoder.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                                                
100.00 100.00 --     --     100.00 --     core_ibex_tb_top.dut.u_ibex_core.if_stage_i.compressed_decoder_i(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_compressed_decoder

             Line No.   Total   Covered  Percent
TOTAL                       56       52    92.86
ALWAYS             25       56       52    92.86

24                        // Compressed decoder //
25         1/1            ////////////////////////
26         1/1          
27                        always_comb begin
28         1/1              // By default, forward incoming instruction, mark it as legal.
29                          instr_o         = instr_i;
30                          illegal_instr_o = 1'b0;
31         1/1          
32                          // Check if incoming instruction is compressed.
33                          unique case (instr_i[1:0])
34         1/1                // C0
35                            2'b00: begin
36         2/2                  unique case (instr_i[15:13])
                        MISSING_ELSE
37                                3'b000: begin
38                                  // c.addi4spn -> addi rd', x2, imm
39                                  instr_o = {2'b0, instr_i[10:7], instr_i[12:11], instr_i[5],
40                                             instr_i[6], 2'b00, 5'h02, 3'b000, 2'b01, instr_i[4:2], {OPCODE_OP_IMM}};
41         1/1                      if (instr_i[12:5] == 8'b0)  illegal_instr_o = 1'b1;
42                                end
43                      
44                                3'b010: begin
45                                  // c.lw -> lw rd', imm(rs1')
46                                  instr_o = {5'b0, instr_i[5], instr_i[12:10], instr_i[6],
47         1/1                                 2'b00, 2'b01, instr_i[9:7], 3'b010, 2'b01, instr_i[4:2], {OPCODE_LOAD}};
48                                end
49                      
50                                3'b110: begin
51                                  // c.sw -> sw rs2', imm(rs1')
52                                  instr_o = {5'b0, instr_i[5], instr_i[12], 2'b01, instr_i[4:2],
53         1/1                                 2'b01, instr_i[9:7], 3'b010, instr_i[11:10], instr_i[6],
54                                             2'b00, {OPCODE_STORE}};
55                                end
56                      
57                                3'b001,
58                                3'b011,
59                                3'b100,
60                                3'b101,
61                                3'b111: begin
62                                  illegal_instr_o = 1'b1;
63                                end
64         1/1          
65                                default: begin
66                                  illegal_instr_o = 1'b1;
67                                end
68         1/1                  endcase
69                            end
70                      
71                            // C1
72                            //
73                            // Register address checks for RV32E are performed in the regular instruction decoder.
74                            // If this check fails, an illegal instruction exception is triggered and the controller
75         1/1                // writes the actual faulting instruction to mtval.
76                            2'b01: begin
77                              unique case (instr_i[15:13])
78                                3'b000: begin
79                                  // c.addi -> addi rd, rd, nzimm
80                                  // c.nop
81                                  instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2],
82                                             instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
83         1/1                    end
84                      
85                                3'b001, 3'b101: begin
86                                  // 001: c.jal -> jal x1, imm
87                                  // 101: c.j   -> jal x0, imm
88                                  instr_o = {instr_i[12], instr_i[8], instr_i[10:9], instr_i[6],
89                                             instr_i[7], instr_i[2], instr_i[11], instr_i[5:3],
90         1/1                                 {9 {instr_i[12]}}, 4'b0, ~instr_i[15], {OPCODE_JAL}};
91                                end
92         1/1          
93                                3'b010: begin
94         1/1                      // c.li -> addi rd, x0, nzimm
95                                  // (c.li hints are translated into an addi hint)
96                                  instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0,
                        MISSING_ELSE
97                                             3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
98         2/2                    end
                        MISSING_ELSE
99                      
100                               3'b011: begin
101                                 // c.lui -> lui rd, imm
102        1/1                      // (c.lui hints are translated into a lui hint)
103                                 instr_o = {{15 {instr_i[12]}}, instr_i[6:2], instr_i[11:7], {OPCODE_LUI}};
104                     
105                                 if (instr_i[11:7] == 5'h02) begin
106                                   // c.addi16sp -> addi x2, x2, nzimm
107                                   instr_o = {{3 {instr_i[12]}}, instr_i[4:3], instr_i[5], instr_i[2],
108        1/1                                   instr_i[6], 4'b0, 5'h02, 3'b000, 5'h02, {OPCODE_OP_IMM}};
109                                 end
110        2/2          
                        MISSING_ELSE
111                                 if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;
112                               end
113                     
114                               3'b100: begin
115        1/1                      unique case (instr_i[11:10])
116                                   2'b00,
117                                   2'b01: begin
118                                     // 00: c.srli -> srli rd, rd, shamt
119                                     // 01: c.srai -> srai rd, rd, shamt
120        1/1                          // (c.srli/c.srai hints are translated into a srli/srai hint)
121                                     instr_o = {1'b0, instr_i[10], 5'b0, instr_i[6:2], 2'b01, instr_i[9:7],
122                                                3'b101, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
123        1/1                          if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1;
124                                   end
125                     
126                                   2'b10: begin
127                                     // c.andi -> andi rd, rd, imm
128                                     instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 2'b01, instr_i[9:7],
129        1/1                                     3'b111, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
130                                   end
131                     
132                                   2'b11: begin
133                                     unique case ({instr_i[12], instr_i[6:5]})
134                                       3'b000: begin
135        1/1                              // c.sub -> sub rd', rd', rs2'
136                                         instr_o = {2'b01, 5'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7],
137                                                    3'b000, 2'b01, instr_i[9:7], {OPCODE_OP}};
138                                       end
139                     
140                                       3'b001: begin
141        1/1                              // c.xor -> xor rd', rd', rs2'
142                                         instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b100,
143                                                    2'b01, instr_i[9:7], {OPCODE_OP}};
144                                       end
145                     
146                                       3'b010: begin
147                                         // c.or  -> or  rd', rd', rs2'
148                                         instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b110,
149                                                    2'b01, instr_i[9:7], {OPCODE_OP}};
150                                       end
151        1/1          
152                                       3'b011: begin
153                                         // c.and -> and rd', rd', rs2'
154                                         instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b111,
155        0/1     ==>                                 2'b01, instr_i[9:7], {OPCODE_OP}};
156                                       end
157                     
158                                       3'b100,
159                                       3'b101,
160                                       3'b110,
161        0/1     ==>                    3'b111: begin
162                                         // 100: c.subw
163                                         // 101: c.addw
164                                         illegal_instr_o = 1'b1;
165                                       end
166                     
167                                       default: begin
168                                         illegal_instr_o = 1'b1;
169        1/1                            end
170                                     endcase
171                                   end
172                     
173                                   default: begin
174                                     illegal_instr_o = 1'b1;
175        0/1     ==>                end
176                                 endcase
177                               end
178                     
179                               3'b110, 3'b111: begin
180                                 // 0: c.beqz -> beq rs1', x0, imm
181                                 // 1: c.bnez -> bne rs1', x0, imm
182                                 instr_o = {{4 {instr_i[12]}}, instr_i[6:5], instr_i[2], 5'b0, 2'b01,
183                                            instr_i[9:7], 2'b00, instr_i[13], instr_i[11:10], instr_i[4:3],
184                                            instr_i[12], {OPCODE_BRANCH}};
185                               end
186        1/1          
187                               default: begin
188                                 illegal_instr_o = 1'b1;
189                               end
190        1/1                  endcase
191        2/2                end
                        MISSING_ELSE
192                     
193                           // C2
194                           //
195                           // Register address checks for RV32E are performed in the regular instruction decoder.
196        1/1                // If this check fails, an illegal instruction exception is triggered and the controller
197                           // writes the actual faulting instruction to mtval.
198        2/2                2'b10: begin
                        MISSING_ELSE
199                             unique case (instr_i[15:13])
200                               3'b000: begin
201                                 // c.slli -> slli rd, rd, shamt
202        1/1                      // (c.ssli hints are translated into a slli hint)
203        1/1                      instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], {OPCODE_OP_IMM}};
204                                 if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1; // reserved for custom extensions
205                               end
206        1/1          
207                               3'b010: begin
208                                 // c.lwsp -> lw rd, imm(x2)
209        1/1                      instr_o = {4'b0, instr_i[3:2], instr_i[12], instr_i[6:4], 2'b00, 5'h02,
210        2/2                                 3'b010, instr_i[11:7], OPCODE_LOAD};
                        MISSING_ELSE
211                                 if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
212                               end
213        1/1          
214                               3'b100: begin
215                                 if (instr_i[12] == 1'b0) begin
216        1/1                        if (instr_i[6:2] != 5'b0) begin
217                                     // c.mv -> add rd/rs1, x0, rs2
218        1/1                          // (c.mv hints are translated into an add hint)
219                                     instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], {OPCODE_OP}};
220        1/1                        end else begin
221                                     // c.jr -> jalr x0, rd/rs1, 0
222                                     instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, {OPCODE_JALR}};
223        1/1                          if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
224                                   end
225                                 end else begin
226                                   if (instr_i[6:2] != 5'b0) begin
227                                     // c.add -> add rd, rd, rs2
228                                     // (c.add hints are translated into an add hint)
229                                     instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP}};
230                                   end else begin
231        1/1                          if (instr_i[11:7] == 5'b0) begin
232                                       // c.ebreak -> ebreak
233                                       instr_o = {32'h00_10_00_73};
234                                     end else begin
235                                       // c.jalr -> jalr x1, rs1, 0
236                                       instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, {OPCODE_JALR}};
237                                     end
238                                   end
239        1/1                      end
240                               end
241                     
242                               3'b110: begin
243        0/1     ==>              // c.swsp -> sw rs2, imm(x2)
244                                 instr_o = {4'b0, instr_i[8:7], instr_i[12], instr_i[6:2], 5'h02, 3'b010,
245                                            instr_i[11:9], 2'b00, {OPCODE_STORE}};
246                               end
247                     
248                               3'b001,
249                               3'b011,
250        1/1                    3'b101,

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_compressed_decoder
         Line No. Total Covered Percent 
Branches          38    34      89.47   
CASE     28       38    34      89.47   


28             // By default, forward incoming instruction, mark it as legal.
                                                                             -1-
29             instr_o         = instr_i;
30             illegal_instr_o = 1'b0;
31         
           -2-
32             // Check if incoming instruction is compressed.
33             unique case (instr_i[1:0])
34               // C0
35               2'b00: begin
36                 unique case (instr_i[15:13])
                   -3-                            
                   ==>
                   MISSING_ELSE
                   ==>
37                   3'b000: begin
38                     // c.addi4spn -> addi rd', x2, imm
39                     instr_o = {2'b0, instr_i[10:7], instr_i[12:11], instr_i[5],
40                                instr_i[6], 2'b00, 5'h02, 3'b000, 2'b01, instr_i[4:2], {OPCODE_OP_IMM}};
41                     if (instr_i[12:5] == 8'b0)  illegal_instr_o = 1'b1;
                       ==>
42                   end
43         
44                   3'b010: begin
45                     // c.lw -> lw rd', imm(rs1')
46                     instr_o = {5'b0, instr_i[5], instr_i[12:10], instr_i[6],
47                                2'b00, 2'b01, instr_i[9:7], 3'b010, 2'b01, instr_i[4:2], {OPCODE_LOAD}};
                                  ==>
48                   end
49         
50                   3'b110: begin
51                     // c.sw -> sw rs2', imm(rs1')
52                     instr_o = {5'b0, instr_i[5], instr_i[12], 2'b01, instr_i[4:2],
53                                2'b01, instr_i[9:7], 3'b010, instr_i[11:10], instr_i[6],
                                  ==>
54                                2'b00, {OPCODE_STORE}};
55                   end
56         
57                   3'b001,
58                   3'b011,
59                   3'b100,
60                   3'b101,
61                   3'b111: begin
62                     illegal_instr_o = 1'b1;
63                   end
64         
           -4-
65                   default: begin
66                     illegal_instr_o = 1'b1;
67                   end
68                 endcase
                   ==>
69               end
70         
71               // C1
72               //
73               // Register address checks for RV32E are performed in the regular instruction decoder.
74               // If this check fails, an illegal instruction exception is triggered and the controller
75               // writes the actual faulting instruction to mtval.
                 ==>
76               2'b01: begin
77                 unique case (instr_i[15:13])
78                   3'b000: begin
79                     // c.addi -> addi rd, rd, nzimm
80                     // c.nop
81                     instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2],
82                                instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
83                   end
                     ==>
84         
85                   3'b001, 3'b101: begin
86                     // 001: c.jal -> jal x1, imm
87                     // 101: c.j   -> jal x0, imm
88                     instr_o = {instr_i[12], instr_i[8], instr_i[10:9], instr_i[6],
89                                instr_i[7], instr_i[2], instr_i[11], instr_i[5:3],
90                                {9 {instr_i[12]}}, 4'b0, ~instr_i[15], {OPCODE_JAL}};
91                   end
92         
           -5-
93                   3'b010: begin
94                     // c.li -> addi rd, x0, nzimm
                       ==>
95                     // (c.li hints are translated into an addi hint)
96                     instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0,
                       MISSING_ELSE
                       ==>
97                                3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
98                   end
                     -6-   
                     ==>
                     MISSING_ELSE
                     ==>
99         
100                  3'b011: begin
101                    // c.lui -> lui rd, imm
102                    // (c.lui hints are translated into a lui hint)
                                                                      -7-
103                    instr_o = {{15 {instr_i[12]}}, instr_i[6:2], instr_i[11:7], {OPCODE_LUI}};
104        
105                    if (instr_i[11:7] == 5'h02) begin
106                      // c.addi16sp -> addi x2, x2, nzimm
107                      instr_o = {{3 {instr_i[12]}}, instr_i[4:3], instr_i[5], instr_i[2],
108                                 instr_i[6], 4'b0, 5'h02, 3'b000, 5'h02, {OPCODE_OP_IMM}};
109                    end
110        
           -8-
           ==>
           MISSING_ELSE
           ==>
111                    if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;
112                  end
113        
114                  3'b100: begin
115                    unique case (instr_i[11:10])
                       ==>
116                      2'b00,
117                      2'b01: begin
118                        // 00: c.srli -> srli rd, rd, shamt
119                        // 01: c.srai -> srai rd, rd, shamt
120                        // (c.srli/c.srai hints are translated into a srli/srai hint)
                                                                                        -9-
121                        instr_o = {1'b0, instr_i[10], 5'b0, instr_i[6:2], 2'b01, instr_i[9:7],
122                                   3'b101, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
123                        if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1;
                           ==>
124                      end
125        
126                      2'b10: begin
127                        // c.andi -> andi rd, rd, imm
128                        instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 2'b01, instr_i[9:7],
129                                   3'b111, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
                                      ==>
130                      end
131        
132                      2'b11: begin
133                        unique case ({instr_i[12], instr_i[6:5]})
134                          3'b000: begin
135                            // c.sub -> sub rd', rd', rs2'
                               ==>
136                            instr_o = {2'b01, 5'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7],
137                                       3'b000, 2'b01, instr_i[9:7], {OPCODE_OP}};
138                          end
139        
140                          3'b001: begin
141                            // c.xor -> xor rd', rd', rs2'
                               ==>
142                            instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b100,
143                                       2'b01, instr_i[9:7], {OPCODE_OP}};
144                          end
145        
146                          3'b010: begin
147                            // c.or  -> or  rd', rd', rs2'
148                            instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b110,
149                                       2'b01, instr_i[9:7], {OPCODE_OP}};
150                          end
151        
           ==>
152                          3'b011: begin
153                            // c.and -> and rd', rd', rs2'
154                            instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b111,
155                                       2'b01, instr_i[9:7], {OPCODE_OP}};
                                          ==>
156                          end
157        
158                          3'b100,
159                          3'b101,
160                          3'b110,
161                          3'b111: begin
                             ==>
162                            // 100: c.subw
163                            // 101: c.addw
164                            illegal_instr_o = 1'b1;
165                          end
166        
167                          default: begin
168                            illegal_instr_o = 1'b1;
169                          end
                             ==>
170                        endcase
171                      end
172        
173                      default: begin
174                        illegal_instr_o = 1'b1;
175                      end
                         ==>
176                    endcase
177                  end
178        
179                  3'b110, 3'b111: begin
180                    // 0: c.beqz -> beq rs1', x0, imm
181                    // 1: c.bnez -> bne rs1', x0, imm
182                    instr_o = {{4 {instr_i[12]}}, instr_i[6:5], instr_i[2], 5'b0, 2'b01,
183                               instr_i[9:7], 2'b00, instr_i[13], instr_i[11:10], instr_i[4:3],
184                               instr_i[12], {OPCODE_BRANCH}};
185                  end
186        
           -10-
187                  default: begin
188                    illegal_instr_o = 1'b1;
189                  end
190                endcase
191              end
                 -11-   
                 ==>
                 MISSING_ELSE
                 ==>
192        
193              // C2
194              //
195              // Register address checks for RV32E are performed in the regular instruction decoder.
196              // If this check fails, an illegal instruction exception is triggered and the controller
197              // writes the actual faulting instruction to mtval.
198              2'b10: begin
                 -12-            
                 ==>
                 MISSING_ELSE
                 ==>
199                unique case (instr_i[15:13])
200                  3'b000: begin
201                    // c.slli -> slli rd, rd, shamt
202                    // (c.ssli hints are translated into a slli hint)
                                                                        -13-
203                    instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], {OPCODE_OP_IMM}};
                       -14-                                                                                      
204                    if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1; // reserved for custom extensions
205                  end
206        
           ==>
207                  3'b010: begin
208                    // c.lwsp -> lw rd, imm(x2)
209                    instr_o = {4'b0, instr_i[3:2], instr_i[12], instr_i[6:4], 2'b00, 5'h02,
210                               3'b010, instr_i[11:7], OPCODE_LOAD};
                                  -15-                                    
                                  ==>
                                  MISSING_ELSE
                                  ==>
211                    if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
212                  end
213        
           -16-
214                  3'b100: begin
215                    if (instr_i[12] == 1'b0) begin
216                      if (instr_i[6:2] != 5'b0) begin
                         ==>
217                        // c.mv -> add rd/rs1, x0, rs2
218                        // (c.mv hints are translated into an add hint)
                                                                          -17-
219                        instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], {OPCODE_OP}};
220                      end else begin
                         ==>
221                        // c.jr -> jalr x0, rd/rs1, 0
222                        instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, {OPCODE_JALR}};
223                        if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
                           ==>
224                      end
225                    end else begin
226                      if (instr_i[6:2] != 5'b0) begin
227                        // c.add -> add rd, rd, rs2
228                        // (c.add hints are translated into an add hint)
229                        instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP}};
230                      end else begin
231                        if (instr_i[11:7] == 5'b0) begin
                           ==>
232                          // c.ebreak -> ebreak
233                          instr_o = {32'h00_10_00_73};
234                        end else begin
235                          // c.jalr -> jalr x1, rs1, 0
236                          instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, {OPCODE_JALR}};
237                        end
238                      end
239                    end
                       ==>
240                  end
241        
242                  3'b110: begin
243                    // c.swsp -> sw rs2, imm(x2)
                       ==>
244                    instr_o = {4'b0, instr_i[8:7], instr_i[12], instr_i[6:2], 5'h02, 3'b010,
245                               instr_i[11:9], 2'b00, {OPCODE_STORE}};
246                  end
247        
248                  3'b001,
249                  3'b011,
250                  3'b101,
                     ==>

Branches:

-1-     -2-     -3- -4-            -5- -6- -7-        -8- -9-                          -10-                       -11- -12- -13- -14- -15- -16- -17- Status      
2'b00   3'b000  1   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b00   3'b000  0   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b00   3'b010  -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b00   3'b110  -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b00   default -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b000         -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b1 3'b101    -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b010         -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b011         1   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b011         0   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b011         -   1   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b011         -   0   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b100         -   -   2'b0 2'b1  1   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b100         -   -   2'b0 2'b1  0   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b100         -   -   2'b10      -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b100         -   -   2'b11      -   3'b000                       -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b100         -   -   2'b11      -   3'b001                       -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b100         -   -   2'b11      -   3'b010                       -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b100         -   -   2'b11      -   3'b011                       -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b100         -   -   2'b11      -   3'b100 3'b101 3'b110 3'b111  -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   3'b100         -   -   2'b11      -   default                      -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -       -   3'b100         -   -   default    -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b01   -       -   3'b110 3'b111  -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     
2'b01   -       -   default        -   -   -          -   -                            -                          -    -    -    -    -    -    -    Not Covered 
2'b10   -       -   -              -   -   -          -   -                            3'b000                     1    -    -    -    -    -    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b000                     0    -    -    -    -    -    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b010                     -    1    -    -    -    -    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b010                     -    0    -    -    -    -    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    1    1    -    -    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    1    0    1    -    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    1    0    0    -    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    0    -    -    1    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    0    -    -    0    1    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    0    -    -    0    0    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b110                     -    -    -    -    -    -    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            3'b1 3'b011 3'b101 3'b111  -    -    -    -    -    -    -    Covered     
2'b10   -       -   -              -   -   -          -   -                            default                    -    -    -    -    -    -    -    Not Covered 
default -       -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered     


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.if_stage_i.compressed_decoder_i(x)
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                    
 91.17  92.86 --     --      89.47 --     ibex_compressed_decoder 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME          
100.00 100.00 --     --     100.00 100.00 if_stage_i(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.if_stage_i.compressed_decoder_i(x)

             Line No.   Total   Covered  Percent
TOTAL                       52       52   100.00
ALWAYS             25       52       52   100.00

24                        // Compressed decoder //
25         1/1            ////////////////////////
26         1/1          
27                        always_comb begin
28         1/1              // By default, forward incoming instruction, mark it as legal.
29                          instr_o         = instr_i;
30                          illegal_instr_o = 1'b0;
31         1/1          
32                          // Check if incoming instruction is compressed.
33                          unique case (instr_i[1:0])
34         1/1                // C0
35                            2'b00: begin
36         2/2                  unique case (instr_i[15:13])
                        MISSING_ELSE
37                                3'b000: begin
38                                  // c.addi4spn -> addi rd', x2, imm
39                                  instr_o = {2'b0, instr_i[10:7], instr_i[12:11], instr_i[5],
40                                             instr_i[6], 2'b00, 5'h02, 3'b000, 2'b01, instr_i[4:2], {OPCODE_OP_IMM}};
41         1/1                      if (instr_i[12:5] == 8'b0)  illegal_instr_o = 1'b1;
42                                end
43                      
44                                3'b010: begin
45                                  // c.lw -> lw rd', imm(rs1')
46                                  instr_o = {5'b0, instr_i[5], instr_i[12:10], instr_i[6],
47         1/1                                 2'b00, 2'b01, instr_i[9:7], 3'b010, 2'b01, instr_i[4:2], {OPCODE_LOAD}};
48                                end
49                      
50                                3'b110: begin
51                                  // c.sw -> sw rs2', imm(rs1')
52                                  instr_o = {5'b0, instr_i[5], instr_i[12], 2'b01, instr_i[4:2],
53         1/1                                 2'b01, instr_i[9:7], 3'b010, instr_i[11:10], instr_i[6],
54                                             2'b00, {OPCODE_STORE}};
55                                end
56                      
57                                3'b001,
58                                3'b011,
59                                3'b100,
60                                3'b101,
61                                3'b111: begin
62                                  illegal_instr_o = 1'b1;
63                                end
64         1/1          
65                                default: begin
66                                  illegal_instr_o = 1'b1;
67                                end
68         1/1                  endcase
69                            end
70                      
71                            // C1
72                            //
73                            // Register address checks for RV32E are performed in the regular instruction decoder.
74                            // If this check fails, an illegal instruction exception is triggered and the controller
75         1/1                // writes the actual faulting instruction to mtval.
76                            2'b01: begin
77                              unique case (instr_i[15:13])
78                                3'b000: begin
79                                  // c.addi -> addi rd, rd, nzimm
80                                  // c.nop
81                                  instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2],
82                                             instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
83         1/1                    end
84                      
85                                3'b001, 3'b101: begin
86                                  // 001: c.jal -> jal x1, imm
87                                  // 101: c.j   -> jal x0, imm
88                                  instr_o = {instr_i[12], instr_i[8], instr_i[10:9], instr_i[6],
89                                             instr_i[7], instr_i[2], instr_i[11], instr_i[5:3],
90         1/1                                 {9 {instr_i[12]}}, 4'b0, ~instr_i[15], {OPCODE_JAL}};
91                                end
92         1/1          
93                                3'b010: begin
94         1/1                      // c.li -> addi rd, x0, nzimm
95                                  // (c.li hints are translated into an addi hint)
96                                  instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0,
                        MISSING_ELSE
97                                             3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
98         2/2                    end
                        MISSING_ELSE
99                      
100                               3'b011: begin
101                                 // c.lui -> lui rd, imm
102        1/1                      // (c.lui hints are translated into a lui hint)
103                                 instr_o = {{15 {instr_i[12]}}, instr_i[6:2], instr_i[11:7], {OPCODE_LUI}};
104                     
105                                 if (instr_i[11:7] == 5'h02) begin
106                                   // c.addi16sp -> addi x2, x2, nzimm
107                                   instr_o = {{3 {instr_i[12]}}, instr_i[4:3], instr_i[5], instr_i[2],
108        1/1                                   instr_i[6], 4'b0, 5'h02, 3'b000, 5'h02, {OPCODE_OP_IMM}};
109                                 end
110        2/2          
                        MISSING_ELSE
111                                 if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;
112                               end
113                     
114                               3'b100: begin
115        1/1                      unique case (instr_i[11:10])
116                                   2'b00,
117                                   2'b01: begin
118                                     // 00: c.srli -> srli rd, rd, shamt
119                                     // 01: c.srai -> srai rd, rd, shamt
120        1/1                          // (c.srli/c.srai hints are translated into a srli/srai hint)
121                                     instr_o = {1'b0, instr_i[10], 5'b0, instr_i[6:2], 2'b01, instr_i[9:7],
122                                                3'b101, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
123        1/1                          if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1;
124                                   end
125                     
126                                   2'b10: begin
127                                     // c.andi -> andi rd, rd, imm
128                                     instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 2'b01, instr_i[9:7],
129        1/1                                     3'b111, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
130                                   end
131                     
132                                   2'b11: begin
133                                     unique case ({instr_i[12], instr_i[6:5]})
134                                       3'b000: begin
135        1/1                              // c.sub -> sub rd', rd', rs2'
136                                         instr_o = {2'b01, 5'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7],
137                                                    3'b000, 2'b01, instr_i[9:7], {OPCODE_OP}};
138                                       end
139                     
140                                       3'b001: begin
141        1/1                              // c.xor -> xor rd', rd', rs2'
142                                         instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b100,
143                                                    2'b01, instr_i[9:7], {OPCODE_OP}};
144                                       end
145                     
146                                       3'b010: begin
147                                         // c.or  -> or  rd', rd', rs2'
148                                         instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b110,
149                                                    2'b01, instr_i[9:7], {OPCODE_OP}};
150                                       end
151        1/1          
152                                       3'b011: begin
153                                         // c.and -> and rd', rd', rs2'
154                                         instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b111,
155        excluded                                    2'b01, instr_i[9:7], {OPCODE_OP}};
156                                       end
157                     
158                                       3'b100,
159                                       3'b101,
160                                       3'b110,
161        excluded                       3'b111: begin
162                                         // 100: c.subw
163                                         // 101: c.addw
164                                         illegal_instr_o = 1'b1;
165                                       end
166                     
167                                       default: begin
168                                         illegal_instr_o = 1'b1;
169        1/1                            end
170                                     endcase
171                                   end
172                     
173                                   default: begin
174                                     illegal_instr_o = 1'b1;
175        excluded                   end
176                                 endcase
177                               end
178                     
179                               3'b110, 3'b111: begin
180                                 // 0: c.beqz -> beq rs1', x0, imm
181                                 // 1: c.bnez -> bne rs1', x0, imm
182                                 instr_o = {{4 {instr_i[12]}}, instr_i[6:5], instr_i[2], 5'b0, 2'b01,
183                                            instr_i[9:7], 2'b00, instr_i[13], instr_i[11:10], instr_i[4:3],
184                                            instr_i[12], {OPCODE_BRANCH}};
185                               end
186        1/1          
187                               default: begin
188                                 illegal_instr_o = 1'b1;
189                               end
190        1/1                  endcase
191        2/2                end
                        MISSING_ELSE
192                     
193                           // C2
194                           //
195                           // Register address checks for RV32E are performed in the regular instruction decoder.
196        1/1                // If this check fails, an illegal instruction exception is triggered and the controller
197                           // writes the actual faulting instruction to mtval.
198        2/2                2'b10: begin
                        MISSING_ELSE
199                             unique case (instr_i[15:13])
200                               3'b000: begin
201                                 // c.slli -> slli rd, rd, shamt
202        1/1                      // (c.ssli hints are translated into a slli hint)
203        1/1                      instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], {OPCODE_OP_IMM}};
204                                 if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1; // reserved for custom extensions
205                               end
206        1/1          
207                               3'b010: begin
208                                 // c.lwsp -> lw rd, imm(x2)
209        1/1                      instr_o = {4'b0, instr_i[3:2], instr_i[12], instr_i[6:4], 2'b00, 5'h02,
210        2/2                                 3'b010, instr_i[11:7], OPCODE_LOAD};
                        MISSING_ELSE
211                                 if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
212                               end
213        1/1          
214                               3'b100: begin
215                                 if (instr_i[12] == 1'b0) begin
216        1/1                        if (instr_i[6:2] != 5'b0) begin
217                                     // c.mv -> add rd/rs1, x0, rs2
218        1/1                          // (c.mv hints are translated into an add hint)
219                                     instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], {OPCODE_OP}};
220        1/1                        end else begin
221                                     // c.jr -> jalr x0, rd/rs1, 0
222                                     instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, {OPCODE_JALR}};
223        1/1                          if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
224                                   end
225                                 end else begin
226                                   if (instr_i[6:2] != 5'b0) begin
227                                     // c.add -> add rd, rd, rs2
228                                     // (c.add hints are translated into an add hint)
229                                     instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP}};
230                                   end else begin
231        1/1                          if (instr_i[11:7] == 5'b0) begin
232                                       // c.ebreak -> ebreak
233                                       instr_o = {32'h00_10_00_73};
234                                     end else begin
235                                       // c.jalr -> jalr x1, rs1, 0
236                                       instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, {OPCODE_JALR}};
237                                     end
238                                   end
239        1/1                      end
240                               end
241                     
242                               3'b110: begin
243        excluded                 // c.swsp -> sw rs2, imm(x2)
244                                 instr_o = {4'b0, instr_i[8:7], instr_i[12], instr_i[6:2], 5'h02, 3'b010,
245                                            instr_i[11:9], 2'b00, {OPCODE_STORE}};
246                               end
247                     
248                               3'b001,
249                               3'b011,
250        1/1                    3'b101,

-------------------------------------------------------------------------------
Branch Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.if_stage_i.compressed_decoder_i(x)
         Line No. Total Covered Percent 
Branches          34    34      100.00  
CASE     28       34    34      100.00  


28             // By default, forward incoming instruction, mark it as legal.
                                                                             -1-
29             instr_o         = instr_i;
30             illegal_instr_o = 1'b0;
31         
           -2-
32             // Check if incoming instruction is compressed.
33             unique case (instr_i[1:0])
34               // C0
35               2'b00: begin
36                 unique case (instr_i[15:13])
                   -3-                            
                   ==>
                   MISSING_ELSE
                   ==>
37                   3'b000: begin
38                     // c.addi4spn -> addi rd', x2, imm
39                     instr_o = {2'b0, instr_i[10:7], instr_i[12:11], instr_i[5],
40                                instr_i[6], 2'b00, 5'h02, 3'b000, 2'b01, instr_i[4:2], {OPCODE_OP_IMM}};
41                     if (instr_i[12:5] == 8'b0)  illegal_instr_o = 1'b1;
                       ==>
42                   end
43         
44                   3'b010: begin
45                     // c.lw -> lw rd', imm(rs1')
46                     instr_o = {5'b0, instr_i[5], instr_i[12:10], instr_i[6],
47                                2'b00, 2'b01, instr_i[9:7], 3'b010, 2'b01, instr_i[4:2], {OPCODE_LOAD}};
                                  ==>
48                   end
49         
50                   3'b110: begin
51                     // c.sw -> sw rs2', imm(rs1')
52                     instr_o = {5'b0, instr_i[5], instr_i[12], 2'b01, instr_i[4:2],
53                                2'b01, instr_i[9:7], 3'b010, instr_i[11:10], instr_i[6],
                                  ==>
54                                2'b00, {OPCODE_STORE}};
55                   end
56         
57                   3'b001,
58                   3'b011,
59                   3'b100,
60                   3'b101,
61                   3'b111: begin
62                     illegal_instr_o = 1'b1;
63                   end
64         
           -4-
65                   default: begin
66                     illegal_instr_o = 1'b1;
67                   end
68                 endcase
                   ==>
69               end
70         
71               // C1
72               //
73               // Register address checks for RV32E are performed in the regular instruction decoder.
74               // If this check fails, an illegal instruction exception is triggered and the controller
75               // writes the actual faulting instruction to mtval.
                 ==>
76               2'b01: begin
77                 unique case (instr_i[15:13])
78                   3'b000: begin
79                     // c.addi -> addi rd, rd, nzimm
80                     // c.nop
81                     instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2],
82                                instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
83                   end
                     ==>
84         
85                   3'b001, 3'b101: begin
86                     // 001: c.jal -> jal x1, imm
87                     // 101: c.j   -> jal x0, imm
88                     instr_o = {instr_i[12], instr_i[8], instr_i[10:9], instr_i[6],
89                                instr_i[7], instr_i[2], instr_i[11], instr_i[5:3],
90                                {9 {instr_i[12]}}, 4'b0, ~instr_i[15], {OPCODE_JAL}};
91                   end
92         
           -5-
93                   3'b010: begin
94                     // c.li -> addi rd, x0, nzimm
                       ==>
95                     // (c.li hints are translated into an addi hint)
96                     instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0,
                       MISSING_ELSE
                       ==>
97                                3'b0, instr_i[11:7], {OPCODE_OP_IMM}};
98                   end
                     -6-   
                     ==>
                     MISSING_ELSE
                     ==>
99         
100                  3'b011: begin
101                    // c.lui -> lui rd, imm
102                    // (c.lui hints are translated into a lui hint)
                                                                      -7-
103                    instr_o = {{15 {instr_i[12]}}, instr_i[6:2], instr_i[11:7], {OPCODE_LUI}};
104        
105                    if (instr_i[11:7] == 5'h02) begin
106                      // c.addi16sp -> addi x2, x2, nzimm
107                      instr_o = {{3 {instr_i[12]}}, instr_i[4:3], instr_i[5], instr_i[2],
108                                 instr_i[6], 4'b0, 5'h02, 3'b000, 5'h02, {OPCODE_OP_IMM}};
109                    end
110        
           -8-
           ==>
           MISSING_ELSE
           ==>
111                    if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;
112                  end
113        
114                  3'b100: begin
115                    unique case (instr_i[11:10])
                       ==>
116                      2'b00,
117                      2'b01: begin
118                        // 00: c.srli -> srli rd, rd, shamt
119                        // 01: c.srai -> srai rd, rd, shamt
120                        // (c.srli/c.srai hints are translated into a srli/srai hint)
                                                                                        -9-
121                        instr_o = {1'b0, instr_i[10], 5'b0, instr_i[6:2], 2'b01, instr_i[9:7],
122                                   3'b101, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
123                        if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1;
                           ==>
124                      end
125        
126                      2'b10: begin
127                        // c.andi -> andi rd, rd, imm
128                        instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 2'b01, instr_i[9:7],
129                                   3'b111, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};
                                      ==>
130                      end
131        
132                      2'b11: begin
133                        unique case ({instr_i[12], instr_i[6:5]})
134                          3'b000: begin
135                            // c.sub -> sub rd', rd', rs2'
                               ==>
136                            instr_o = {2'b01, 5'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7],
137                                       3'b000, 2'b01, instr_i[9:7], {OPCODE_OP}};
138                          end
139        
140                          3'b001: begin
141                            // c.xor -> xor rd', rd', rs2'
                               ==>
142                            instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b100,
143                                       2'b01, instr_i[9:7], {OPCODE_OP}};
144                          end
145        
146                          3'b010: begin
147                            // c.or  -> or  rd', rd', rs2'
148                            instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b110,
149                                       2'b01, instr_i[9:7], {OPCODE_OP}};
150                          end
151        
           ==>
152                          3'b011: begin
153                            // c.and -> and rd', rd', rs2'
154                            instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b111,
155                                       2'b01, instr_i[9:7], {OPCODE_OP}};
                                          ==> (Excluded)
156                          end
157        
158                          3'b100,
159                          3'b101,
160                          3'b110,
161                          3'b111: begin
                             ==> (Excluded)
162                            // 100: c.subw
163                            // 101: c.addw
164                            illegal_instr_o = 1'b1;
165                          end
166        
167                          default: begin
168                            illegal_instr_o = 1'b1;
169                          end
                             ==>
170                        endcase
171                      end
172        
173                      default: begin
174                        illegal_instr_o = 1'b1;
175                      end
                         ==> (Excluded)
176                    endcase
177                  end
178        
179                  3'b110, 3'b111: begin
180                    // 0: c.beqz -> beq rs1', x0, imm
181                    // 1: c.bnez -> bne rs1', x0, imm
182                    instr_o = {{4 {instr_i[12]}}, instr_i[6:5], instr_i[2], 5'b0, 2'b01,
183                               instr_i[9:7], 2'b00, instr_i[13], instr_i[11:10], instr_i[4:3],
184                               instr_i[12], {OPCODE_BRANCH}};
185                  end
186        
           -10-
187                  default: begin
188                    illegal_instr_o = 1'b1;
189                  end
190                endcase
191              end
                 -11-   
                 ==>
                 MISSING_ELSE
                 ==>
192        
193              // C2
194              //
195              // Register address checks for RV32E are performed in the regular instruction decoder.
196              // If this check fails, an illegal instruction exception is triggered and the controller
197              // writes the actual faulting instruction to mtval.
198              2'b10: begin
                 -12-            
                 ==>
                 MISSING_ELSE
                 ==>
199                unique case (instr_i[15:13])
200                  3'b000: begin
201                    // c.slli -> slli rd, rd, shamt
202                    // (c.ssli hints are translated into a slli hint)
                                                                        -13-
203                    instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], {OPCODE_OP_IMM}};
                       -14-                                                                                      
204                    if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1; // reserved for custom extensions
205                  end
206        
           ==>
207                  3'b010: begin
208                    // c.lwsp -> lw rd, imm(x2)
209                    instr_o = {4'b0, instr_i[3:2], instr_i[12], instr_i[6:4], 2'b00, 5'h02,
210                               3'b010, instr_i[11:7], OPCODE_LOAD};
                                  -15-                                    
                                  ==>
                                  MISSING_ELSE
                                  ==>
211                    if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
212                  end
213        
           -16-
214                  3'b100: begin
215                    if (instr_i[12] == 1'b0) begin
216                      if (instr_i[6:2] != 5'b0) begin
                         ==>
217                        // c.mv -> add rd/rs1, x0, rs2
218                        // (c.mv hints are translated into an add hint)
                                                                          -17-
219                        instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], {OPCODE_OP}};
220                      end else begin
                         ==>
221                        // c.jr -> jalr x0, rd/rs1, 0
222                        instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, {OPCODE_JALR}};
223                        if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;
                           ==>
224                      end
225                    end else begin
226                      if (instr_i[6:2] != 5'b0) begin
227                        // c.add -> add rd, rd, rs2
228                        // (c.add hints are translated into an add hint)
229                        instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP}};
230                      end else begin
231                        if (instr_i[11:7] == 5'b0) begin
                           ==>
232                          // c.ebreak -> ebreak
233                          instr_o = {32'h00_10_00_73};
234                        end else begin
235                          // c.jalr -> jalr x1, rs1, 0
236                          instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, {OPCODE_JALR}};
237                        end
238                      end
239                    end
                       ==>
240                  end
241        
242                  3'b110: begin
243                    // c.swsp -> sw rs2, imm(x2)
                       ==> (Excluded)
244                    instr_o = {4'b0, instr_i[8:7], instr_i[12], instr_i[6:2], 5'h02, 3'b010,
245                               instr_i[11:9], 2'b00, {OPCODE_STORE}};
246                  end
247        
248                  3'b001,
249                  3'b011,
250                  3'b101,
                     ==>

Branches:

-1-     -2-     -3- -4-            -5- -6- -7-        -8- -9-                          -10-                       -11- -12- -13- -14- -15- -16- -17- Status   
2'b00   3'b000  1   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b00   3'b000  0   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b00   3'b010  -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b00   3'b110  -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b00   default -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b000         -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b1 3'b101    -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b010         -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b011         1   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b011         0   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b011         -   1   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b011         -   0   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b100         -   -   2'b0 2'b1  1   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b100         -   -   2'b0 2'b1  0   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b100         -   -   2'b10      -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b100         -   -   2'b11      -   3'b000                       -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b100         -   -   2'b11      -   3'b001                       -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b100         -   -   2'b11      -   3'b010                       -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b100         -   -   2'b11      -   3'b011                       -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b100         -   -   2'b11      -   3'b100 3'b101 3'b110 3'b111  -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   3'b100         -   -   2'b11      -   default                      -                          -    -    -    -    -    -    -    Excluded 
2'b01   -       -   3'b100         -   -   default    -   -                            -                          -    -    -    -    -    -    -    Excluded 
2'b01   -       -   3'b110 3'b111  -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  
2'b01   -       -   default        -   -   -          -   -                            -                          -    -    -    -    -    -    -    Excluded 
2'b10   -       -   -              -   -   -          -   -                            3'b000                     1    -    -    -    -    -    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b000                     0    -    -    -    -    -    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b010                     -    1    -    -    -    -    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b010                     -    0    -    -    -    -    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    1    1    -    -    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    1    0    1    -    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    1    0    0    -    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    0    -    -    1    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    0    -    -    0    1    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b100                     -    -    0    -    -    0    0    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b110                     -    -    -    -    -    -    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            3'b1 3'b011 3'b101 3'b111  -    -    -    -    -    -    -    Covered  
2'b10   -       -   -              -   -   -          -   -                            default                    -    -    -    -    -    -    -    Excluded 
default -       -   -              -   -   -          -   -                            -                          -    -    -    -    -    -    -    Covered  


===============================================================================
Module : ibex_cs_registers
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 94.54  97.03 --     --      92.05 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_cs_registers.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                               
 94.75  97.45 --     --      92.05 --     core_ibex_tb_top.dut.u_ibex_core.cs_registers_i(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_cs_registers

             Line No.   Total   Covered  Percent
TOTAL                      236      229    97.03
ALWAYS            245       71       71   100.00
ALWAYS            413       83       78    93.98
ALWAYS            605        9        9   100.00
ALWAYS            647       31       31   100.00
ALWAYS            837        3        2    66.67
ALWAYS            855       13       13   100.00
ALWAYS            878        0        0
ALWAYS            878        6        6   100.00
ALWAYS            893        0        0
ALWAYS            893        6        6   100.00
ALWAYS            911        8        7    87.50
ALWAYS            931        6        6   100.00

244                       always_comb begin
245        1/1              csr_rdata_int = '0;
246        1/1              illegal_csr   = 1'b0;
247                     
248        1/1              unique case (csr_addr_i)
249                           // mhartid: unique hardware thread id
250        1/1                CSR_MHARTID: csr_rdata_int = hart_id_i;
251                     
252                           // mstatus: always M-mode, contains IE bit
253                           CSR_MSTATUS: begin
254        1/1                  csr_rdata_int                                                   = '0;
255        1/1                  csr_rdata_int[CSR_MSTATUS_MIE_BIT]                              = mstatus_q.mie;
256        1/1                  csr_rdata_int[CSR_MSTATUS_MPIE_BIT]                             = mstatus_q.mpie;
257        1/1                  csr_rdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW] = mstatus_q.mpp;
258        1/1                  csr_rdata_int[CSR_MSTATUS_MPRV_BIT]                             = mstatus_q.mprv;
259        1/1                  csr_rdata_int[CSR_MSTATUS_TW_BIT]                               = mstatus_q.tw;
260                           end
261                     
262                           // misa
263        1/1                CSR_MISA: csr_rdata_int = MISA_VALUE;
264                     
265                           // interrupt enable
266                           CSR_MIE: begin
267        1/1                  csr_rdata_int                                     = '0;
268        1/1                  csr_rdata_int[CSR_MSIX_BIT]                       = mie_q.irq_software;
269        1/1                  csr_rdata_int[CSR_MTIX_BIT]                       = mie_q.irq_timer;
270        1/1                  csr_rdata_int[CSR_MEIX_BIT]                       = mie_q.irq_external;
271        1/1                  csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mie_q.irq_fast;
272                           end
273                     
274        1/1                CSR_MSCRATCH: csr_rdata_int = mscratch_q;
275                     
276                           // mtvec: trap-vector base address
277        1/1                CSR_MTVEC: csr_rdata_int = mtvec_q;
278                     
279                           // mepc: exception program counter
280        1/1                CSR_MEPC: csr_rdata_int = mepc_q;
281                     
282                           // mcause: exception cause
283        1/1                CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};
284                     
285                           // mtval: trap value
286        1/1                CSR_MTVAL: csr_rdata_int = mtval_q;
287                     
288                           // mip: interrupt pending
289                           CSR_MIP: begin
290        1/1                  csr_rdata_int                                     = '0;
291        1/1                  csr_rdata_int[CSR_MSIX_BIT]                       = mip.irq_software;
292        1/1                  csr_rdata_int[CSR_MTIX_BIT]                       = mip.irq_timer;
293        1/1                  csr_rdata_int[CSR_MEIX_BIT]                       = mip.irq_external;
294        1/1                  csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mip.irq_fast;
295                           end
296                     
297                           // PMP registers
298        1/1                CSR_PMPCFG0:   csr_rdata_int = {pmp_cfg_rdata[3],  pmp_cfg_rdata[2],
299                                                           pmp_cfg_rdata[1],  pmp_cfg_rdata[0]};
300        1/1                CSR_PMPCFG1:   csr_rdata_int = {pmp_cfg_rdata[7],  pmp_cfg_rdata[6],
301                                                           pmp_cfg_rdata[5],  pmp_cfg_rdata[4]};
302        1/1                CSR_PMPCFG2:   csr_rdata_int = {pmp_cfg_rdata[11], pmp_cfg_rdata[10],
303                                                           pmp_cfg_rdata[9],  pmp_cfg_rdata[8]};
304        1/1                CSR_PMPCFG3:   csr_rdata_int = {pmp_cfg_rdata[15], pmp_cfg_rdata[14],
305                                                           pmp_cfg_rdata[13], pmp_cfg_rdata[12]};
306        1/1                CSR_PMPADDR0:  csr_rdata_int = pmp_addr_rdata[0];
307        1/1                CSR_PMPADDR1:  csr_rdata_int = pmp_addr_rdata[1];
308        1/1                CSR_PMPADDR2:  csr_rdata_int = pmp_addr_rdata[2];
309        1/1                CSR_PMPADDR3:  csr_rdata_int = pmp_addr_rdata[3];
310        1/1                CSR_PMPADDR4:  csr_rdata_int = pmp_addr_rdata[4];
311        1/1                CSR_PMPADDR5:  csr_rdata_int = pmp_addr_rdata[5];
312        1/1                CSR_PMPADDR6:  csr_rdata_int = pmp_addr_rdata[6];
313        1/1                CSR_PMPADDR7:  csr_rdata_int = pmp_addr_rdata[7];
314        1/1                CSR_PMPADDR8:  csr_rdata_int = pmp_addr_rdata[8];
315        1/1                CSR_PMPADDR9:  csr_rdata_int = pmp_addr_rdata[9];
316        1/1                CSR_PMPADDR10: csr_rdata_int = pmp_addr_rdata[10];
317        1/1                CSR_PMPADDR11: csr_rdata_int = pmp_addr_rdata[11];
318        1/1                CSR_PMPADDR12: csr_rdata_int = pmp_addr_rdata[12];
319        1/1                CSR_PMPADDR13: csr_rdata_int = pmp_addr_rdata[13];
320        1/1                CSR_PMPADDR14: csr_rdata_int = pmp_addr_rdata[14];
321        1/1                CSR_PMPADDR15: csr_rdata_int = pmp_addr_rdata[15];
322                     
323                           CSR_DCSR: begin
324        1/1                  csr_rdata_int = dcsr_q;
325        1/1                  illegal_csr = ~debug_mode_i;
326                           end
327                           CSR_DPC: begin
328        1/1                  csr_rdata_int = depc_q;
329        1/1                  illegal_csr = ~debug_mode_i;
330                           end
331                           CSR_DSCRATCH0: begin
332        1/1                  csr_rdata_int = dscratch0_q;
333        1/1                  illegal_csr = ~debug_mode_i;
334                           end
335                           CSR_DSCRATCH1: begin
336        1/1                  csr_rdata_int = dscratch1_q;
337        1/1                  illegal_csr = ~debug_mode_i;
338                           end
339                     
340                           // machine counter/timers
341        1/1                CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit;
342                           CSR_MHPMEVENT3,
343                           CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,
344                           CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,
345                           CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,
346                           CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,
347                           CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,
348                           CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,
349                           CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31: begin
350        1/1                  csr_rdata_int = mhpmevent[mhpmcounter_idx];
351                           end
352                     
353                           CSR_MCYCLE,
354                           CSR_MINSTRET,
355                           CSR_MHPMCOUNTER3,
356                           CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
357                           CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
358                           CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
359                           CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
360                           CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
361                           CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
362                           CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
363        1/1                  csr_rdata_int = mhpmcounter_q[mhpmcounter_idx][31:0];
364                           end
365                     
366                           CSR_MCYCLEH,
367                           CSR_MINSTRETH,
368                           CSR_MHPMCOUNTER3H,
369                           CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
370                           CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
371                           CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
372                           CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
373                           CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
374                           CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
375                           CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
376        1/1                  csr_rdata_int = mhpmcounter_q[mhpmcounter_idx][63:32];
377                           end
378                     
379                           // Debug triggers
380                           CSR_TSELECT: begin
381        1/1                  csr_rdata_int = tselect_rdata;
382        1/1                  illegal_csr   = ~DbgTriggerEn;
383                           end
384                           CSR_TDATA1: begin
385        1/1                  csr_rdata_int = tmatch_control_rdata;
386        1/1                  illegal_csr   = ~DbgTriggerEn;
387                           end
388                           CSR_TDATA2: begin
389        1/1                  csr_rdata_int = tmatch_value_rdata;
390        1/1                  illegal_csr   = ~DbgTriggerEn;
391                           end
392                           CSR_TDATA3: begin
393        1/1                  csr_rdata_int = '0;
394        1/1                  illegal_csr   = ~DbgTriggerEn;
395                           end
396                           CSR_MCONTEXT: begin
397        1/1                  csr_rdata_int = '0;
398        1/1                  illegal_csr   = ~DbgTriggerEn;
399                           end
400                           CSR_SCONTEXT: begin
401        1/1                  csr_rdata_int = '0;
402        1/1                  illegal_csr   = ~DbgTriggerEn;
403                           end
404                     
405                           default: begin
406        1/1                  illegal_csr = 1'b1;
407                           end
408                         endcase
409                       end
410                     
411                       // write logic
412                       always_comb begin
413        1/1              exception_pc = pc_id_i;
414                     
415        1/1              priv_lvl_d   = priv_lvl_q;
416        1/1              mstatus_d    = mstatus_q;
417        1/1              mie_d        = mie_q;
418        1/1              mscratch_d   = mscratch_q;
419        1/1              mepc_d       = mepc_q;
420        1/1              mcause_d     = mcause_q;
421        1/1              mtval_d      = mtval_q;
422        1/1              mtvec_d      = csr_mtvec_init_i ? {boot_addr_i[31:8], 6'b0, 2'b01} : mtvec_q;
423        1/1              dcsr_d       = dcsr_q;
424        1/1              depc_d       = depc_q;
425        1/1              dscratch0_d  = dscratch0_q;
426        1/1              dscratch1_d  = dscratch1_q;
427                     
428        1/1              mstack_d       = mstack_q;
429        1/1              mstack_epc_d   = mstack_epc_q;
430        1/1              mstack_cause_d = mstack_cause_q;
431                     
432        1/1              mcountinhibit_we = 1'b0;
433        1/1              mhpmcounter_we   = '0;
434        1/1              mhpmcounterh_we  = '0;
435                     
436        1/1              if (csr_we_int) begin
437        1/1                unique case (csr_addr_i)
438                             // mstatus: IE bit
439                             CSR_MSTATUS: begin
440        1/1                    mstatus_d = '{
441                                   mie:  csr_wdata_int[CSR_MSTATUS_MIE_BIT],
442                                   mpie: csr_wdata_int[CSR_MSTATUS_MPIE_BIT],
443                                   mpp:  priv_lvl_e'(csr_wdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW]),
444                                   mprv: csr_wdata_int[CSR_MSTATUS_MPRV_BIT],
445                                   tw:   csr_wdata_int[CSR_MSTATUS_TW_BIT]
446                               };
447                               // Convert illegal values to M-mode
448        1/1                    if ((mstatus_d.mpp != PRIV_LVL_M) && (mstatus_d.mpp != PRIV_LVL_U)) begin
449        0/1     ==>              mstatus_d.mpp = PRIV_LVL_M;
450                               end
                        MISSING_ELSE
451                             end
452                     
453                             // interrupt enable
454                             CSR_MIE: begin
455        1/1                    mie_d.irq_software = csr_wdata_int[CSR_MSIX_BIT];
456        1/1                    mie_d.irq_timer    = csr_wdata_int[CSR_MTIX_BIT];
457        1/1                    mie_d.irq_external = csr_wdata_int[CSR_MEIX_BIT];
458        1/1                    mie_d.irq_fast     = csr_wdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW];
459                             end
460                     
461        1/1                  CSR_MSCRATCH: mscratch_d = csr_wdata_int;
462                     
463                             // mepc: exception program counter
464        1/1                  CSR_MEPC: mepc_d = {csr_wdata_int[31:1], 1'b0};
465                     
466                             // mcause
467        1/1                  CSR_MCAUSE: mcause_d = {csr_wdata_int[31], csr_wdata_int[4:0]};
468                     
469                             // mtval: trap value
470        1/1                  CSR_MTVAL: mtval_d = csr_wdata_int;
471                     
472                             // mtvec
473                             // mtvec.MODE set to vectored
474                             // mtvec.BASE must be 256-byte aligned
475        1/1                  CSR_MTVEC: mtvec_d = {csr_wdata_int[31:8], 6'b0, 2'b01};
476                     
477                             CSR_DCSR: begin
478        1/1                    dcsr_d = csr_wdata_int;
479        1/1                    dcsr_d.xdebugver = XDEBUGVER_STD;
480                               // Change to PRIV_LVL_M if software writes an unsupported value
481        1/1                    if ((dcsr_d.prv != PRIV_LVL_M) && (dcsr_d.prv != PRIV_LVL_U)) begin
482        0/1     ==>              dcsr_d.prv = PRIV_LVL_M;
483                               end
                        MISSING_ELSE
484                     
485                               // currently not supported:
486        1/1                    dcsr_d.nmip = 1'b0;
487        1/1                    dcsr_d.mprven = 1'b0;
488        1/1                    dcsr_d.stopcount = 1'b0;
489        1/1                    dcsr_d.stoptime = 1'b0;
490                     
491                               // forced to be zero
492        1/1                    dcsr_d.zero0 = 1'b0;
493        1/1                    dcsr_d.zero1 = 1'b0;
494        1/1                    dcsr_d.zero2 = 12'h0;
495                             end
496                     
497                             // dpc: debug program counter
498        1/1                  CSR_DPC: depc_d = {csr_wdata_int[31:1], 1'b0};
499                     
500        1/1                  CSR_DSCRATCH0: dscratch0_d = csr_wdata_int;
501        1/1                  CSR_DSCRATCH1: dscratch1_d = csr_wdata_int;
502                     
503                             // machine counter/timers
504        0/1     ==>          CSR_MCOUNTINHIBIT: mcountinhibit_we = 1'b1;
505                     
506                             CSR_MCYCLE,
507                             CSR_MINSTRET,
508                             CSR_MHPMCOUNTER3,
509                             CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
510                             CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
511                             CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
512                             CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
513                             CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
514                             CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
515                             CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
516        0/1     ==>            mhpmcounter_we[mhpmcounter_idx] = 1'b1;
517                             end
518                     
519                             CSR_MCYCLEH,
520                             CSR_MINSTRETH,
521                             CSR_MHPMCOUNTER3H,
522                             CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
523                             CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
524                             CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
525                             CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
526                             CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
527                             CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
528                             CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
529        1/1                    mhpmcounterh_we[mhpmcounter_idx] = 1'b1;
530                             end
531                     
532        1/1                  default:;
533                           endcase
534                         end
                        MISSING_ELSE
535                     
536                         // exception controller gets priority over other writes
537        1/1              unique case (1'b1)
538                     
539                           csr_save_cause_i: begin
540        1/1                  unique case (1'b1)
541                               csr_save_if_i: begin
542        1/1                      exception_pc = pc_if_i;
543                               end
544                               csr_save_id_i: begin
545        1/1                      exception_pc = pc_id_i;
546                               end
547        0/1     ==>            default:;
548                             endcase
549                     
550                             // Any exception, including debug mode, causes a switch to M-mode
551        1/1                  priv_lvl_d = PRIV_LVL_M;
552                     
553        1/1                  if (debug_csr_save_i) begin
554                               // all interrupts are masked
555                               // do not update cause, epc, tval, epc and status
556        1/1                    dcsr_d.prv   = priv_lvl_q;
557        1/1                    dcsr_d.cause = debug_cause_i;
558        1/1                    depc_d       = exception_pc;
559        1/1                  end else if (!debug_mode_i) begin
560                               // In debug mode, "exceptions do not update any registers. That
561                               // includes cause, epc, tval, dpc and mstatus." [Debug Spec v0.13.2, p.39]
562        1/1                    mtval_d        = csr_mtval_i;
563        1/1                    mstatus_d.mie  = 1'b0; // disable interrupts
564                               // save current status
565        1/1                    mstatus_d.mpie = mstatus_q.mie;
566        1/1                    mstatus_d.mpp  = priv_lvl_q;
567        1/1                    mepc_d         = exception_pc;
568        1/1                    mcause_d       = {csr_mcause_i};
569                               // save previous status for recoverable NMI
570        1/1                    mstack_d.mpie  = mstatus_q.mpie;
571        1/1                    mstack_d.mpp   = mstatus_q.mpp;
572        1/1                    mstack_epc_d   = mepc_q;
573        1/1                    mstack_cause_d = mcause_q;
574                             end
                        MISSING_ELSE
575                           end // csr_save_cause_i
576                     
577                           csr_restore_dret_i: begin // DRET
578        1/1                  priv_lvl_d = dcsr_q.prv;
579                           end // csr_restore_dret_i
580                     
581                           csr_restore_mret_i: begin // MRET
582        1/1                  priv_lvl_d     = mstatus_q.mpp;
583        1/1                  mstatus_d.mie  = mstatus_q.mpie; // re-enable interrupts
584                     
585        1/1                  if (nmi_mode_i) begin
586                               // when returning from an NMI restore state from mstack CSR
587        1/1                    mstatus_d.mpie = mstack_q.mpie;
588        1/1                    mstatus_d.mpp  = mstack_q.mpp;
589        1/1                    mepc_d         = mstack_epc_q;
590        1/1                    mcause_d       = mstack_cause_q;
591                             end else begin
592                               // otherwise just set mstatus.MPIE/MPP
593                               // See RISC-V Privileged Specification, version 1.11, Section 3.1.6.1
594        1/1                    mstatus_d.mpie = 1'b1;
595        1/1                    mstatus_d.mpp  = PRIV_LVL_U;
596                             end
597                           end // csr_restore_mret_i
598                     
599        1/1                default:;
600                         endcase
601                       end
602                     
603                       // CSR operation logic
604                       always_comb begin
605        1/1              csr_wreq = 1'b1;
606                     
607        1/1              unique case (csr_op_i)
608        1/1                CSR_OP_WRITE: csr_wdata_int =  csr_wdata_i;
609        1/1                CSR_OP_SET:   csr_wdata_int =  csr_wdata_i | csr_rdata_o;
610        1/1                CSR_OP_CLEAR: csr_wdata_int = ~csr_wdata_i & csr_rdata_o;
611                           CSR_OP_READ: begin
612        1/1                  csr_wdata_int = csr_wdata_i;
613        1/1                  csr_wreq      = 1'b0;
614                           end
615                           default: begin
616        1/1                  csr_wdata_int = csr_wdata_i;
617        1/1                  csr_wreq      = 1'b0;
618                           end
619                         endcase
620                       end
621                     
622                       // only write CSRs during one clock cycle
623                       assign csr_we_int  = csr_wreq & ~illegal_csr_insn_o & instr_new_id_i;
624                     
625                       assign csr_rdata_o = csr_rdata_int;
626                     
627                       // directly output some registers
628                       assign csr_msip_o  = mip.irq_software;
629                       assign csr_mtip_o  = mip.irq_timer;
630                       assign csr_meip_o  = mip.irq_external;
631                       assign csr_mfip_o  = mip.irq_fast;
632                     
633                       assign csr_mepc_o  = mepc_q;
634                       assign csr_depc_o  = depc_q;
635                       assign csr_mtvec_o = mtvec_q;
636                     
637                       assign csr_mstatus_mie_o   = mstatus_q.mie;
638                       assign csr_mstatus_tw_o    = mstatus_q.tw;
639                       assign debug_single_step_o = dcsr_q.step;
640                       assign debug_ebreakm_o     = dcsr_q.ebreakm;
641                       assign debug_ebreaku_o     = dcsr_q.ebreaku;
642                     
643                       assign irq_pending_o = csr_msip_o | csr_mtip_o | csr_meip_o | (|csr_mfip_o);
644                     
645                       // actual registers
646                       always_ff @(posedge clk_i or negedge rst_ni) begin
647        1/1              if (!rst_ni) begin
648        1/1                priv_lvl_q     <= PRIV_LVL_M;
649        1/1                mstatus_q      <= '{
650                               mie:  1'b0,
651                               mpie: 1'b1,
652                               mpp:  PRIV_LVL_U,
653                               mprv: 1'b0,
654                               tw:   1'b0
655                           };
656        1/1                mie_q          <= '0;
657        1/1                mscratch_q     <= '0;
658        1/1                mepc_q         <= '0;
659        1/1                mcause_q       <= '0;
660        1/1                mtval_q        <= '0;
661        1/1                mtvec_q        <= 32'b01;
662        1/1                dcsr_q         <= '{
663                               xdebugver: XDEBUGVER_STD,
664                               cause:     DBG_CAUSE_NONE, // 3'h0
665                               prv:       PRIV_LVL_M,
666                               default:   '0
667                           };
668        1/1                depc_q         <= '0;
669        1/1                dscratch0_q    <= '0;
670        1/1                dscratch1_q    <= '0;
671                     
672        1/1                mstack_q       <= '{
673                               mpie: 1'b1,
674                               mpp:  PRIV_LVL_U
675                           };
676        1/1                mstack_epc_q   <= '0;
677        1/1                mstack_cause_q <= '0;
678                     
679                         end else begin
680                           // update CSRs
681        1/1                priv_lvl_q     <= priv_lvl_d;
682        1/1                mstatus_q      <= mstatus_d;
683        1/1                mie_q          <= mie_d;
684        1/1                mscratch_q     <= mscratch_d;
685        1/1                mepc_q         <= mepc_d;
686        1/1                mcause_q       <= mcause_d;
687        1/1                mtval_q        <= mtval_d;
688        1/1                mtvec_q        <= mtvec_d;
689        1/1                dcsr_q         <= dcsr_d;
690        1/1                depc_q         <= depc_d;
691        1/1                dscratch0_q    <= dscratch0_d;
692        1/1                dscratch1_q    <= dscratch1_d;
693                     
694        1/1                mstack_q       <= mstack_d;
695        1/1                mstack_epc_q   <= mstack_epc_d;
696        1/1                mstack_cause_q <= mstack_cause_d;
697                     
698                         end
699                       end
700                     
701                       // Send current priv level to the decoder
702                       assign priv_mode_id_o = priv_lvl_q;
703                       // New instruction fetches need to account for updates to priv_lvl_q this cycle
704                       assign priv_mode_if_o = priv_lvl_d;
705                       // Load/store instructions must factor in MPRV for PMP checking
706                       assign priv_mode_lsu_o = mstatus_q.mprv ? mstatus_q.mpp : priv_lvl_q;
707                     
708                       // -----------------
709                       // PMP registers
710                       // -----------------
711                     
712                       if (PMPEnable) begin : g_pmp_registers
713                         pmp_cfg_t                    pmp_cfg         [PMPNumRegions];
714                         pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];
715                         logic [31:0]                 pmp_addr        [PMPNumRegions];
716                         logic [PMPNumRegions-1:0]    pmp_cfg_we;
717                         logic [PMPNumRegions-1:0]    pmp_addr_we;
718                     
719                         // Expanded / qualified register read data
720                         for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_exp_rd_data
721                           if (i < PMPNumRegions) begin : g_implemented_regions
722                             // Add in zero padding for reserved fields
723                             assign pmp_cfg_rdata[i] = {pmp_cfg[i].lock, 2'b00, pmp_cfg[i].mode,
724                                                        pmp_cfg[i].exec, pmp_cfg[i].write, pmp_cfg[i].read};
725                     
726                             // Address field read data depends on the current programmed mode and the granularity
727                             // See RISC-V Privileged Specification, version 1.11, Section 3.6.1
728                             if (PMPGranularity == 0) begin : g_pmp_g0
729                               // If G == 0, read data is unmodified
730                               assign pmp_addr_rdata[i] = pmp_addr[i];
731                     
732                             end else if (PMPGranularity == 1) begin : g_pmp_g1
733                               // If G == 1, bit [G-1] reads as zero in TOR or OFF mode
734                               always_comb begin
735                                 pmp_addr_rdata[i] = pmp_addr[i];
736                                 if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin
737                                   pmp_addr_rdata[i][PMPGranularity-1:0] = '0;
738                                 end
739                               end
740                     
741                             end else begin : g_pmp_g2
742                               // For G >= 2, bits are masked to one or zero depending on the mode
743                               always_comb begin
744                                 pmp_addr_rdata[i] = pmp_addr[i];
745                                 if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin
746                                   // In TOR or OFF mode, bits [G-1:0] must read as zero
747                                   pmp_addr_rdata[i][PMPGranularity-1:0] = '0;
748                                 end else if (pmp_cfg[i].mode == PMP_MODE_NAPOT) begin
749                                   // In NAPOT mode, bits [G-2:0] must read as one
750                                   pmp_addr_rdata[i][PMPGranularity-2:0] = '1;
751                                 end
752                               end
753                             end
754                     
755                           end else begin : g_other_regions
756                             // Non-implemented regions read as zero
757                             assign pmp_cfg_rdata[i]  = '0;
758                             assign pmp_addr_rdata[i] = '0;
759                           end
760                         end
761                     
762                         // Write data calculation
763                         for (genvar i = 0; i < PMPNumRegions; i++) begin : g_pmp_csrs
764                           // -------------------------
765                           // Instantiate cfg registers
766                           // -------------------------
767                           assign pmp_cfg_we[i] = csr_we_int & ~pmp_cfg[i].lock &
768                                                  (csr_addr == (CSR_OFF_PMP_CFG + (i[11:0] >> 2)));
769                     
770                           // Select the correct WDATA (each CSR contains 4 CFG fields, each with 2 RES bits)
771                           assign pmp_cfg_wdata[i].lock  = csr_wdata_int[(i%4)*PMP_CFG_W+7];
772                           // NA4 mode is not selectable when G > 0, mode is treated as OFF
773                           always_comb begin
774                             unique case (csr_wdata_int[(i%4)*PMP_CFG_W+3+:2])
775                               2'b00   : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;
776                               2'b01   : pmp_cfg_wdata[i].mode = PMP_MODE_TOR;
777                               2'b10   : pmp_cfg_wdata[i].mode = (PMPGranularity == 0) ? PMP_MODE_NA4:
778                                                                                         PMP_MODE_OFF;
779                               2'b11   : pmp_cfg_wdata[i].mode = PMP_MODE_NAPOT;
780                               default : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;
781                             endcase
782                           end
783                           assign pmp_cfg_wdata[i].exec  = csr_wdata_int[(i%4)*PMP_CFG_W+2];
784                           // W = 1, R = 0 is a reserved combination. For now, we force W to 0 if R == 0
785                           assign pmp_cfg_wdata[i].write = &csr_wdata_int[(i%4)*PMP_CFG_W+:2];
786                           assign pmp_cfg_wdata[i].read  = csr_wdata_int[(i%4)*PMP_CFG_W];
787                     
788                           always_ff @(posedge clk_i or negedge rst_ni) begin
789                             if (!rst_ni) begin
790                               pmp_cfg[i] <= pmp_cfg_t'('b0);
791                             end else if (pmp_cfg_we[i]) begin
792                               pmp_cfg[i] <= pmp_cfg_wdata[i];
793                             end
794                           end
795                     
796                           // --------------------------
797                           // Instantiate addr registers
798                           // --------------------------
799                           if (i < PMPNumRegions - 1) begin : g_lower
800                             assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg[i].lock &
801                                                     (pmp_cfg[i+1].mode != PMP_MODE_TOR) &
802                                                     (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));
803                           end else begin : g_upper
804                             assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg[i].lock &
805                                                     (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));
806                           end
807                     
808                           always_ff @(posedge clk_i or negedge rst_ni) begin
809                             if (!rst_ni) begin
810                               pmp_addr[i] <= 'b0;
811                             end else if (pmp_addr_we[i]) begin
812                               pmp_addr[i] <= csr_wdata_int;
813                             end
814                           end
815                           assign csr_pmp_cfg_o[i]  = pmp_cfg[i];
816                           assign csr_pmp_addr_o[i] = {pmp_addr[i],2'b00};
817                         end
818                     
819                       end else begin : g_no_pmp_tieoffs
820                         // Generate tieoffs when PMP is not configured
821                         for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_rdata
822                           assign pmp_addr_rdata[i] = '0;
823                           assign pmp_cfg_rdata[i]  = '0;
824                         end
825                         for (genvar i = 0; i < PMPNumRegions; i++) begin : g_outputs
826                           assign csr_pmp_cfg_o[i]  = pmp_cfg_t'(1'b0);
827                           assign csr_pmp_addr_o[i] = '0;
828                         end
829                       end
830                     
831                       //////////////////////////
832                       //  Performance monitor //
833                       //////////////////////////
834                     
835                       // update enable signals
836                       always_comb begin : mcountinhibit_update
837        1/1              if (mcountinhibit_we == 1'b1) begin
838        0/1     ==>        mcountinhibit_d = {csr_wdata_int[31:2], 1'b0, csr_wdata_int[0]}; // bit 1 must always be 0
839                         end else begin
840        1/1                mcountinhibit_d = mcountinhibit_q;
841                         end
842                       end
843                     
844                       assign mcountinhibit_force = {{29-MHPMCounterNum{1'b1}}, {MHPMCounterNum{1'b0}}, 3'b000};
845                       assign mcountinhibit       = mcountinhibit_q | mcountinhibit_force;
846                     
847                       // event selection (hardwired) & control
848                       always_comb begin : gen_mhpmcounter_incr
849                     
850                         // When adding or altering performance counter meanings and default
851                         // mappings please update dv/verilator/pcount/cpp/ibex_pcounts.cc
852                         // appropriately.
853                         //
854                         // active counters
855        1/1              mhpmcounter_incr[0]  = 1'b1;                   // mcycle
856        1/1              mhpmcounter_incr[1]  = 1'b0;                   // reserved
857        1/1              mhpmcounter_incr[2]  = instr_ret_i;            // minstret
858        1/1              mhpmcounter_incr[3]  = lsu_busy_i;             // cycles waiting for data memory
859        1/1              mhpmcounter_incr[4]  = imiss_i & ~pc_set_i;    // cycles waiting for instr fetches
860                                                                        // excl. jump and branch set cycles
861        1/1              mhpmcounter_incr[5]  = mem_load_i;             // num of loads
862        1/1              mhpmcounter_incr[6]  = mem_store_i;            // num of stores
863        1/1              mhpmcounter_incr[7]  = jump_i;                 // num of jumps (unconditional)
864        1/1              mhpmcounter_incr[8]  = branch_i;               // num of branches (conditional)
865        1/1              mhpmcounter_incr[9]  = branch_taken_i;         // num of taken branches (conditional)
866        1/1              mhpmcounter_incr[10] = instr_ret_compressed_i; // num of compressed instr
867                     
868                         // inactive counters
869        1/1              for (int unsigned i=3+MHPMCounterNum; i<32; i++) begin : gen_mhpmcounter_incr_inactive
870        1/1                mhpmcounter_incr[i] = 1'b0;
871                         end
872                       end
873                     
874                       // event selector (hardwired, 0 means no event)
875                       always_comb begin : gen_mhpmevent
876                     
877                         // activate all
878        1/1              for (int i=0; i<32; i++) begin : gen_mhpmevent_active
879        1/1                mhpmevent[i]    =   '0;
880        1/1                mhpmevent[i][i] = 1'b1;
881                         end
882                     
883                         // deactivate
884        1/1              mhpmevent[1] = '0; // not existing, reserved
885        1/1              for (int unsigned i=3+MHPMCounterNum; i<32; i++) begin : gen_mhpmevent_inactive
886        1/1                mhpmevent[i] = '0;
887                         end
888                       end
889                     
890                       // mask, controls effective counter width
891                       always_comb begin : gen_mask
892                     
893        1/1              for (int i=0; i<3; i++) begin : gen_mask_fixed
894                           // mcycle, mtime, minstret are always 64 bit wide
895        1/1                mhpmcounter_mask[i] = {64{1'b1}};
896                         end
897                     
898        1/1              for (int unsigned i=3; i<3+MHPMCounterNum; i++) begin : gen_mask_configurable
899                           // mhpmcounters have a configurable width
900        1/1                mhpmcounter_mask[i] = {{64-MHPMCounterWidth{1'b0}}, {MHPMCounterWidth{1'b1}}};
901                         end
902                     
903        1/1              for (int unsigned i=3+MHPMCounterNum; i<32; i++) begin : gen_mask_inactive
904                           // mask inactive mhpmcounters
905        1/1                mhpmcounter_mask[i] = '0;
906                         end
907                       end
908                     
909                       // update
910                       always_comb begin : mhpmcounter_update
911        1/1              mhpmcounter_d = mhpmcounter_q;
912                     
913        1/1              for (int i=0; i<32; i++) begin : gen_mhpmcounter_update
914                     
915                           // increment
916        1/1                if (mhpmcounter_incr[i] & ~mcountinhibit[i]) begin
917        1/1                  mhpmcounter_d[i] = mhpmcounter_mask[i] & (mhpmcounter_q[i] + 64'h1);
918                           end
                        MISSING_ELSE
919                     
920                           // write
921        1/1                if (mhpmcounter_we[i]) begin
922        0/1     ==>          mhpmcounter_d[i][31: 0] = mhpmcounter_mask[i][31: 0] & csr_wdata_int;
923        1/1                end else if (mhpmcounterh_we[i]) begin
924        1/1                  mhpmcounter_d[i][63:32] = mhpmcounter_mask[i][63:32] & csr_wdata_int;
925                           end
                        MISSING_ELSE
926                         end
927                       end
928                     
929                       // performance monitor registers
930                       always_ff @(posedge clk_i or negedge rst_ni) begin : perf_counter_registers
931        1/1              if (!rst_ni) begin
932        1/1                mcountinhibit_q    <= '0;
933        1/1                for (int i=0; i<32; i++) begin
934        1/1                  mhpmcounter_q[i] <= '0;
935                           end
936                         end else begin
937        1/1                mhpmcounter_q      <= mhpmcounter_d;
938        1/1                mcountinhibit_q    <= mcountinhibit_d;

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_cs_registers
         Line No. Total Covered Percent 
Branches          88    81      92.05   
TERNARY  706      2     1       50.00   
CASE     248      45    45      100.00  
TERNARY  422      2     2       100.00  
IF       436      18    14      77.78   
CASE     537      10    9       90.00   
CASE     607      5     5       100.00  
IF       647      2     2       100.00  
IF       837      2     1       50.00   
IF       931      2     2       100.00  


706          assign priv_mode_lsu_o = mstatus_q.mprv ? mstatus_q.mpp : priv_lvl_q;
                                                     -1-  
                                                     ==>  
                                                     ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


248            unique case (csr_addr_i)
                      -1-  
249              // mhartid: unique hardware thread id
250              CSR_MHARTID: csr_rdata_int = hart_id_i;
                 ==>
251        
252              // mstatus: always M-mode, contains IE bit
253              CSR_MSTATUS: begin
254                csr_rdata_int                                                   = '0;
                   ==>
255                csr_rdata_int[CSR_MSTATUS_MIE_BIT]                              = mstatus_q.mie;
256                csr_rdata_int[CSR_MSTATUS_MPIE_BIT]                             = mstatus_q.mpie;
257                csr_rdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW] = mstatus_q.mpp;
258                csr_rdata_int[CSR_MSTATUS_MPRV_BIT]                             = mstatus_q.mprv;
259                csr_rdata_int[CSR_MSTATUS_TW_BIT]                               = mstatus_q.tw;
260              end
261        
262              // misa
263              CSR_MISA: csr_rdata_int = MISA_VALUE;
                 ==>
264        
265              // interrupt enable
266              CSR_MIE: begin
267                csr_rdata_int                                     = '0;
                   ==>
268                csr_rdata_int[CSR_MSIX_BIT]                       = mie_q.irq_software;
269                csr_rdata_int[CSR_MTIX_BIT]                       = mie_q.irq_timer;
270                csr_rdata_int[CSR_MEIX_BIT]                       = mie_q.irq_external;
271                csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mie_q.irq_fast;
272              end
273        
274              CSR_MSCRATCH: csr_rdata_int = mscratch_q;
                 ==>
275        
276              // mtvec: trap-vector base address
277              CSR_MTVEC: csr_rdata_int = mtvec_q;
                 ==>
278        
279              // mepc: exception program counter
280              CSR_MEPC: csr_rdata_int = mepc_q;
                 ==>
281        
282              // mcause: exception cause
283              CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};
                 ==>
284        
285              // mtval: trap value
286              CSR_MTVAL: csr_rdata_int = mtval_q;
                 ==>
287        
288              // mip: interrupt pending
289              CSR_MIP: begin
290                csr_rdata_int                                     = '0;
                   ==>
291                csr_rdata_int[CSR_MSIX_BIT]                       = mip.irq_software;
292                csr_rdata_int[CSR_MTIX_BIT]                       = mip.irq_timer;
293                csr_rdata_int[CSR_MEIX_BIT]                       = mip.irq_external;
294                csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mip.irq_fast;
295              end
296        
297              // PMP registers
298              CSR_PMPCFG0:   csr_rdata_int = {pmp_cfg_rdata[3],  pmp_cfg_rdata[2],
                 ==>
299                                              pmp_cfg_rdata[1],  pmp_cfg_rdata[0]};
300              CSR_PMPCFG1:   csr_rdata_int = {pmp_cfg_rdata[7],  pmp_cfg_rdata[6],
                 ==>
301                                              pmp_cfg_rdata[5],  pmp_cfg_rdata[4]};
302              CSR_PMPCFG2:   csr_rdata_int = {pmp_cfg_rdata[11], pmp_cfg_rdata[10],
                 ==>
303                                              pmp_cfg_rdata[9],  pmp_cfg_rdata[8]};
304              CSR_PMPCFG3:   csr_rdata_int = {pmp_cfg_rdata[15], pmp_cfg_rdata[14],
                 ==>
305                                              pmp_cfg_rdata[13], pmp_cfg_rdata[12]};
306              CSR_PMPADDR0:  csr_rdata_int = pmp_addr_rdata[0];
                 ==>
307              CSR_PMPADDR1:  csr_rdata_int = pmp_addr_rdata[1];
                 ==>
308              CSR_PMPADDR2:  csr_rdata_int = pmp_addr_rdata[2];
                 ==>
309              CSR_PMPADDR3:  csr_rdata_int = pmp_addr_rdata[3];
                 ==>
310              CSR_PMPADDR4:  csr_rdata_int = pmp_addr_rdata[4];
                 ==>
311              CSR_PMPADDR5:  csr_rdata_int = pmp_addr_rdata[5];
                 ==>
312              CSR_PMPADDR6:  csr_rdata_int = pmp_addr_rdata[6];
                 ==>
313              CSR_PMPADDR7:  csr_rdata_int = pmp_addr_rdata[7];
                 ==>
314              CSR_PMPADDR8:  csr_rdata_int = pmp_addr_rdata[8];
                 ==>
315              CSR_PMPADDR9:  csr_rdata_int = pmp_addr_rdata[9];
                 ==>
316              CSR_PMPADDR10: csr_rdata_int = pmp_addr_rdata[10];
                 ==>
317              CSR_PMPADDR11: csr_rdata_int = pmp_addr_rdata[11];
                 ==>
318              CSR_PMPADDR12: csr_rdata_int = pmp_addr_rdata[12];
                 ==>
319              CSR_PMPADDR13: csr_rdata_int = pmp_addr_rdata[13];
                 ==>
320              CSR_PMPADDR14: csr_rdata_int = pmp_addr_rdata[14];
                 ==>
321              CSR_PMPADDR15: csr_rdata_int = pmp_addr_rdata[15];
                 ==>
322        
323              CSR_DCSR: begin
324                csr_rdata_int = dcsr_q;
                   ==>
325                illegal_csr = ~debug_mode_i;
326              end
327              CSR_DPC: begin
328                csr_rdata_int = depc_q;
                   ==>
329                illegal_csr = ~debug_mode_i;
330              end
331              CSR_DSCRATCH0: begin
332                csr_rdata_int = dscratch0_q;
                   ==>
333                illegal_csr = ~debug_mode_i;
334              end
335              CSR_DSCRATCH1: begin
336                csr_rdata_int = dscratch1_q;
                   ==>
337                illegal_csr = ~debug_mode_i;
338              end
339        
340              // machine counter/timers
341              CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit;
                 ==>
342              CSR_MHPMEVENT3,
343              CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,
344              CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,
345              CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,
346              CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,
347              CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,
348              CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,
349              CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31: begin
350                csr_rdata_int = mhpmevent[mhpmcounter_idx];
                   ==>
351              end
352        
353              CSR_MCYCLE,
354              CSR_MINSTRET,
355              CSR_MHPMCOUNTER3,
356              CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
357              CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
358              CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
359              CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
360              CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
361              CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
362              CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
363                csr_rdata_int = mhpmcounter_q[mhpmcounter_idx][31:0];
                   ==>
364              end
365        
366              CSR_MCYCLEH,
367              CSR_MINSTRETH,
368              CSR_MHPMCOUNTER3H,
369              CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
370              CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
371              CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
372              CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
373              CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
374              CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
375              CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
376                csr_rdata_int = mhpmcounter_q[mhpmcounter_idx][63:32];
                   ==>
377              end
378        
379              // Debug triggers
380              CSR_TSELECT: begin
381                csr_rdata_int = tselect_rdata;
                   ==>
382                illegal_csr   = ~DbgTriggerEn;
383              end
384              CSR_TDATA1: begin
385                csr_rdata_int = tmatch_control_rdata;
                   ==>
386                illegal_csr   = ~DbgTriggerEn;
387              end
388              CSR_TDATA2: begin
389                csr_rdata_int = tmatch_value_rdata;
                   ==>
390                illegal_csr   = ~DbgTriggerEn;
391              end
392              CSR_TDATA3: begin
393                csr_rdata_int = '0;
                   ==>
394                illegal_csr   = ~DbgTriggerEn;
395              end
396              CSR_MCONTEXT: begin
397                csr_rdata_int = '0;
                   ==>
398                illegal_csr   = ~DbgTriggerEn;
399              end
400              CSR_SCONTEXT: begin
401                csr_rdata_int = '0;
                   ==>
402                illegal_csr   = ~DbgTriggerEn;
403              end
404        
405              default: begin
406                illegal_csr = 1'b1;
                   ==>

Branches:

-1-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Status  
CSR_MHARTID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_MSTATUS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_MISA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Covered 
CSR_MIE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Covered 
CSR_MSCRATCH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_MTVEC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Covered 
CSR_MEPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Covered 
CSR_MCAUSE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Covered 
CSR_MTVAL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Covered 
CSR_MIP                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Covered 
CSR_PMPCFG0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_PMPCFG1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_PMPCFG2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_PMPCFG3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_PMPADDR0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR9                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR10                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR11                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR12                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR13                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR14                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR15                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_DCSR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Covered 
CSR_DPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Covered 
CSR_DSCRATCH0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_DSCRATCH1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_MCOUNTINHIBIT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Covered 
CASEITEM-36: CSR_MHPMEVENT3 CSR_MHPMEVENT4 CSR_MHPMEVENT5 CSR_MHPMEVENT6 CSR_MHPMEVENT7 CSR_MHPMEVENT8 CSR_MHPMEVENT9 CSR_MHPMEVENT10 CSR_MHPMEVENT11 CSR_MHPMEVENT12 CSR_MHPMEVENT13 CSR_MHPMEVENT14 CSR_MHPMEVENT15 CSR_MHPMEVENT16 CSR_MHPMEVENT17 CSR_MHPMEVENT18 CSR_MHPMEVENT19 CSR_MHPMEVENT20 CSR_MHPMEVENT21 CSR_MHPMEVENT22 CSR_MHPMEVENT23 CSR_MHPMEVENT24 CSR_MHPMEVENT25 CSR_MHPMEVENT26 CSR_MHPMEVENT27 CSR_MHPMEVENT28 CSR_MHPMEVENT29 CSR_MHPMEVENT30 CSR_MHPMEVENT31                                                                                                                   Covered 
CASEITEM-37: CSR_MCYCLE CSR_MINSTRET CSR_MHPMCOUNTER3 CSR_MHPMCOUNTER4 CSR_MHPMCOUNTER5 CSR_MHPMCOUNTER6 CSR_MHPMCOUNTER7 CSR_MHPMCOUNTER8 CSR_MHPMCOUNTER9 CSR_MHPMCOUNTER10 CSR_MHPMCOUNTER11 CSR_MHPMCOUNTER12 CSR_MHPMCOUNTER13 CSR_MHPMCOUNTER14 CSR_MHPMCOUNTER15 CSR_MHPMCOUNTER16 CSR_MHPMCOUNTER17 CSR_MHPMCOUNTER18 CSR_MHPMCOUNTER19 CSR_MHPMCOUNTER20 CSR_MHPMCOUNTER21 CSR_MHPMCOUNTER22 CSR_MHPMCOUNTER23 CSR_MHPMCOUNTER24 CSR_MHPMCOUNTER25 CSR_MHPMCOUNTER26 CSR_MHPMCOUNTER27 CSR_MHPMCOUNTER28 CSR_MHPMCOUNTER29 CSR_MHPMCOUNTER30 CSR_MHPMCOUNTER31                                 Covered 
CASEITEM-38: CSR_MCYCLEH CSR_MINSTRETH CSR_MHPMCOUNTER3H CSR_MHPMCOUNTER4H CSR_MHPMCOUNTER5H CSR_MHPMCOUNTER6H CSR_MHPMCOUNTER7H CSR_MHPMCOUNTER8H CSR_MHPMCOUNTER9H CSR_MHPMCOUNTER10H CSR_MHPMCOUNTER11H CSR_MHPMCOUNTER12H CSR_MHPMCOUNTER13H CSR_MHPMCOUNTER14H CSR_MHPMCOUNTER15H CSR_MHPMCOUNTER16H CSR_MHPMCOUNTER17H CSR_MHPMCOUNTER18H CSR_MHPMCOUNTER19H CSR_MHPMCOUNTER20H CSR_MHPMCOUNTER21H CSR_MHPMCOUNTER22H CSR_MHPMCOUNTER23H CSR_MHPMCOUNTER24H CSR_MHPMCOUNTER25H CSR_MHPMCOUNTER26H CSR_MHPMCOUNTER27H CSR_MHPMCOUNTER28H CSR_MHPMCOUNTER29H CSR_MHPMCOUNTER30H CSR_MHPMCOUNTER31H  Covered 
CSR_TSELECT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_TDATA1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Covered 
CSR_TDATA2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Covered 
CSR_TDATA3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Covered 
CSR_MCONTEXT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_SCONTEXT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
default                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Covered 


422            mtvec_d      = csr_mtvec_init_i ? {boot_addr_i[31:8], 6'b0, 2'b01} : mtvec_q;
                                               -1-  
                                               ==>  
                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


436            if (csr_we_int) begin
               -1-  
437              unique case (csr_addr_i)
                        -2-  
438                // mstatus: IE bit
439                CSR_MSTATUS: begin
440                  mstatus_d = '{
441                      mie:  csr_wdata_int[CSR_MSTATUS_MIE_BIT],
442                      mpie: csr_wdata_int[CSR_MSTATUS_MPIE_BIT],
443                      mpp:  priv_lvl_e'(csr_wdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW]),
444                      mprv: csr_wdata_int[CSR_MSTATUS_MPRV_BIT],
445                      tw:   csr_wdata_int[CSR_MSTATUS_TW_BIT]
446                  };
447                  // Convert illegal values to M-mode
448                  if ((mstatus_d.mpp != PRIV_LVL_M) && (mstatus_d.mpp != PRIV_LVL_U)) begin
                     -3-  
449                    mstatus_d.mpp = PRIV_LVL_M;
                       ==>
450                  end
                     MISSING_ELSE
                     ==>
451                end
452        
453                // interrupt enable
454                CSR_MIE: begin
455                  mie_d.irq_software = csr_wdata_int[CSR_MSIX_BIT];
                     ==>
456                  mie_d.irq_timer    = csr_wdata_int[CSR_MTIX_BIT];
457                  mie_d.irq_external = csr_wdata_int[CSR_MEIX_BIT];
458                  mie_d.irq_fast     = csr_wdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW];
459                end
460        
461                CSR_MSCRATCH: mscratch_d = csr_wdata_int;
                   ==>
462        
463                // mepc: exception program counter
464                CSR_MEPC: mepc_d = {csr_wdata_int[31:1], 1'b0};
                   ==>
465        
466                // mcause
467                CSR_MCAUSE: mcause_d = {csr_wdata_int[31], csr_wdata_int[4:0]};
                   ==>
468        
469                // mtval: trap value
470                CSR_MTVAL: mtval_d = csr_wdata_int;
                   ==>
471        
472                // mtvec
473                // mtvec.MODE set to vectored
474                // mtvec.BASE must be 256-byte aligned
475                CSR_MTVEC: mtvec_d = {csr_wdata_int[31:8], 6'b0, 2'b01};
                   ==>
476        
477                CSR_DCSR: begin
478                  dcsr_d = csr_wdata_int;
479                  dcsr_d.xdebugver = XDEBUGVER_STD;
480                  // Change to PRIV_LVL_M if software writes an unsupported value
481                  if ((dcsr_d.prv != PRIV_LVL_M) && (dcsr_d.prv != PRIV_LVL_U)) begin
                     -4-  
482                    dcsr_d.prv = PRIV_LVL_M;
                       ==>
483                  end
                     MISSING_ELSE
                     ==>
484        
485                  // currently not supported:
486                  dcsr_d.nmip = 1'b0;
487                  dcsr_d.mprven = 1'b0;
488                  dcsr_d.stopcount = 1'b0;
489                  dcsr_d.stoptime = 1'b0;
490        
491                  // forced to be zero
492                  dcsr_d.zero0 = 1'b0;
493                  dcsr_d.zero1 = 1'b0;
494                  dcsr_d.zero2 = 12'h0;
495                end
496        
497                // dpc: debug program counter
498                CSR_DPC: depc_d = {csr_wdata_int[31:1], 1'b0};
                   ==>
499        
500                CSR_DSCRATCH0: dscratch0_d = csr_wdata_int;
                   ==>
501                CSR_DSCRATCH1: dscratch1_d = csr_wdata_int;
                   ==>
502        
503                // machine counter/timers
504                CSR_MCOUNTINHIBIT: mcountinhibit_we = 1'b1;
                   ==>
505        
506                CSR_MCYCLE,
507                CSR_MINSTRET,
508                CSR_MHPMCOUNTER3,
509                CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
510                CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
511                CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
512                CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
513                CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
514                CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
515                CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
516                  mhpmcounter_we[mhpmcounter_idx] = 1'b1;
                     ==>
517                end
518        
519                CSR_MCYCLEH,
520                CSR_MINSTRETH,
521                CSR_MHPMCOUNTER3H,
522                CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
523                CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
524                CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
525                CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
526                CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
527                CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
528                CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
529                  mhpmcounterh_we[mhpmcounter_idx] = 1'b1;
                     ==>
530                end
531        
532                default:;
                   ==>
533              endcase
534            end
               MISSING_ELSE
               ==>

Branches:

-1- -2-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -3- -4- Status      
1   CSR_MSTATUS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1   -   Not Covered 
1   CSR_MSTATUS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             0   -   Covered     
1   CSR_MIE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Covered     
1   CSR_MSCRATCH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Covered     
1   CSR_MEPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   -   Covered     
1   CSR_MCAUSE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -   -   Covered     
1   CSR_MTVAL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -   -   Covered     
1   CSR_MTVEC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -   -   Covered     
1   CSR_DCSR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   1   Not Covered 
1   CSR_DCSR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   0   Covered     
1   CSR_DPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Covered     
1   CSR_DSCRATCH0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Covered     
1   CSR_DSCRATCH1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Covered     
1   CSR_MCOUNTINHIBIT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -   -   Not Covered 
1   CASEITEM-13: CSR_MCYCLE CSR_MINSTRET CSR_MHPMCOUNTER3 CSR_MHPMCOUNTER4 CSR_MHPMCOUNTER5 CSR_MHPMCOUNTER6 CSR_MHPMCOUNTER7 CSR_MHPMCOUNTER8 CSR_MHPMCOUNTER9 CSR_MHPMCOUNTER10 CSR_MHPMCOUNTER11 CSR_MHPMCOUNTER12 CSR_MHPMCOUNTER13 CSR_MHPMCOUNTER14 CSR_MHPMCOUNTER15 CSR_MHPMCOUNTER16 CSR_MHPMCOUNTER17 CSR_MHPMCOUNTER18 CSR_MHPMCOUNTER19 CSR_MHPMCOUNTER20 CSR_MHPMCOUNTER21 CSR_MHPMCOUNTER22 CSR_MHPMCOUNTER23 CSR_MHPMCOUNTER24 CSR_MHPMCOUNTER25 CSR_MHPMCOUNTER26 CSR_MHPMCOUNTER27 CSR_MHPMCOUNTER28 CSR_MHPMCOUNTER29 CSR_MHPMCOUNTER30 CSR_MHPMCOUNTER31                                 -   -   Not Covered 
1   CASEITEM-14: CSR_MCYCLEH CSR_MINSTRETH CSR_MHPMCOUNTER3H CSR_MHPMCOUNTER4H CSR_MHPMCOUNTER5H CSR_MHPMCOUNTER6H CSR_MHPMCOUNTER7H CSR_MHPMCOUNTER8H CSR_MHPMCOUNTER9H CSR_MHPMCOUNTER10H CSR_MHPMCOUNTER11H CSR_MHPMCOUNTER12H CSR_MHPMCOUNTER13H CSR_MHPMCOUNTER14H CSR_MHPMCOUNTER15H CSR_MHPMCOUNTER16H CSR_MHPMCOUNTER17H CSR_MHPMCOUNTER18H CSR_MHPMCOUNTER19H CSR_MHPMCOUNTER20H CSR_MHPMCOUNTER21H CSR_MHPMCOUNTER22H CSR_MHPMCOUNTER23H CSR_MHPMCOUNTER24H CSR_MHPMCOUNTER25H CSR_MHPMCOUNTER26H CSR_MHPMCOUNTER27H CSR_MHPMCOUNTER28H CSR_MHPMCOUNTER29H CSR_MHPMCOUNTER30H CSR_MHPMCOUNTER31H  -   -   Covered     
1   default                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Covered     
0   -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -   -   Covered     


537            unique case (1'b1)
                      -1-  
538        
539              csr_save_cause_i: begin
540                unique case (1'b1)
                          -2-  
541                  csr_save_if_i: begin
542                    exception_pc = pc_if_i;
                       ==>
543                  end
544                  csr_save_id_i: begin
545                    exception_pc = pc_id_i;
                       ==>
546                  end
547                  default:;
                     ==>
548                endcase
549        
550                // Any exception, including debug mode, causes a switch to M-mode
551                priv_lvl_d = PRIV_LVL_M;
552        
553                if (debug_csr_save_i) begin
                   -3-  
554                  // all interrupts are masked
555                  // do not update cause, epc, tval, epc and status
556                  dcsr_d.prv   = priv_lvl_q;
                     ==>
557                  dcsr_d.cause = debug_cause_i;
558                  depc_d       = exception_pc;
559                end else if (!debug_mode_i) begin
                            -4-  
560                  // In debug mode, "exceptions do not update any registers. That
561                  // includes cause, epc, tval, dpc and mstatus." [Debug Spec v0.13.2, p.39]
562                  mtval_d        = csr_mtval_i;
                     ==>
563                  mstatus_d.mie  = 1'b0; // disable interrupts
564                  // save current status
565                  mstatus_d.mpie = mstatus_q.mie;
566                  mstatus_d.mpp  = priv_lvl_q;
567                  mepc_d         = exception_pc;
568                  mcause_d       = {csr_mcause_i};
569                  // save previous status for recoverable NMI
570                  mstack_d.mpie  = mstatus_q.mpie;
571                  mstack_d.mpp   = mstatus_q.mpp;
572                  mstack_epc_d   = mepc_q;
573                  mstack_cause_d = mcause_q;
574                end
                   MISSING_ELSE
                   ==>
575              end // csr_save_cause_i
576        
577              csr_restore_dret_i: begin // DRET
578                priv_lvl_d = dcsr_q.prv;
                   ==>
579              end // csr_restore_dret_i
580        
581              csr_restore_mret_i: begin // MRET
582                priv_lvl_d     = mstatus_q.mpp;
583                mstatus_d.mie  = mstatus_q.mpie; // re-enable interrupts
584        
585                if (nmi_mode_i) begin
                   -5-  
586                  // when returning from an NMI restore state from mstack CSR
587                  mstatus_d.mpie = mstack_q.mpie;
                     ==>
588                  mstatus_d.mpp  = mstack_q.mpp;
589                  mepc_d         = mstack_epc_q;
590                  mcause_d       = mstack_cause_q;
591                end else begin
592                  // otherwise just set mstatus.MPIE/MPP
593                  // See RISC-V Privileged Specification, version 1.11, Section 3.1.6.1
594                  mstatus_d.mpie = 1'b1;
                     ==>
595                  mstatus_d.mpp  = PRIV_LVL_U;
596                end
597              end // csr_restore_mret_i
598        
599              default:;
                 ==>

Branches:

-1-                 -2-            -3- -4- -5- Status      
csr_save_cause_i    csr_save_if_i  -   -   -   Covered     
csr_save_cause_i    csr_save_id_i  -   -   -   Covered     
csr_save_cause_i    default        -   -   -   Not Covered 
csr_save_cause_i    -              1   -   -   Covered     
csr_save_cause_i    -              0   1   -   Covered     
csr_save_cause_i    -              0   0   -   Covered     
csr_restore_dret_i  -              -   -   -   Covered     
csr_restore_mret_i  -              -   -   1   Covered     
csr_restore_mret_i  -              -   -   0   Covered     
default             -              -   -   -   Covered     


607            unique case (csr_op_i)
                      -1-  
608              CSR_OP_WRITE: csr_wdata_int =  csr_wdata_i;
                 ==>
609              CSR_OP_SET:   csr_wdata_int =  csr_wdata_i | csr_rdata_o;
                 ==>
610              CSR_OP_CLEAR: csr_wdata_int = ~csr_wdata_i & csr_rdata_o;
                 ==>
611              CSR_OP_READ: begin
612                csr_wdata_int = csr_wdata_i;
                   ==>
613                csr_wreq      = 1'b0;
614              end
615              default: begin
616                csr_wdata_int = csr_wdata_i;
                   ==>

Branches:

-1-           Status  
CSR_OP_WRITE  Covered 
CSR_OP_SET    Covered 
CSR_OP_CLEAR  Covered 
CSR_OP_READ   Covered 
default       Covered 


647            if (!rst_ni) begin
               -1-  
648              priv_lvl_q     <= PRIV_LVL_M;
                 ==>
649              mstatus_q      <= '{
650                  mie:  1'b0,
651                  mpie: 1'b1,
652                  mpp:  PRIV_LVL_U,
653                  mprv: 1'b0,
654                  tw:   1'b0
655              };
656              mie_q          <= '0;
657              mscratch_q     <= '0;
658              mepc_q         <= '0;
659              mcause_q       <= '0;
660              mtval_q        <= '0;
661              mtvec_q        <= 32'b01;
662              dcsr_q         <= '{
663                  xdebugver: XDEBUGVER_STD,
664                  cause:     DBG_CAUSE_NONE, // 3'h0
665                  prv:       PRIV_LVL_M,
666                  default:   '0
667              };
668              depc_q         <= '0;
669              dscratch0_q    <= '0;
670              dscratch1_q    <= '0;
671        
672              mstack_q       <= '{
673                  mpie: 1'b1,
674                  mpp:  PRIV_LVL_U
675              };
676              mstack_epc_q   <= '0;
677              mstack_cause_q <= '0;
678        
679            end else begin
680              // update CSRs
681              priv_lvl_q     <= priv_lvl_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


837            if (mcountinhibit_we == 1'b1) begin
               -1-  
838              mcountinhibit_d = {csr_wdata_int[31:2], 1'b0, csr_wdata_int[0]}; // bit 1 must always be 0
                 ==>
839            end else begin
840              mcountinhibit_d = mcountinhibit_q;
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


931            if (!rst_ni) begin
               -1-  
932              mcountinhibit_q    <= '0;
                 ==>
933              for (int i=0; i<32; i++) begin
934                mhpmcounter_q[i] <= '0;
935              end
936            end else begin
937              mhpmcounter_q      <= mhpmcounter_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.cs_registers_i(x)
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 94.75  97.45 --     --      92.05 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 94.75  97.45 --     --      92.05 --     


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME              
 94.54  97.03 --     --      92.05 --     ibex_cs_registers 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME        
 98.10  99.07 --     --      97.14 --     u_ibex_core 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.cs_registers_i(x)

             Line No.   Total   Covered  Percent
TOTAL                      235      229    97.45
ALWAYS            245       71       71   100.00
ALWAYS            413       82       78    95.12
ALWAYS            605        9        9   100.00
ALWAYS            647       31       31   100.00
ALWAYS            837        3        2    66.67
ALWAYS            855       13       13   100.00
ALWAYS            878        0        0
ALWAYS            878        6        6   100.00
ALWAYS            893        0        0
ALWAYS            893        6        6   100.00
ALWAYS            911        8        7    87.50
ALWAYS            931        6        6   100.00

244                       always_comb begin
245        1/1              csr_rdata_int = '0;
246        1/1              illegal_csr   = 1'b0;
247                     
248        1/1              unique case (csr_addr_i)
249                           // mhartid: unique hardware thread id
250        1/1                CSR_MHARTID: csr_rdata_int = hart_id_i;
251                     
252                           // mstatus: always M-mode, contains IE bit
253                           CSR_MSTATUS: begin
254        1/1                  csr_rdata_int                                                   = '0;
255        1/1                  csr_rdata_int[CSR_MSTATUS_MIE_BIT]                              = mstatus_q.mie;
256        1/1                  csr_rdata_int[CSR_MSTATUS_MPIE_BIT]                             = mstatus_q.mpie;
257        1/1                  csr_rdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW] = mstatus_q.mpp;
258        1/1                  csr_rdata_int[CSR_MSTATUS_MPRV_BIT]                             = mstatus_q.mprv;
259        1/1                  csr_rdata_int[CSR_MSTATUS_TW_BIT]                               = mstatus_q.tw;
260                           end
261                     
262                           // misa
263        1/1                CSR_MISA: csr_rdata_int = MISA_VALUE;
264                     
265                           // interrupt enable
266                           CSR_MIE: begin
267        1/1                  csr_rdata_int                                     = '0;
268        1/1                  csr_rdata_int[CSR_MSIX_BIT]                       = mie_q.irq_software;
269        1/1                  csr_rdata_int[CSR_MTIX_BIT]                       = mie_q.irq_timer;
270        1/1                  csr_rdata_int[CSR_MEIX_BIT]                       = mie_q.irq_external;
271        1/1                  csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mie_q.irq_fast;
272                           end
273                     
274        1/1                CSR_MSCRATCH: csr_rdata_int = mscratch_q;
275                     
276                           // mtvec: trap-vector base address
277        1/1                CSR_MTVEC: csr_rdata_int = mtvec_q;
278                     
279                           // mepc: exception program counter
280        1/1                CSR_MEPC: csr_rdata_int = mepc_q;
281                     
282                           // mcause: exception cause
283        1/1                CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};
284                     
285                           // mtval: trap value
286        1/1                CSR_MTVAL: csr_rdata_int = mtval_q;
287                     
288                           // mip: interrupt pending
289                           CSR_MIP: begin
290        1/1                  csr_rdata_int                                     = '0;
291        1/1                  csr_rdata_int[CSR_MSIX_BIT]                       = mip.irq_software;
292        1/1                  csr_rdata_int[CSR_MTIX_BIT]                       = mip.irq_timer;
293        1/1                  csr_rdata_int[CSR_MEIX_BIT]                       = mip.irq_external;
294        1/1                  csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mip.irq_fast;
295                           end
296                     
297                           // PMP registers
298        1/1                CSR_PMPCFG0:   csr_rdata_int = {pmp_cfg_rdata[3],  pmp_cfg_rdata[2],
299                                                           pmp_cfg_rdata[1],  pmp_cfg_rdata[0]};
300        1/1                CSR_PMPCFG1:   csr_rdata_int = {pmp_cfg_rdata[7],  pmp_cfg_rdata[6],
301                                                           pmp_cfg_rdata[5],  pmp_cfg_rdata[4]};
302        1/1                CSR_PMPCFG2:   csr_rdata_int = {pmp_cfg_rdata[11], pmp_cfg_rdata[10],
303                                                           pmp_cfg_rdata[9],  pmp_cfg_rdata[8]};
304        1/1                CSR_PMPCFG3:   csr_rdata_int = {pmp_cfg_rdata[15], pmp_cfg_rdata[14],
305                                                           pmp_cfg_rdata[13], pmp_cfg_rdata[12]};
306        1/1                CSR_PMPADDR0:  csr_rdata_int = pmp_addr_rdata[0];
307        1/1                CSR_PMPADDR1:  csr_rdata_int = pmp_addr_rdata[1];
308        1/1                CSR_PMPADDR2:  csr_rdata_int = pmp_addr_rdata[2];
309        1/1                CSR_PMPADDR3:  csr_rdata_int = pmp_addr_rdata[3];
310        1/1                CSR_PMPADDR4:  csr_rdata_int = pmp_addr_rdata[4];
311        1/1                CSR_PMPADDR5:  csr_rdata_int = pmp_addr_rdata[5];
312        1/1                CSR_PMPADDR6:  csr_rdata_int = pmp_addr_rdata[6];
313        1/1                CSR_PMPADDR7:  csr_rdata_int = pmp_addr_rdata[7];
314        1/1                CSR_PMPADDR8:  csr_rdata_int = pmp_addr_rdata[8];
315        1/1                CSR_PMPADDR9:  csr_rdata_int = pmp_addr_rdata[9];
316        1/1                CSR_PMPADDR10: csr_rdata_int = pmp_addr_rdata[10];
317        1/1                CSR_PMPADDR11: csr_rdata_int = pmp_addr_rdata[11];
318        1/1                CSR_PMPADDR12: csr_rdata_int = pmp_addr_rdata[12];
319        1/1                CSR_PMPADDR13: csr_rdata_int = pmp_addr_rdata[13];
320        1/1                CSR_PMPADDR14: csr_rdata_int = pmp_addr_rdata[14];
321        1/1                CSR_PMPADDR15: csr_rdata_int = pmp_addr_rdata[15];
322                     
323                           CSR_DCSR: begin
324        1/1                  csr_rdata_int = dcsr_q;
325        1/1                  illegal_csr = ~debug_mode_i;
326                           end
327                           CSR_DPC: begin
328        1/1                  csr_rdata_int = depc_q;
329        1/1                  illegal_csr = ~debug_mode_i;
330                           end
331                           CSR_DSCRATCH0: begin
332        1/1                  csr_rdata_int = dscratch0_q;
333        1/1                  illegal_csr = ~debug_mode_i;
334                           end
335                           CSR_DSCRATCH1: begin
336        1/1                  csr_rdata_int = dscratch1_q;
337        1/1                  illegal_csr = ~debug_mode_i;
338                           end
339                     
340                           // machine counter/timers
341        1/1                CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit;
342                           CSR_MHPMEVENT3,
343                           CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,
344                           CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,
345                           CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,
346                           CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,
347                           CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,
348                           CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,
349                           CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31: begin
350        1/1                  csr_rdata_int = mhpmevent[mhpmcounter_idx];
351                           end
352                     
353                           CSR_MCYCLE,
354                           CSR_MINSTRET,
355                           CSR_MHPMCOUNTER3,
356                           CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
357                           CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
358                           CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
359                           CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
360                           CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
361                           CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
362                           CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
363        1/1                  csr_rdata_int = mhpmcounter_q[mhpmcounter_idx][31:0];
364                           end
365                     
366                           CSR_MCYCLEH,
367                           CSR_MINSTRETH,
368                           CSR_MHPMCOUNTER3H,
369                           CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
370                           CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
371                           CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
372                           CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
373                           CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
374                           CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
375                           CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
376        1/1                  csr_rdata_int = mhpmcounter_q[mhpmcounter_idx][63:32];
377                           end
378                     
379                           // Debug triggers
380                           CSR_TSELECT: begin
381        1/1                  csr_rdata_int = tselect_rdata;
382        1/1                  illegal_csr   = ~DbgTriggerEn;
383                           end
384                           CSR_TDATA1: begin
385        1/1                  csr_rdata_int = tmatch_control_rdata;
386        1/1                  illegal_csr   = ~DbgTriggerEn;
387                           end
388                           CSR_TDATA2: begin
389        1/1                  csr_rdata_int = tmatch_value_rdata;
390        1/1                  illegal_csr   = ~DbgTriggerEn;
391                           end
392                           CSR_TDATA3: begin
393        1/1                  csr_rdata_int = '0;
394        1/1                  illegal_csr   = ~DbgTriggerEn;
395                           end
396                           CSR_MCONTEXT: begin
397        1/1                  csr_rdata_int = '0;
398        1/1                  illegal_csr   = ~DbgTriggerEn;
399                           end
400                           CSR_SCONTEXT: begin
401        1/1                  csr_rdata_int = '0;
402        1/1                  illegal_csr   = ~DbgTriggerEn;
403                           end
404                     
405                           default: begin
406        1/1                  illegal_csr = 1'b1;
407                           end
408                         endcase
409                       end
410                     
411                       // write logic
412                       always_comb begin
413        1/1              exception_pc = pc_id_i;
414                     
415        1/1              priv_lvl_d   = priv_lvl_q;
416        1/1              mstatus_d    = mstatus_q;
417        1/1              mie_d        = mie_q;
418        1/1              mscratch_d   = mscratch_q;
419        1/1              mepc_d       = mepc_q;
420        1/1              mcause_d     = mcause_q;
421        1/1              mtval_d      = mtval_q;
422        1/1              mtvec_d      = csr_mtvec_init_i ? {boot_addr_i[31:8], 6'b0, 2'b01} : mtvec_q;
423        1/1              dcsr_d       = dcsr_q;
424        1/1              depc_d       = depc_q;
425        1/1              dscratch0_d  = dscratch0_q;
426        1/1              dscratch1_d  = dscratch1_q;
427                     
428        1/1              mstack_d       = mstack_q;
429        1/1              mstack_epc_d   = mstack_epc_q;
430        1/1              mstack_cause_d = mstack_cause_q;
431                     
432        1/1              mcountinhibit_we = 1'b0;
433        1/1              mhpmcounter_we   = '0;
434        1/1              mhpmcounterh_we  = '0;
435                     
436        1/1              if (csr_we_int) begin
437        1/1                unique case (csr_addr_i)
438                             // mstatus: IE bit
439                             CSR_MSTATUS: begin
440        1/1                    mstatus_d = '{
441                                   mie:  csr_wdata_int[CSR_MSTATUS_MIE_BIT],
442                                   mpie: csr_wdata_int[CSR_MSTATUS_MPIE_BIT],
443                                   mpp:  priv_lvl_e'(csr_wdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW]),
444                                   mprv: csr_wdata_int[CSR_MSTATUS_MPRV_BIT],
445                                   tw:   csr_wdata_int[CSR_MSTATUS_TW_BIT]
446                               };
447                               // Convert illegal values to M-mode
448        1/1                    if ((mstatus_d.mpp != PRIV_LVL_M) && (mstatus_d.mpp != PRIV_LVL_U)) begin
449        0/1     ==>              mstatus_d.mpp = PRIV_LVL_M;
450                               end
                        MISSING_ELSE
451                             end
452                     
453                             // interrupt enable
454                             CSR_MIE: begin
455        1/1                    mie_d.irq_software = csr_wdata_int[CSR_MSIX_BIT];
456        1/1                    mie_d.irq_timer    = csr_wdata_int[CSR_MTIX_BIT];
457        1/1                    mie_d.irq_external = csr_wdata_int[CSR_MEIX_BIT];
458        1/1                    mie_d.irq_fast     = csr_wdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW];
459                             end
460                     
461        1/1                  CSR_MSCRATCH: mscratch_d = csr_wdata_int;
462                     
463                             // mepc: exception program counter
464        1/1                  CSR_MEPC: mepc_d = {csr_wdata_int[31:1], 1'b0};
465                     
466                             // mcause
467        1/1                  CSR_MCAUSE: mcause_d = {csr_wdata_int[31], csr_wdata_int[4:0]};
468                     
469                             // mtval: trap value
470        1/1                  CSR_MTVAL: mtval_d = csr_wdata_int;
471                     
472                             // mtvec
473                             // mtvec.MODE set to vectored
474                             // mtvec.BASE must be 256-byte aligned
475        1/1                  CSR_MTVEC: mtvec_d = {csr_wdata_int[31:8], 6'b0, 2'b01};
476                     
477                             CSR_DCSR: begin
478        1/1                    dcsr_d = csr_wdata_int;
479        1/1                    dcsr_d.xdebugver = XDEBUGVER_STD;
480                               // Change to PRIV_LVL_M if software writes an unsupported value
481        1/1                    if ((dcsr_d.prv != PRIV_LVL_M) && (dcsr_d.prv != PRIV_LVL_U)) begin
482        0/1     ==>              dcsr_d.prv = PRIV_LVL_M;
483                               end
                        MISSING_ELSE
484                     
485                               // currently not supported:
486        1/1                    dcsr_d.nmip = 1'b0;
487        1/1                    dcsr_d.mprven = 1'b0;
488        1/1                    dcsr_d.stopcount = 1'b0;
489        1/1                    dcsr_d.stoptime = 1'b0;
490                     
491                               // forced to be zero
492        1/1                    dcsr_d.zero0 = 1'b0;
493        1/1                    dcsr_d.zero1 = 1'b0;
494        1/1                    dcsr_d.zero2 = 12'h0;
495                             end
496                     
497                             // dpc: debug program counter
498        1/1                  CSR_DPC: depc_d = {csr_wdata_int[31:1], 1'b0};
499                     
500        1/1                  CSR_DSCRATCH0: dscratch0_d = csr_wdata_int;
501        1/1                  CSR_DSCRATCH1: dscratch1_d = csr_wdata_int;
502                     
503                             // machine counter/timers
504        0/1     ==>          CSR_MCOUNTINHIBIT: mcountinhibit_we = 1'b1;
505                     
506                             CSR_MCYCLE,
507                             CSR_MINSTRET,
508                             CSR_MHPMCOUNTER3,
509                             CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
510                             CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
511                             CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
512                             CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
513                             CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
514                             CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
515                             CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
516        0/1     ==>            mhpmcounter_we[mhpmcounter_idx] = 1'b1;
517                             end
518                     
519                             CSR_MCYCLEH,
520                             CSR_MINSTRETH,
521                             CSR_MHPMCOUNTER3H,
522                             CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
523                             CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
524                             CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
525                             CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
526                             CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
527                             CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
528                             CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
529        1/1                    mhpmcounterh_we[mhpmcounter_idx] = 1'b1;
530                             end
531                     
532        1/1                  default:;
533                           endcase
534                         end
                        MISSING_ELSE
535                     
536                         // exception controller gets priority over other writes
537        1/1              unique case (1'b1)
538                     
539                           csr_save_cause_i: begin
540        1/1                  unique case (1'b1)
541                               csr_save_if_i: begin
542        1/1                      exception_pc = pc_if_i;
543                               end
544                               csr_save_id_i: begin
545        1/1                      exception_pc = pc_id_i;
546                               end
547        excluded               default:;
548                             endcase
549                     
550                             // Any exception, including debug mode, causes a switch to M-mode
551        1/1                  priv_lvl_d = PRIV_LVL_M;
552                     
553        1/1                  if (debug_csr_save_i) begin
554                               // all interrupts are masked
555                               // do not update cause, epc, tval, epc and status
556        1/1                    dcsr_d.prv   = priv_lvl_q;
557        1/1                    dcsr_d.cause = debug_cause_i;
558        1/1                    depc_d       = exception_pc;
559        1/1                  end else if (!debug_mode_i) begin
560                               // In debug mode, "exceptions do not update any registers. That
561                               // includes cause, epc, tval, dpc and mstatus." [Debug Spec v0.13.2, p.39]
562        1/1                    mtval_d        = csr_mtval_i;
563        1/1                    mstatus_d.mie  = 1'b0; // disable interrupts
564                               // save current status
565        1/1                    mstatus_d.mpie = mstatus_q.mie;
566        1/1                    mstatus_d.mpp  = priv_lvl_q;
567        1/1                    mepc_d         = exception_pc;
568        1/1                    mcause_d       = {csr_mcause_i};
569                               // save previous status for recoverable NMI
570        1/1                    mstack_d.mpie  = mstatus_q.mpie;
571        1/1                    mstack_d.mpp   = mstatus_q.mpp;
572        1/1                    mstack_epc_d   = mepc_q;
573        1/1                    mstack_cause_d = mcause_q;
574                             end
                        MISSING_ELSE
575                           end // csr_save_cause_i
576                     
577                           csr_restore_dret_i: begin // DRET
578        1/1                  priv_lvl_d = dcsr_q.prv;
579                           end // csr_restore_dret_i
580                     
581                           csr_restore_mret_i: begin // MRET
582        1/1                  priv_lvl_d     = mstatus_q.mpp;
583        1/1                  mstatus_d.mie  = mstatus_q.mpie; // re-enable interrupts
584                     
585        1/1                  if (nmi_mode_i) begin
586                               // when returning from an NMI restore state from mstack CSR
587        1/1                    mstatus_d.mpie = mstack_q.mpie;
588        1/1                    mstatus_d.mpp  = mstack_q.mpp;
589        1/1                    mepc_d         = mstack_epc_q;
590        1/1                    mcause_d       = mstack_cause_q;
591                             end else begin
592                               // otherwise just set mstatus.MPIE/MPP
593                               // See RISC-V Privileged Specification, version 1.11, Section 3.1.6.1
594        1/1                    mstatus_d.mpie = 1'b1;
595        1/1                    mstatus_d.mpp  = PRIV_LVL_U;
596                             end
597                           end // csr_restore_mret_i
598                     
599        1/1                default:;
600                         endcase
601                       end
602                     
603                       // CSR operation logic
604                       always_comb begin
605        1/1              csr_wreq = 1'b1;
606                     
607        1/1              unique case (csr_op_i)
608        1/1                CSR_OP_WRITE: csr_wdata_int =  csr_wdata_i;
609        1/1                CSR_OP_SET:   csr_wdata_int =  csr_wdata_i | csr_rdata_o;
610        1/1                CSR_OP_CLEAR: csr_wdata_int = ~csr_wdata_i & csr_rdata_o;
611                           CSR_OP_READ: begin
612        1/1                  csr_wdata_int = csr_wdata_i;
613        1/1                  csr_wreq      = 1'b0;
614                           end
615                           default: begin
616        1/1                  csr_wdata_int = csr_wdata_i;
617        1/1                  csr_wreq      = 1'b0;
618                           end
619                         endcase
620                       end
621                     
622                       // only write CSRs during one clock cycle
623                       assign csr_we_int  = csr_wreq & ~illegal_csr_insn_o & instr_new_id_i;
624                     
625                       assign csr_rdata_o = csr_rdata_int;
626                     
627                       // directly output some registers
628                       assign csr_msip_o  = mip.irq_software;
629                       assign csr_mtip_o  = mip.irq_timer;
630                       assign csr_meip_o  = mip.irq_external;
631                       assign csr_mfip_o  = mip.irq_fast;
632                     
633                       assign csr_mepc_o  = mepc_q;
634                       assign csr_depc_o  = depc_q;
635                       assign csr_mtvec_o = mtvec_q;
636                     
637                       assign csr_mstatus_mie_o   = mstatus_q.mie;
638                       assign csr_mstatus_tw_o    = mstatus_q.tw;
639                       assign debug_single_step_o = dcsr_q.step;
640                       assign debug_ebreakm_o     = dcsr_q.ebreakm;
641                       assign debug_ebreaku_o     = dcsr_q.ebreaku;
642                     
643                       assign irq_pending_o = csr_msip_o | csr_mtip_o | csr_meip_o | (|csr_mfip_o);
644                     
645                       // actual registers
646                       always_ff @(posedge clk_i or negedge rst_ni) begin
647        1/1              if (!rst_ni) begin
648        1/1                priv_lvl_q     <= PRIV_LVL_M;
649        1/1                mstatus_q      <= '{
650                               mie:  1'b0,
651                               mpie: 1'b1,
652                               mpp:  PRIV_LVL_U,
653                               mprv: 1'b0,
654                               tw:   1'b0
655                           };
656        1/1                mie_q          <= '0;
657        1/1                mscratch_q     <= '0;
658        1/1                mepc_q         <= '0;
659        1/1                mcause_q       <= '0;
660        1/1                mtval_q        <= '0;
661        1/1                mtvec_q        <= 32'b01;
662        1/1                dcsr_q         <= '{
663                               xdebugver: XDEBUGVER_STD,
664                               cause:     DBG_CAUSE_NONE, // 3'h0
665                               prv:       PRIV_LVL_M,
666                               default:   '0
667                           };
668        1/1                depc_q         <= '0;
669        1/1                dscratch0_q    <= '0;
670        1/1                dscratch1_q    <= '0;
671                     
672        1/1                mstack_q       <= '{
673                               mpie: 1'b1,
674                               mpp:  PRIV_LVL_U
675                           };
676        1/1                mstack_epc_q   <= '0;
677        1/1                mstack_cause_q <= '0;
678                     
679                         end else begin
680                           // update CSRs
681        1/1                priv_lvl_q     <= priv_lvl_d;
682        1/1                mstatus_q      <= mstatus_d;
683        1/1                mie_q          <= mie_d;
684        1/1                mscratch_q     <= mscratch_d;
685        1/1                mepc_q         <= mepc_d;
686        1/1                mcause_q       <= mcause_d;
687        1/1                mtval_q        <= mtval_d;
688        1/1                mtvec_q        <= mtvec_d;
689        1/1                dcsr_q         <= dcsr_d;
690        1/1                depc_q         <= depc_d;
691        1/1                dscratch0_q    <= dscratch0_d;
692        1/1                dscratch1_q    <= dscratch1_d;
693                     
694        1/1                mstack_q       <= mstack_d;
695        1/1                mstack_epc_q   <= mstack_epc_d;
696        1/1                mstack_cause_q <= mstack_cause_d;
697                     
698                         end
699                       end
700                     
701                       // Send current priv level to the decoder
702                       assign priv_mode_id_o = priv_lvl_q;
703                       // New instruction fetches need to account for updates to priv_lvl_q this cycle
704                       assign priv_mode_if_o = priv_lvl_d;
705                       // Load/store instructions must factor in MPRV for PMP checking
706                       assign priv_mode_lsu_o = mstatus_q.mprv ? mstatus_q.mpp : priv_lvl_q;
707                     
708                       // -----------------
709                       // PMP registers
710                       // -----------------
711                     
712                       if (PMPEnable) begin : g_pmp_registers
713                         pmp_cfg_t                    pmp_cfg         [PMPNumRegions];
714                         pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];
715                         logic [31:0]                 pmp_addr        [PMPNumRegions];
716                         logic [PMPNumRegions-1:0]    pmp_cfg_we;
717                         logic [PMPNumRegions-1:0]    pmp_addr_we;
718                     
719                         // Expanded / qualified register read data
720                         for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_exp_rd_data
721                           if (i < PMPNumRegions) begin : g_implemented_regions
722                             // Add in zero padding for reserved fields
723                             assign pmp_cfg_rdata[i] = {pmp_cfg[i].lock, 2'b00, pmp_cfg[i].mode,
724                                                        pmp_cfg[i].exec, pmp_cfg[i].write, pmp_cfg[i].read};
725                     
726                             // Address field read data depends on the current programmed mode and the granularity
727                             // See RISC-V Privileged Specification, version 1.11, Section 3.6.1
728                             if (PMPGranularity == 0) begin : g_pmp_g0
729                               // If G == 0, read data is unmodified
730                               assign pmp_addr_rdata[i] = pmp_addr[i];
731                     
732                             end else if (PMPGranularity == 1) begin : g_pmp_g1
733                               // If G == 1, bit [G-1] reads as zero in TOR or OFF mode
734                               always_comb begin
735                                 pmp_addr_rdata[i] = pmp_addr[i];
736                                 if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin
737                                   pmp_addr_rdata[i][PMPGranularity-1:0] = '0;
738                                 end
739                               end
740                     
741                             end else begin : g_pmp_g2
742                               // For G >= 2, bits are masked to one or zero depending on the mode
743                               always_comb begin
744                                 pmp_addr_rdata[i] = pmp_addr[i];
745                                 if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin
746                                   // In TOR or OFF mode, bits [G-1:0] must read as zero
747                                   pmp_addr_rdata[i][PMPGranularity-1:0] = '0;
748                                 end else if (pmp_cfg[i].mode == PMP_MODE_NAPOT) begin
749                                   // In NAPOT mode, bits [G-2:0] must read as one
750                                   pmp_addr_rdata[i][PMPGranularity-2:0] = '1;
751                                 end
752                               end
753                             end
754                     
755                           end else begin : g_other_regions
756                             // Non-implemented regions read as zero
757                             assign pmp_cfg_rdata[i]  = '0;
758                             assign pmp_addr_rdata[i] = '0;
759                           end
760                         end
761                     
762                         // Write data calculation
763                         for (genvar i = 0; i < PMPNumRegions; i++) begin : g_pmp_csrs
764                           // -------------------------
765                           // Instantiate cfg registers
766                           // -------------------------
767                           assign pmp_cfg_we[i] = csr_we_int & ~pmp_cfg[i].lock &
768                                                  (csr_addr == (CSR_OFF_PMP_CFG + (i[11:0] >> 2)));
769                     
770                           // Select the correct WDATA (each CSR contains 4 CFG fields, each with 2 RES bits)
771                           assign pmp_cfg_wdata[i].lock  = csr_wdata_int[(i%4)*PMP_CFG_W+7];
772                           // NA4 mode is not selectable when G > 0, mode is treated as OFF
773                           always_comb begin
774                             unique case (csr_wdata_int[(i%4)*PMP_CFG_W+3+:2])
775                               2'b00   : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;
776                               2'b01   : pmp_cfg_wdata[i].mode = PMP_MODE_TOR;
777                               2'b10   : pmp_cfg_wdata[i].mode = (PMPGranularity == 0) ? PMP_MODE_NA4:
778                                                                                         PMP_MODE_OFF;
779                               2'b11   : pmp_cfg_wdata[i].mode = PMP_MODE_NAPOT;
780                               default : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;
781                             endcase
782                           end
783                           assign pmp_cfg_wdata[i].exec  = csr_wdata_int[(i%4)*PMP_CFG_W+2];
784                           // W = 1, R = 0 is a reserved combination. For now, we force W to 0 if R == 0
785                           assign pmp_cfg_wdata[i].write = &csr_wdata_int[(i%4)*PMP_CFG_W+:2];
786                           assign pmp_cfg_wdata[i].read  = csr_wdata_int[(i%4)*PMP_CFG_W];
787                     
788                           always_ff @(posedge clk_i or negedge rst_ni) begin
789                             if (!rst_ni) begin
790                               pmp_cfg[i] <= pmp_cfg_t'('b0);
791                             end else if (pmp_cfg_we[i]) begin
792                               pmp_cfg[i] <= pmp_cfg_wdata[i];
793                             end
794                           end
795                     
796                           // --------------------------
797                           // Instantiate addr registers
798                           // --------------------------
799                           if (i < PMPNumRegions - 1) begin : g_lower
800                             assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg[i].lock &
801                                                     (pmp_cfg[i+1].mode != PMP_MODE_TOR) &
802                                                     (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));
803                           end else begin : g_upper
804                             assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg[i].lock &
805                                                     (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));
806                           end
807                     
808                           always_ff @(posedge clk_i or negedge rst_ni) begin
809                             if (!rst_ni) begin
810                               pmp_addr[i] <= 'b0;
811                             end else if (pmp_addr_we[i]) begin
812                               pmp_addr[i] <= csr_wdata_int;
813                             end
814                           end
815                           assign csr_pmp_cfg_o[i]  = pmp_cfg[i];
816                           assign csr_pmp_addr_o[i] = {pmp_addr[i],2'b00};
817                         end
818                     
819                       end else begin : g_no_pmp_tieoffs
820                         // Generate tieoffs when PMP is not configured
821                         for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_rdata
822                           assign pmp_addr_rdata[i] = '0;
823                           assign pmp_cfg_rdata[i]  = '0;
824                         end
825                         for (genvar i = 0; i < PMPNumRegions; i++) begin : g_outputs
826                           assign csr_pmp_cfg_o[i]  = pmp_cfg_t'(1'b0);
827                           assign csr_pmp_addr_o[i] = '0;
828                         end
829                       end
830                     
831                       //////////////////////////
832                       //  Performance monitor //
833                       //////////////////////////
834                     
835                       // update enable signals
836                       always_comb begin : mcountinhibit_update
837        1/1              if (mcountinhibit_we == 1'b1) begin
838        0/1     ==>        mcountinhibit_d = {csr_wdata_int[31:2], 1'b0, csr_wdata_int[0]}; // bit 1 must always be 0
839                         end else begin
840        1/1                mcountinhibit_d = mcountinhibit_q;
841                         end
842                       end
843                     
844                       assign mcountinhibit_force = {{29-MHPMCounterNum{1'b1}}, {MHPMCounterNum{1'b0}}, 3'b000};
845                       assign mcountinhibit       = mcountinhibit_q | mcountinhibit_force;
846                     
847                       // event selection (hardwired) & control
848                       always_comb begin : gen_mhpmcounter_incr
849                     
850                         // When adding or altering performance counter meanings and default
851                         // mappings please update dv/verilator/pcount/cpp/ibex_pcounts.cc
852                         // appropriately.
853                         //
854                         // active counters
855        1/1              mhpmcounter_incr[0]  = 1'b1;                   // mcycle
856        1/1              mhpmcounter_incr[1]  = 1'b0;                   // reserved
857        1/1              mhpmcounter_incr[2]  = instr_ret_i;            // minstret
858        1/1              mhpmcounter_incr[3]  = lsu_busy_i;             // cycles waiting for data memory
859        1/1              mhpmcounter_incr[4]  = imiss_i & ~pc_set_i;    // cycles waiting for instr fetches
860                                                                        // excl. jump and branch set cycles
861        1/1              mhpmcounter_incr[5]  = mem_load_i;             // num of loads
862        1/1              mhpmcounter_incr[6]  = mem_store_i;            // num of stores
863        1/1              mhpmcounter_incr[7]  = jump_i;                 // num of jumps (unconditional)
864        1/1              mhpmcounter_incr[8]  = branch_i;               // num of branches (conditional)
865        1/1              mhpmcounter_incr[9]  = branch_taken_i;         // num of taken branches (conditional)
866        1/1              mhpmcounter_incr[10] = instr_ret_compressed_i; // num of compressed instr
867                     
868                         // inactive counters
869        1/1              for (int unsigned i=3+MHPMCounterNum; i<32; i++) begin : gen_mhpmcounter_incr_inactive
870        1/1                mhpmcounter_incr[i] = 1'b0;
871                         end
872                       end
873                     
874                       // event selector (hardwired, 0 means no event)
875                       always_comb begin : gen_mhpmevent
876                     
877                         // activate all
878        1/1              for (int i=0; i<32; i++) begin : gen_mhpmevent_active
879        1/1                mhpmevent[i]    =   '0;
880        1/1                mhpmevent[i][i] = 1'b1;
881                         end
882                     
883                         // deactivate
884        1/1              mhpmevent[1] = '0; // not existing, reserved
885        1/1              for (int unsigned i=3+MHPMCounterNum; i<32; i++) begin : gen_mhpmevent_inactive
886        1/1                mhpmevent[i] = '0;
887                         end
888                       end
889                     
890                       // mask, controls effective counter width
891                       always_comb begin : gen_mask
892                     
893        1/1              for (int i=0; i<3; i++) begin : gen_mask_fixed
894                           // mcycle, mtime, minstret are always 64 bit wide
895        1/1                mhpmcounter_mask[i] = {64{1'b1}};
896                         end
897                     
898        1/1              for (int unsigned i=3; i<3+MHPMCounterNum; i++) begin : gen_mask_configurable
899                           // mhpmcounters have a configurable width
900        1/1                mhpmcounter_mask[i] = {{64-MHPMCounterWidth{1'b0}}, {MHPMCounterWidth{1'b1}}};
901                         end
902                     
903        1/1              for (int unsigned i=3+MHPMCounterNum; i<32; i++) begin : gen_mask_inactive
904                           // mask inactive mhpmcounters
905        1/1                mhpmcounter_mask[i] = '0;
906                         end
907                       end
908                     
909                       // update
910                       always_comb begin : mhpmcounter_update
911        1/1              mhpmcounter_d = mhpmcounter_q;
912                     
913        1/1              for (int i=0; i<32; i++) begin : gen_mhpmcounter_update
914                     
915                           // increment
916        1/1                if (mhpmcounter_incr[i] & ~mcountinhibit[i]) begin
917        1/1                  mhpmcounter_d[i] = mhpmcounter_mask[i] & (mhpmcounter_q[i] + 64'h1);
918                           end
                        MISSING_ELSE
919                     
920                           // write
921        1/1                if (mhpmcounter_we[i]) begin
922        0/1     ==>          mhpmcounter_d[i][31: 0] = mhpmcounter_mask[i][31: 0] & csr_wdata_int;
923        1/1                end else if (mhpmcounterh_we[i]) begin
924        1/1                  mhpmcounter_d[i][63:32] = mhpmcounter_mask[i][63:32] & csr_wdata_int;
925                           end
                        MISSING_ELSE
926                         end
927                       end
928                     
929                       // performance monitor registers
930                       always_ff @(posedge clk_i or negedge rst_ni) begin : perf_counter_registers
931        1/1              if (!rst_ni) begin
932        1/1                mcountinhibit_q    <= '0;
933        1/1                for (int i=0; i<32; i++) begin
934        1/1                  mhpmcounter_q[i] <= '0;
935                           end
936                         end else begin
937        1/1                mhpmcounter_q      <= mhpmcounter_d;
938        1/1                mcountinhibit_q    <= mcountinhibit_d;

-------------------------------------------------------------------------------
Branch Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.cs_registers_i(x)
         Line No. Total Covered Percent 
Branches          88    81      92.05   
TERNARY  706      2     1       50.00   
CASE     248      45    45      100.00  
TERNARY  422      2     2       100.00  
IF       436      18    14      77.78   
CASE     537      10    9       90.00   
CASE     607      5     5       100.00  
IF       647      2     2       100.00  
IF       837      2     1       50.00   
IF       931      2     2       100.00  


706          assign priv_mode_lsu_o = mstatus_q.mprv ? mstatus_q.mpp : priv_lvl_q;
                                                     -1-  
                                                     ==>  
                                                     ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


248            unique case (csr_addr_i)
                      -1-  
249              // mhartid: unique hardware thread id
250              CSR_MHARTID: csr_rdata_int = hart_id_i;
                 ==>
251        
252              // mstatus: always M-mode, contains IE bit
253              CSR_MSTATUS: begin
254                csr_rdata_int                                                   = '0;
                   ==>
255                csr_rdata_int[CSR_MSTATUS_MIE_BIT]                              = mstatus_q.mie;
256                csr_rdata_int[CSR_MSTATUS_MPIE_BIT]                             = mstatus_q.mpie;
257                csr_rdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW] = mstatus_q.mpp;
258                csr_rdata_int[CSR_MSTATUS_MPRV_BIT]                             = mstatus_q.mprv;
259                csr_rdata_int[CSR_MSTATUS_TW_BIT]                               = mstatus_q.tw;
260              end
261        
262              // misa
263              CSR_MISA: csr_rdata_int = MISA_VALUE;
                 ==>
264        
265              // interrupt enable
266              CSR_MIE: begin
267                csr_rdata_int                                     = '0;
                   ==>
268                csr_rdata_int[CSR_MSIX_BIT]                       = mie_q.irq_software;
269                csr_rdata_int[CSR_MTIX_BIT]                       = mie_q.irq_timer;
270                csr_rdata_int[CSR_MEIX_BIT]                       = mie_q.irq_external;
271                csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mie_q.irq_fast;
272              end
273        
274              CSR_MSCRATCH: csr_rdata_int = mscratch_q;
                 ==>
275        
276              // mtvec: trap-vector base address
277              CSR_MTVEC: csr_rdata_int = mtvec_q;
                 ==>
278        
279              // mepc: exception program counter
280              CSR_MEPC: csr_rdata_int = mepc_q;
                 ==>
281        
282              // mcause: exception cause
283              CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};
                 ==>
284        
285              // mtval: trap value
286              CSR_MTVAL: csr_rdata_int = mtval_q;
                 ==>
287        
288              // mip: interrupt pending
289              CSR_MIP: begin
290                csr_rdata_int                                     = '0;
                   ==>
291                csr_rdata_int[CSR_MSIX_BIT]                       = mip.irq_software;
292                csr_rdata_int[CSR_MTIX_BIT]                       = mip.irq_timer;
293                csr_rdata_int[CSR_MEIX_BIT]                       = mip.irq_external;
294                csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mip.irq_fast;
295              end
296        
297              // PMP registers
298              CSR_PMPCFG0:   csr_rdata_int = {pmp_cfg_rdata[3],  pmp_cfg_rdata[2],
                 ==>
299                                              pmp_cfg_rdata[1],  pmp_cfg_rdata[0]};
300              CSR_PMPCFG1:   csr_rdata_int = {pmp_cfg_rdata[7],  pmp_cfg_rdata[6],
                 ==>
301                                              pmp_cfg_rdata[5],  pmp_cfg_rdata[4]};
302              CSR_PMPCFG2:   csr_rdata_int = {pmp_cfg_rdata[11], pmp_cfg_rdata[10],
                 ==>
303                                              pmp_cfg_rdata[9],  pmp_cfg_rdata[8]};
304              CSR_PMPCFG3:   csr_rdata_int = {pmp_cfg_rdata[15], pmp_cfg_rdata[14],
                 ==>
305                                              pmp_cfg_rdata[13], pmp_cfg_rdata[12]};
306              CSR_PMPADDR0:  csr_rdata_int = pmp_addr_rdata[0];
                 ==>
307              CSR_PMPADDR1:  csr_rdata_int = pmp_addr_rdata[1];
                 ==>
308              CSR_PMPADDR2:  csr_rdata_int = pmp_addr_rdata[2];
                 ==>
309              CSR_PMPADDR3:  csr_rdata_int = pmp_addr_rdata[3];
                 ==>
310              CSR_PMPADDR4:  csr_rdata_int = pmp_addr_rdata[4];
                 ==>
311              CSR_PMPADDR5:  csr_rdata_int = pmp_addr_rdata[5];
                 ==>
312              CSR_PMPADDR6:  csr_rdata_int = pmp_addr_rdata[6];
                 ==>
313              CSR_PMPADDR7:  csr_rdata_int = pmp_addr_rdata[7];
                 ==>
314              CSR_PMPADDR8:  csr_rdata_int = pmp_addr_rdata[8];
                 ==>
315              CSR_PMPADDR9:  csr_rdata_int = pmp_addr_rdata[9];
                 ==>
316              CSR_PMPADDR10: csr_rdata_int = pmp_addr_rdata[10];
                 ==>
317              CSR_PMPADDR11: csr_rdata_int = pmp_addr_rdata[11];
                 ==>
318              CSR_PMPADDR12: csr_rdata_int = pmp_addr_rdata[12];
                 ==>
319              CSR_PMPADDR13: csr_rdata_int = pmp_addr_rdata[13];
                 ==>
320              CSR_PMPADDR14: csr_rdata_int = pmp_addr_rdata[14];
                 ==>
321              CSR_PMPADDR15: csr_rdata_int = pmp_addr_rdata[15];
                 ==>
322        
323              CSR_DCSR: begin
324                csr_rdata_int = dcsr_q;
                   ==>
325                illegal_csr = ~debug_mode_i;
326              end
327              CSR_DPC: begin
328                csr_rdata_int = depc_q;
                   ==>
329                illegal_csr = ~debug_mode_i;
330              end
331              CSR_DSCRATCH0: begin
332                csr_rdata_int = dscratch0_q;
                   ==>
333                illegal_csr = ~debug_mode_i;
334              end
335              CSR_DSCRATCH1: begin
336                csr_rdata_int = dscratch1_q;
                   ==>
337                illegal_csr = ~debug_mode_i;
338              end
339        
340              // machine counter/timers
341              CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit;
                 ==>
342              CSR_MHPMEVENT3,
343              CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,
344              CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,
345              CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,
346              CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,
347              CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,
348              CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,
349              CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31: begin
350                csr_rdata_int = mhpmevent[mhpmcounter_idx];
                   ==>
351              end
352        
353              CSR_MCYCLE,
354              CSR_MINSTRET,
355              CSR_MHPMCOUNTER3,
356              CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
357              CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
358              CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
359              CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
360              CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
361              CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
362              CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
363                csr_rdata_int = mhpmcounter_q[mhpmcounter_idx][31:0];
                   ==>
364              end
365        
366              CSR_MCYCLEH,
367              CSR_MINSTRETH,
368              CSR_MHPMCOUNTER3H,
369              CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
370              CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
371              CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
372              CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
373              CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
374              CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
375              CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
376                csr_rdata_int = mhpmcounter_q[mhpmcounter_idx][63:32];
                   ==>
377              end
378        
379              // Debug triggers
380              CSR_TSELECT: begin
381                csr_rdata_int = tselect_rdata;
                   ==>
382                illegal_csr   = ~DbgTriggerEn;
383              end
384              CSR_TDATA1: begin
385                csr_rdata_int = tmatch_control_rdata;
                   ==>
386                illegal_csr   = ~DbgTriggerEn;
387              end
388              CSR_TDATA2: begin
389                csr_rdata_int = tmatch_value_rdata;
                   ==>
390                illegal_csr   = ~DbgTriggerEn;
391              end
392              CSR_TDATA3: begin
393                csr_rdata_int = '0;
                   ==>
394                illegal_csr   = ~DbgTriggerEn;
395              end
396              CSR_MCONTEXT: begin
397                csr_rdata_int = '0;
                   ==>
398                illegal_csr   = ~DbgTriggerEn;
399              end
400              CSR_SCONTEXT: begin
401                csr_rdata_int = '0;
                   ==>
402                illegal_csr   = ~DbgTriggerEn;
403              end
404        
405              default: begin
406                illegal_csr = 1'b1;
                   ==>

Branches:

-1-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Status  
CSR_MHARTID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_MSTATUS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_MISA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Covered 
CSR_MIE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Covered 
CSR_MSCRATCH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_MTVEC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Covered 
CSR_MEPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Covered 
CSR_MCAUSE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Covered 
CSR_MTVAL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Covered 
CSR_MIP                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Covered 
CSR_PMPCFG0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_PMPCFG1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_PMPCFG2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_PMPCFG3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_PMPADDR0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR9                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_PMPADDR10                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR11                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR12                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR13                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR14                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_PMPADDR15                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_DCSR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Covered 
CSR_DPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Covered 
CSR_DSCRATCH0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_DSCRATCH1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Covered 
CSR_MCOUNTINHIBIT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Covered 
CASEITEM-36: CSR_MHPMEVENT3 CSR_MHPMEVENT4 CSR_MHPMEVENT5 CSR_MHPMEVENT6 CSR_MHPMEVENT7 CSR_MHPMEVENT8 CSR_MHPMEVENT9 CSR_MHPMEVENT10 CSR_MHPMEVENT11 CSR_MHPMEVENT12 CSR_MHPMEVENT13 CSR_MHPMEVENT14 CSR_MHPMEVENT15 CSR_MHPMEVENT16 CSR_MHPMEVENT17 CSR_MHPMEVENT18 CSR_MHPMEVENT19 CSR_MHPMEVENT20 CSR_MHPMEVENT21 CSR_MHPMEVENT22 CSR_MHPMEVENT23 CSR_MHPMEVENT24 CSR_MHPMEVENT25 CSR_MHPMEVENT26 CSR_MHPMEVENT27 CSR_MHPMEVENT28 CSR_MHPMEVENT29 CSR_MHPMEVENT30 CSR_MHPMEVENT31                                                                                                                   Covered 
CASEITEM-37: CSR_MCYCLE CSR_MINSTRET CSR_MHPMCOUNTER3 CSR_MHPMCOUNTER4 CSR_MHPMCOUNTER5 CSR_MHPMCOUNTER6 CSR_MHPMCOUNTER7 CSR_MHPMCOUNTER8 CSR_MHPMCOUNTER9 CSR_MHPMCOUNTER10 CSR_MHPMCOUNTER11 CSR_MHPMCOUNTER12 CSR_MHPMCOUNTER13 CSR_MHPMCOUNTER14 CSR_MHPMCOUNTER15 CSR_MHPMCOUNTER16 CSR_MHPMCOUNTER17 CSR_MHPMCOUNTER18 CSR_MHPMCOUNTER19 CSR_MHPMCOUNTER20 CSR_MHPMCOUNTER21 CSR_MHPMCOUNTER22 CSR_MHPMCOUNTER23 CSR_MHPMCOUNTER24 CSR_MHPMCOUNTER25 CSR_MHPMCOUNTER26 CSR_MHPMCOUNTER27 CSR_MHPMCOUNTER28 CSR_MHPMCOUNTER29 CSR_MHPMCOUNTER30 CSR_MHPMCOUNTER31                                 Covered 
CASEITEM-38: CSR_MCYCLEH CSR_MINSTRETH CSR_MHPMCOUNTER3H CSR_MHPMCOUNTER4H CSR_MHPMCOUNTER5H CSR_MHPMCOUNTER6H CSR_MHPMCOUNTER7H CSR_MHPMCOUNTER8H CSR_MHPMCOUNTER9H CSR_MHPMCOUNTER10H CSR_MHPMCOUNTER11H CSR_MHPMCOUNTER12H CSR_MHPMCOUNTER13H CSR_MHPMCOUNTER14H CSR_MHPMCOUNTER15H CSR_MHPMCOUNTER16H CSR_MHPMCOUNTER17H CSR_MHPMCOUNTER18H CSR_MHPMCOUNTER19H CSR_MHPMCOUNTER20H CSR_MHPMCOUNTER21H CSR_MHPMCOUNTER22H CSR_MHPMCOUNTER23H CSR_MHPMCOUNTER24H CSR_MHPMCOUNTER25H CSR_MHPMCOUNTER26H CSR_MHPMCOUNTER27H CSR_MHPMCOUNTER28H CSR_MHPMCOUNTER29H CSR_MHPMCOUNTER30H CSR_MHPMCOUNTER31H  Covered 
CSR_TSELECT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Covered 
CSR_TDATA1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Covered 
CSR_TDATA2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Covered 
CSR_TDATA3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Covered 
CSR_MCONTEXT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
CSR_SCONTEXT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Covered 
default                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Covered 


422            mtvec_d      = csr_mtvec_init_i ? {boot_addr_i[31:8], 6'b0, 2'b01} : mtvec_q;
                                               -1-  
                                               ==>  
                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


436            if (csr_we_int) begin
               -1-  
437              unique case (csr_addr_i)
                        -2-  
438                // mstatus: IE bit
439                CSR_MSTATUS: begin
440                  mstatus_d = '{
441                      mie:  csr_wdata_int[CSR_MSTATUS_MIE_BIT],
442                      mpie: csr_wdata_int[CSR_MSTATUS_MPIE_BIT],
443                      mpp:  priv_lvl_e'(csr_wdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW]),
444                      mprv: csr_wdata_int[CSR_MSTATUS_MPRV_BIT],
445                      tw:   csr_wdata_int[CSR_MSTATUS_TW_BIT]
446                  };
447                  // Convert illegal values to M-mode
448                  if ((mstatus_d.mpp != PRIV_LVL_M) && (mstatus_d.mpp != PRIV_LVL_U)) begin
                     -3-  
449                    mstatus_d.mpp = PRIV_LVL_M;
                       ==>
450                  end
                     MISSING_ELSE
                     ==>
451                end
452        
453                // interrupt enable
454                CSR_MIE: begin
455                  mie_d.irq_software = csr_wdata_int[CSR_MSIX_BIT];
                     ==>
456                  mie_d.irq_timer    = csr_wdata_int[CSR_MTIX_BIT];
457                  mie_d.irq_external = csr_wdata_int[CSR_MEIX_BIT];
458                  mie_d.irq_fast     = csr_wdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW];
459                end
460        
461                CSR_MSCRATCH: mscratch_d = csr_wdata_int;
                   ==>
462        
463                // mepc: exception program counter
464                CSR_MEPC: mepc_d = {csr_wdata_int[31:1], 1'b0};
                   ==>
465        
466                // mcause
467                CSR_MCAUSE: mcause_d = {csr_wdata_int[31], csr_wdata_int[4:0]};
                   ==>
468        
469                // mtval: trap value
470                CSR_MTVAL: mtval_d = csr_wdata_int;
                   ==>
471        
472                // mtvec
473                // mtvec.MODE set to vectored
474                // mtvec.BASE must be 256-byte aligned
475                CSR_MTVEC: mtvec_d = {csr_wdata_int[31:8], 6'b0, 2'b01};
                   ==>
476        
477                CSR_DCSR: begin
478                  dcsr_d = csr_wdata_int;
479                  dcsr_d.xdebugver = XDEBUGVER_STD;
480                  // Change to PRIV_LVL_M if software writes an unsupported value
481                  if ((dcsr_d.prv != PRIV_LVL_M) && (dcsr_d.prv != PRIV_LVL_U)) begin
                     -4-  
482                    dcsr_d.prv = PRIV_LVL_M;
                       ==>
483                  end
                     MISSING_ELSE
                     ==>
484        
485                  // currently not supported:
486                  dcsr_d.nmip = 1'b0;
487                  dcsr_d.mprven = 1'b0;
488                  dcsr_d.stopcount = 1'b0;
489                  dcsr_d.stoptime = 1'b0;
490        
491                  // forced to be zero
492                  dcsr_d.zero0 = 1'b0;
493                  dcsr_d.zero1 = 1'b0;
494                  dcsr_d.zero2 = 12'h0;
495                end
496        
497                // dpc: debug program counter
498                CSR_DPC: depc_d = {csr_wdata_int[31:1], 1'b0};
                   ==>
499        
500                CSR_DSCRATCH0: dscratch0_d = csr_wdata_int;
                   ==>
501                CSR_DSCRATCH1: dscratch1_d = csr_wdata_int;
                   ==>
502        
503                // machine counter/timers
504                CSR_MCOUNTINHIBIT: mcountinhibit_we = 1'b1;
                   ==>
505        
506                CSR_MCYCLE,
507                CSR_MINSTRET,
508                CSR_MHPMCOUNTER3,
509                CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,
510                CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,
511                CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,
512                CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,
513                CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,
514                CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,
515                CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin
516                  mhpmcounter_we[mhpmcounter_idx] = 1'b1;
                     ==>
517                end
518        
519                CSR_MCYCLEH,
520                CSR_MINSTRETH,
521                CSR_MHPMCOUNTER3H,
522                CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,
523                CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,
524                CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,
525                CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,
526                CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,
527                CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,
528                CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin
529                  mhpmcounterh_we[mhpmcounter_idx] = 1'b1;
                     ==>
530                end
531        
532                default:;
                   ==>
533              endcase
534            end
               MISSING_ELSE
               ==>

Branches:

-1- -2-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     -3- -4- Status      
1   CSR_MSTATUS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             1   -   Not Covered 
1   CSR_MSTATUS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             0   -   Covered     
1   CSR_MIE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Covered     
1   CSR_MSCRATCH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            -   -   Covered     
1   CSR_MEPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   -   Covered     
1   CSR_MCAUSE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              -   -   Covered     
1   CSR_MTVAL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -   -   Covered     
1   CSR_MTVEC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -   -   Covered     
1   CSR_DCSR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   1   Not Covered 
1   CSR_DCSR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                -   0   Covered     
1   CSR_DPC                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Covered     
1   CSR_DSCRATCH0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Covered     
1   CSR_DSCRATCH1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           -   -   Covered     
1   CSR_MCOUNTINHIBIT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -   -   Not Covered 
1   CASEITEM-13: CSR_MCYCLE CSR_MINSTRET CSR_MHPMCOUNTER3 CSR_MHPMCOUNTER4 CSR_MHPMCOUNTER5 CSR_MHPMCOUNTER6 CSR_MHPMCOUNTER7 CSR_MHPMCOUNTER8 CSR_MHPMCOUNTER9 CSR_MHPMCOUNTER10 CSR_MHPMCOUNTER11 CSR_MHPMCOUNTER12 CSR_MHPMCOUNTER13 CSR_MHPMCOUNTER14 CSR_MHPMCOUNTER15 CSR_MHPMCOUNTER16 CSR_MHPMCOUNTER17 CSR_MHPMCOUNTER18 CSR_MHPMCOUNTER19 CSR_MHPMCOUNTER20 CSR_MHPMCOUNTER21 CSR_MHPMCOUNTER22 CSR_MHPMCOUNTER23 CSR_MHPMCOUNTER24 CSR_MHPMCOUNTER25 CSR_MHPMCOUNTER26 CSR_MHPMCOUNTER27 CSR_MHPMCOUNTER28 CSR_MHPMCOUNTER29 CSR_MHPMCOUNTER30 CSR_MHPMCOUNTER31                                 -   -   Not Covered 
1   CASEITEM-14: CSR_MCYCLEH CSR_MINSTRETH CSR_MHPMCOUNTER3H CSR_MHPMCOUNTER4H CSR_MHPMCOUNTER5H CSR_MHPMCOUNTER6H CSR_MHPMCOUNTER7H CSR_MHPMCOUNTER8H CSR_MHPMCOUNTER9H CSR_MHPMCOUNTER10H CSR_MHPMCOUNTER11H CSR_MHPMCOUNTER12H CSR_MHPMCOUNTER13H CSR_MHPMCOUNTER14H CSR_MHPMCOUNTER15H CSR_MHPMCOUNTER16H CSR_MHPMCOUNTER17H CSR_MHPMCOUNTER18H CSR_MHPMCOUNTER19H CSR_MHPMCOUNTER20H CSR_MHPMCOUNTER21H CSR_MHPMCOUNTER22H CSR_MHPMCOUNTER23H CSR_MHPMCOUNTER24H CSR_MHPMCOUNTER25H CSR_MHPMCOUNTER26H CSR_MHPMCOUNTER27H CSR_MHPMCOUNTER28H CSR_MHPMCOUNTER29H CSR_MHPMCOUNTER30H CSR_MHPMCOUNTER31H  -   -   Covered     
1   default                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 -   -   Covered     
0   -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -   -   Covered     


537            unique case (1'b1)
                      -1-  
538        
539              csr_save_cause_i: begin
540                unique case (1'b1)
                          -2-  
541                  csr_save_if_i: begin
542                    exception_pc = pc_if_i;
                       ==>
543                  end
544                  csr_save_id_i: begin
545                    exception_pc = pc_id_i;
                       ==>
546                  end
547                  default:;
                     ==>
548                endcase
549        
550                // Any exception, including debug mode, causes a switch to M-mode
551                priv_lvl_d = PRIV_LVL_M;
552        
553                if (debug_csr_save_i) begin
                   -3-  
554                  // all interrupts are masked
555                  // do not update cause, epc, tval, epc and status
556                  dcsr_d.prv   = priv_lvl_q;
                     ==>
557                  dcsr_d.cause = debug_cause_i;
558                  depc_d       = exception_pc;
559                end else if (!debug_mode_i) begin
                            -4-  
560                  // In debug mode, "exceptions do not update any registers. That
561                  // includes cause, epc, tval, dpc and mstatus." [Debug Spec v0.13.2, p.39]
562                  mtval_d        = csr_mtval_i;
                     ==>
563                  mstatus_d.mie  = 1'b0; // disable interrupts
564                  // save current status
565                  mstatus_d.mpie = mstatus_q.mie;
566                  mstatus_d.mpp  = priv_lvl_q;
567                  mepc_d         = exception_pc;
568                  mcause_d       = {csr_mcause_i};
569                  // save previous status for recoverable NMI
570                  mstack_d.mpie  = mstatus_q.mpie;
571                  mstack_d.mpp   = mstatus_q.mpp;
572                  mstack_epc_d   = mepc_q;
573                  mstack_cause_d = mcause_q;
574                end
                   MISSING_ELSE
                   ==>
575              end // csr_save_cause_i
576        
577              csr_restore_dret_i: begin // DRET
578                priv_lvl_d = dcsr_q.prv;
                   ==>
579              end // csr_restore_dret_i
580        
581              csr_restore_mret_i: begin // MRET
582                priv_lvl_d     = mstatus_q.mpp;
583                mstatus_d.mie  = mstatus_q.mpie; // re-enable interrupts
584        
585                if (nmi_mode_i) begin
                   -5-  
586                  // when returning from an NMI restore state from mstack CSR
587                  mstatus_d.mpie = mstack_q.mpie;
                     ==>
588                  mstatus_d.mpp  = mstack_q.mpp;
589                  mepc_d         = mstack_epc_q;
590                  mcause_d       = mstack_cause_q;
591                end else begin
592                  // otherwise just set mstatus.MPIE/MPP
593                  // See RISC-V Privileged Specification, version 1.11, Section 3.1.6.1
594                  mstatus_d.mpie = 1'b1;
                     ==>
595                  mstatus_d.mpp  = PRIV_LVL_U;
596                end
597              end // csr_restore_mret_i
598        
599              default:;
                 ==>

Branches:

-1-                 -2-            -3- -4- -5- Status      
csr_save_cause_i    csr_save_if_i  -   -   -   Covered     
csr_save_cause_i    csr_save_id_i  -   -   -   Covered     
csr_save_cause_i    default        -   -   -   Not Covered 
csr_save_cause_i    -              1   -   -   Covered     
csr_save_cause_i    -              0   1   -   Covered     
csr_save_cause_i    -              0   0   -   Covered     
csr_restore_dret_i  -              -   -   -   Covered     
csr_restore_mret_i  -              -   -   1   Covered     
csr_restore_mret_i  -              -   -   0   Covered     
default             -              -   -   -   Covered     


607            unique case (csr_op_i)
                      -1-  
608              CSR_OP_WRITE: csr_wdata_int =  csr_wdata_i;
                 ==>
609              CSR_OP_SET:   csr_wdata_int =  csr_wdata_i | csr_rdata_o;
                 ==>
610              CSR_OP_CLEAR: csr_wdata_int = ~csr_wdata_i & csr_rdata_o;
                 ==>
611              CSR_OP_READ: begin
612                csr_wdata_int = csr_wdata_i;
                   ==>
613                csr_wreq      = 1'b0;
614              end
615              default: begin
616                csr_wdata_int = csr_wdata_i;
                   ==>

Branches:

-1-           Status  
CSR_OP_WRITE  Covered 
CSR_OP_SET    Covered 
CSR_OP_CLEAR  Covered 
CSR_OP_READ   Covered 
default       Covered 


647            if (!rst_ni) begin
               -1-  
648              priv_lvl_q     <= PRIV_LVL_M;
                 ==>
649              mstatus_q      <= '{
650                  mie:  1'b0,
651                  mpie: 1'b1,
652                  mpp:  PRIV_LVL_U,
653                  mprv: 1'b0,
654                  tw:   1'b0
655              };
656              mie_q          <= '0;
657              mscratch_q     <= '0;
658              mepc_q         <= '0;
659              mcause_q       <= '0;
660              mtval_q        <= '0;
661              mtvec_q        <= 32'b01;
662              dcsr_q         <= '{
663                  xdebugver: XDEBUGVER_STD,
664                  cause:     DBG_CAUSE_NONE, // 3'h0
665                  prv:       PRIV_LVL_M,
666                  default:   '0
667              };
668              depc_q         <= '0;
669              dscratch0_q    <= '0;
670              dscratch1_q    <= '0;
671        
672              mstack_q       <= '{
673                  mpie: 1'b1,
674                  mpp:  PRIV_LVL_U
675              };
676              mstack_epc_q   <= '0;
677              mstack_cause_q <= '0;
678        
679            end else begin
680              // update CSRs
681              priv_lvl_q     <= priv_lvl_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


837            if (mcountinhibit_we == 1'b1) begin
               -1-  
838              mcountinhibit_d = {csr_wdata_int[31:2], 1'b0, csr_wdata_int[0]}; // bit 1 must always be 0
                 ==>
839            end else begin
840              mcountinhibit_d = mcountinhibit_q;
                 ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


931            if (!rst_ni) begin
               -1-  
932              mcountinhibit_q    <= '0;
                 ==>
933              for (int i=0; i<32; i++) begin
934                mhpmcounter_q[i] <= '0;
935              end
936            end else begin
937              mhpmcounter_q      <= mhpmcounter_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


===============================================================================
Module : ibex_multdiv_fast
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 95.40  99.17 --      89.47  97.56 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_multdiv_fast.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                                                      
 96.49 100.00 --      89.47 100.00 --     core_ibex_tb_top.dut.u_ibex_core.ex_block_i.gen_multdiv_fast.multdiv_i(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_multdiv_fast

             Line No.   Total   Covered  Percent
TOTAL                      120      119    99.17
ALWAYS             73       20       20   100.00
ALWAYS            131        3        3   100.00
ALWAYS            145       50       50   100.00
ALWAYS            249       47       46    97.87

72                        always_ff @(posedge clk_i or negedge rst_ni) begin : proc_mult_state_q
73         1/1              if (!rst_ni) begin
74         1/1                mult_state_q     <= ALBL;
75         1/1                mac_res_q        <= '0;
76         1/1                div_counter_q    <= '0;
77         1/1                md_state_q       <= MD_IDLE;
78         1/1                op_denominator_q <= '0;
79         1/1                op_numerator_q   <= '0;
80         1/1                op_quotient_q    <= '0;
81                          end else begin
82                      
83         1/1                if (mult_en_i) begin
84         1/1                  mult_state_q <= mult_state_n;
85                            end
                        MISSING_ELSE
86                      
87         1/1                if (div_en_i) begin
88         1/1                  div_counter_q    <= div_counter_n;
89         1/1                  op_denominator_q <= op_denominator_n;
90         1/1                  op_numerator_q   <= op_numerator_n;
91         1/1                  op_quotient_q    <= op_quotient_n;
92         1/1                  md_state_q       <= md_state_n;
93                            end
                        MISSING_ELSE
94                      
95         1/1                unique case(1'b1)
96                              mult_en_i:
97         1/1                    mac_res_q <= mac_res_n;
98                              div_en_i:
99         1/1                    mac_res_q <= op_remainder_n;
100                             default:
101        1/1                    mac_res_q <= mac_res_q;
102                            endcase
103                         end
104                       end
105                     
106                       assign signed_mult      = (signed_mode_i != 2'b00);
107                     
108                       assign multdiv_result_o = div_en_i ? mac_res_q[31:0] : mac_res_n[31:0];
109                     
110                       // The 2 MSBs of mac_res_ext (mac_res_ext[34:33]) are always equal since:
111                       // 1. The 2 MSBs of the multiplicants are always equal, and
112                       // 2. The 16 MSBs of the addend (accum[33:18]) are always equal.
113                       // Thus, it is safe to ignore mac_res_ext[34].
114                       assign mac_res_signed =
115                           $signed({sign_a, mult_op_a}) * $signed({sign_b, mult_op_b}) + $signed(accum);
116                       assign mac_res_ext    = $unsigned(mac_res_signed);
117                       assign mac_res        = mac_res_ext[33:0];
118                     
119                       assign res_adder_h    = alu_adder_ext_i[33:1];
120                     
121                       assign next_remainder = is_greater_equal ? res_adder_h[31:0] : mac_res_q[31:0];
122                       assign next_quotient  = is_greater_equal ? {1'b0,op_quotient_q} | {1'b0,one_shift} :
123                                                                  {1'b0,op_quotient_q};
124                     
125                       assign one_shift      = {31'b0, 1'b1} << div_counter_q;
126                     
127                       // The adder in the ALU computes alu_operand_a_o + alu_operand_b_o which means
128                       // Remainder - Divisor. If Remainder - Divisor >= 0, is_greater_equal is equal to 1,
129                       // the next Remainder is Remainder - Divisor contained in res_adder_h and the
130                       always_comb begin
131        1/1              if ((mac_res_q[31] ^ op_denominator_q[31]) == 1'b0) begin
132        1/1                is_greater_equal = (res_adder_h[31] == 1'b0);
133                         end else begin
134        1/1                is_greater_equal = mac_res_q[31];
135                         end
136                       end
137                     
138                       assign div_sign_a      = op_a_i[31] & signed_mode_i[0];
139                       assign div_sign_b      = op_b_i[31] & signed_mode_i[1];
140                       assign div_change_sign = div_sign_a ^ div_sign_b;
141                       assign rem_change_sign = div_sign_a;
142                     
143                     
144                       always_comb begin : md_fsm
145        1/1              div_counter_n    = div_counter_q - 5'h1;
146        1/1              op_remainder_n   = mac_res_q;
147        1/1              op_quotient_n    = op_quotient_q;
148        1/1              md_state_n       = md_state_q;
149        1/1              op_numerator_n   = op_numerator_q;
150        1/1              op_denominator_n = op_denominator_q;
151        1/1              alu_operand_a_o  = {32'h0  , 1'b1};
152        1/1              alu_operand_b_o  = {~op_b_i, 1'b1};
153        1/1              div_valid        = 1'b0;
154                     
155        1/1              unique case(md_state_q)
156                           MD_IDLE: begin
157        1/1                  if (operator_i == MD_OP_DIV) begin
158                               // Check if the Denominator is 0
159                               // quotient for division by 0
160        1/1                    op_remainder_n = '1;
161        1/1                    md_state_n     = equal_to_zero ? MD_FINISH : MD_ABS_A;
162                             end else begin
163                               // Check if the Denominator is 0
164                               // remainder for division by 0
165        1/1                    op_remainder_n = {2'b0, op_a_i};
166        1/1                    md_state_n     = equal_to_zero ? MD_FINISH : MD_ABS_A;
167                             end
168                             // 0 - B = 0 iff B == 0
169        1/1                  alu_operand_a_o  = {32'h0  , 1'b1};
170        1/1                  alu_operand_b_o  = {~op_b_i, 1'b1};
171        1/1                  div_counter_n    = 5'd31;
172                           end
173                     
174                           MD_ABS_A: begin
175                             // quotient
176        1/1                  op_quotient_n   = '0;
177                             // A abs value
178        1/1                  op_numerator_n  = div_sign_a ? alu_adder_i : op_a_i;
179        1/1                  md_state_n      = MD_ABS_B;
180        1/1                  div_counter_n   = 5'd31;
181                             // ABS(A) = 0 - A
182        1/1                  alu_operand_a_o = {32'h0  , 1'b1};
183        1/1                  alu_operand_b_o = {~op_a_i, 1'b1};
184                           end
185                     
186                           MD_ABS_B: begin
187                             // remainder
188        1/1                  op_remainder_n   = { 33'h0, op_numerator_q[31]};
189                             // B abs value
190        1/1                  op_denominator_n = div_sign_b ? alu_adder_i : op_b_i;
191        1/1                  md_state_n       = MD_COMP;
192        1/1                  div_counter_n    = 5'd31;
193                             // ABS(B) = 0 - B
194        1/1                  alu_operand_a_o  = {32'h0  , 1'b1};
195        1/1                  alu_operand_b_o  = {~op_b_i, 1'b1};
196                           end
197                     
198                           MD_COMP: begin
199        1/1                  op_remainder_n  = {1'b0, next_remainder[31:0], op_numerator_q[div_counter_n]};
200        1/1                  op_quotient_n   = next_quotient[31:0];
201        1/1                  md_state_n      = (div_counter_q == 5'd1) ? MD_LAST : MD_COMP;
202                             // Division
203        1/1                  alu_operand_a_o = {mac_res_q[31:0], 1'b1};         // it contains the remainder
204        1/1                  alu_operand_b_o = {~op_denominator_q[31:0], 1'b1}; // -denominator two's compliment
205                           end
206                     
207                           MD_LAST: begin
208        1/1                  if (operator_i == MD_OP_DIV) begin
209                               // this time we save the quotient in op_remainder_n (i.e. mac_res_q) since
210                               // we do not need anymore the remainder
211        1/1                    op_remainder_n = {1'b0, next_quotient};
212                             end else begin
213                               // this time we do not save the quotient anymore since we need only the remainder
214        1/1                    op_remainder_n = {2'b0, next_remainder[31:0]};
215                             end
216                             // Division
217        1/1                  alu_operand_a_o  = {mac_res_q[31:0], 1'b1};         // it contains the remainder
218        1/1                  alu_operand_b_o  = {~op_denominator_q[31:0], 1'b1}; // -denominator two's compliment
219                     
220        1/1                  md_state_n = MD_CHANGE_SIGN;
221                           end
222                     
223                           MD_CHANGE_SIGN: begin
224        1/1                  md_state_n  = MD_FINISH;
225        1/1                  if (operator_i == MD_OP_DIV) begin
226        1/1                    op_remainder_n = (div_change_sign) ? {2'h0,alu_adder_i} : mac_res_q;
227                             end else begin
228        1/1                    op_remainder_n = (rem_change_sign) ? {2'h0,alu_adder_i} : mac_res_q;
229                             end
230                             // ABS(Quotient) = 0 - Quotient (or Remainder)
231        1/1                  alu_operand_a_o  = {32'h0  , 1'b1};
232        1/1                  alu_operand_b_o  = {~mac_res_q[31:0], 1'b1};
233                           end
234                     
235                           MD_FINISH: begin
236        1/1                  md_state_n = MD_IDLE;
237        1/1                  div_valid   = 1'b1;
238                           end
239                     
240                           default: begin
241        1/1                  md_state_n = MD_IDLE;
242                           end
243                         endcase // md_state_q
244                       end
245                     
246                       assign valid_o = mult_valid | div_valid;
247                     
248                       always_comb begin : mult_fsm
249        1/1              mult_op_a    = op_a_i[`OP_L];
250        1/1              mult_op_b    = op_b_i[`OP_L];
251        1/1              sign_a       = 1'b0;
252        1/1              sign_b       = 1'b0;
253        1/1              accum        = mac_res_q;
254        1/1              mac_res_n    = mac_res;
255        1/1              mult_state_n = mult_state_q;
256        1/1              mult_valid   = 1'b0;
257                     
258        1/1              unique case (mult_state_q)
259                     
260                           ALBL: begin
261                             // al*bl
262        1/1                  mult_op_a = op_a_i[`OP_L];
263        1/1                  mult_op_b = op_b_i[`OP_L];
264        1/1                  sign_a    = 1'b0;
265        1/1                  sign_b    = 1'b0;
266        1/1                  accum     = '0;
267        1/1                  mac_res_n = mac_res;
268        1/1                  mult_state_n = ALBH;
269                           end
270                     
271                           ALBH: begin
272                             // al*bh<<16
273        1/1                  mult_op_a = op_a_i[`OP_L];
274        1/1                  mult_op_b = op_b_i[`OP_H];
275        1/1                  sign_a    = 1'b0;
276        1/1                  sign_b    = signed_mode_i[1] & op_b_i[31];
277                             // result of AL*BL (in mac_res_q) always unsigned with no carry, so carries_q always 00
278        1/1                  accum     = {18'b0,mac_res_q[31:16]};
279        1/1                  if (operator_i == MD_OP_MULL) begin
280        1/1                    mac_res_n = {2'b0,mac_res[`OP_L],mac_res_q[`OP_L]};
281                             end else begin
282                               // MD_OP_MULH
283        1/1                    mac_res_n = mac_res;
284                             end
285        1/1                  mult_state_n = AHBL;
286                           end
287                     
288                           AHBL: begin
289                             // ah*bl<<16
290        1/1                  mult_op_a = op_a_i[`OP_H];
291        1/1                  mult_op_b = op_b_i[`OP_L];
292        1/1                  sign_a    = signed_mode_i[0] & op_a_i[31];
293        1/1                  sign_b    = 1'b0;
294        1/1                  if (operator_i == MD_OP_MULL) begin
295        1/1                    accum        = {18'b0,mac_res_q[31:16]};
296        1/1                    mac_res_n    = {2'b0,mac_res[15:0],mac_res_q[15:0]};
297        1/1                    mult_valid   = 1'b1;
298        1/1                    mult_state_n = ALBL;
299                             end else begin
300        1/1                    accum        = mac_res_q;
301        1/1                    mac_res_n    = mac_res;
302        1/1                    mult_state_n = AHBH;
303                             end
304                           end
305                     
306                           AHBH: begin
307                             // only MD_OP_MULH here
308                             // ah*bh
309        1/1                  mult_op_a = op_a_i[`OP_H];
310        1/1                  mult_op_b = op_b_i[`OP_H];
311        1/1                  sign_a    = signed_mode_i[0] & op_a_i[31];
312        1/1                  sign_b    = signed_mode_i[1] & op_b_i[31];
313        1/1                  accum[17: 0]  = mac_res_q[33:16];
314        1/1                  accum[33:18]  = {16{signed_mult & mac_res_q[33]}};
315                             // result of AH*BL is not signed only if signed_mode_i == 2'b00
316        1/1                  mac_res_n    = mac_res;
317        1/1                  mult_state_n = ALBL;
318        1/1                  mult_valid   = 1'b1;
319                           end
320                           default: begin
321        0/1     ==>          mult_state_n = ALBL;

-------------------------------------------------------------------------------
FSM Coverage for Module : ibex_multdiv_fast
Summary for FSM :: mult_state_q
            Total Covered Percent                         
States      4     4       100.00  (Not included in score) 
Transitions 6     6       100.00                          
Sequences   0     0                                       

State, Transition and Sequence Details for FSM :: mult_state_q
-------------------------------------------------------------------------------
states Line No. Covered 
AHBH   302      Covered 
AHBL   285      Covered 
ALBH   268      Covered 
ALBL   74       Covered 

transitions Line No. Covered 
AHBH->ALBL  74       Covered 
AHBL->AHBH  302      Covered 
AHBL->ALBL  74       Covered 
ALBH->AHBL  285      Covered 
ALBH->ALBL  74       Covered 
ALBL->ALBH  268      Covered 

Summary for FSM :: md_state_q
            Total Covered Percent                         
States      7     7       100.00  (Not included in score) 
Transitions 13    11      84.62                           
Sequences   0     0                                       

State, Transition and Sequence Details for FSM :: md_state_q
-------------------------------------------------------------------------------
states         Line No. Covered 
MD_ABS_A       161      Covered 
MD_ABS_B       179      Covered 
MD_CHANGE_SIGN 220      Covered 
MD_COMP        191      Covered 
MD_FINISH      161      Covered 
MD_IDLE        77       Covered 
MD_LAST        201      Covered 

transitions               Line No. Covered     
MD_ABS_A->MD_ABS_B        179      Covered     
MD_ABS_A->MD_IDLE         77       Covered     
MD_ABS_B->MD_COMP         191      Covered     
MD_ABS_B->MD_IDLE         77       Covered     
MD_CHANGE_SIGN->MD_FINISH 224      Covered     
MD_CHANGE_SIGN->MD_IDLE   77       Not Covered 
MD_COMP->MD_IDLE          77       Covered     
MD_COMP->MD_LAST          201      Covered     
MD_FINISH->MD_IDLE        77       Covered     
MD_IDLE->MD_ABS_A         161      Covered     
MD_IDLE->MD_FINISH        161      Covered     
MD_LAST->MD_CHANGE_SIGN   220      Covered     
MD_LAST->MD_IDLE          77       Not Covered 


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_multdiv_fast
         Line No. Total Covered Percent 
Branches          41    40      97.56   
TERNARY  108      2     2       100.00  
TERNARY  121      2     2       100.00  
TERNARY  122      2     2       100.00  
IF       73       8     8       100.00  
IF       131      2     2       100.00  
CASE     155      18    18      100.00  
CASE     258      7     6       85.71   


108          assign multdiv_result_o = div_en_i ? mac_res_q[31:0] : mac_res_n[31:0];
                                                -1-  
                                                ==>  
                                                ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


121          assign next_remainder = is_greater_equal ? res_adder_h[31:0] : mac_res_q[31:0];
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


122          assign next_quotient  = is_greater_equal ? {1'b0,op_quotient_q} | {1'b0,one_shift} :
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


73             if (!rst_ni) begin
               -1-  
74               mult_state_q     <= ALBL;
                 ==>
75               mac_res_q        <= '0;
76               div_counter_q    <= '0;
77               md_state_q       <= MD_IDLE;
78               op_denominator_q <= '0;
79               op_numerator_q   <= '0;
80               op_quotient_q    <= '0;
81             end else begin
82         
83               if (mult_en_i) begin
                 -2-  
84                 mult_state_q <= mult_state_n;
                   ==>
85               end
                 MISSING_ELSE
                 ==>
86         
87               if (div_en_i) begin
                 -3-  
88                 div_counter_q    <= div_counter_n;
                   ==>
89                 op_denominator_q <= op_denominator_n;
90                 op_numerator_q   <= op_numerator_n;
91                 op_quotient_q    <= op_quotient_n;
92                 md_state_q       <= md_state_n;
93               end
                 MISSING_ELSE
                 ==>
94         
95               unique case(1'b1)
                        -4-  
96                 mult_en_i:
97                   mac_res_q <= mac_res_n;
                     ==>
98                 div_en_i:
99                   mac_res_q <= op_remainder_n;
                     ==>
100                default:
101                  mac_res_q <= mac_res_q;
                     ==>

Branches:

-1- -2- -3- -4-        Status  
1   -   -   -          Covered 
0   1   -   -          Covered 
0   0   -   -          Covered 
0   -   1   -          Covered 
0   -   0   -          Covered 
0   -   -   mult_en_i  Covered 
0   -   -   div_en_i   Covered 
0   -   -   default    Covered 


131            if ((mac_res_q[31] ^ op_denominator_q[31]) == 1'b0) begin
               -1-  
132              is_greater_equal = (res_adder_h[31] == 1'b0);
                 ==>
133            end else begin
134              is_greater_equal = mac_res_q[31];
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


155            unique case(md_state_q)
                      -1-  
156              MD_IDLE: begin
157                if (operator_i == MD_OP_DIV) begin
                   -2-  
158                  // Check if the Denominator is 0
159                  // quotient for division by 0
160                  op_remainder_n = '1;
161                  md_state_n     = equal_to_zero ? MD_FINISH : MD_ABS_A;
                                                    -3-  
                                                    ==>  
                                                    ==>  
162                end else begin
163                  // Check if the Denominator is 0
164                  // remainder for division by 0
165                  op_remainder_n = {2'b0, op_a_i};
166                  md_state_n     = equal_to_zero ? MD_FINISH : MD_ABS_A;
                                                    -4-  
                                                    ==>  
                                                    ==>  
167                end
168                // 0 - B = 0 iff B == 0
169                alu_operand_a_o  = {32'h0  , 1'b1};
170                alu_operand_b_o  = {~op_b_i, 1'b1};
171                div_counter_n    = 5'd31;
172              end
173        
174              MD_ABS_A: begin
175                // quotient
176                op_quotient_n   = '0;
177                // A abs value
178                op_numerator_n  = div_sign_a ? alu_adder_i : op_a_i;
                                                -5-  
                                                ==>  
                                                ==>  
179                md_state_n      = MD_ABS_B;
180                div_counter_n   = 5'd31;
181                // ABS(A) = 0 - A
182                alu_operand_a_o = {32'h0  , 1'b1};
183                alu_operand_b_o = {~op_a_i, 1'b1};
184              end
185        
186              MD_ABS_B: begin
187                // remainder
188                op_remainder_n   = { 33'h0, op_numerator_q[31]};
189                // B abs value
190                op_denominator_n = div_sign_b ? alu_adder_i : op_b_i;
                                                 -6-  
                                                 ==>  
                                                 ==>  
191                md_state_n       = MD_COMP;
192                div_counter_n    = 5'd31;
193                // ABS(B) = 0 - B
194                alu_operand_a_o  = {32'h0  , 1'b1};
195                alu_operand_b_o  = {~op_b_i, 1'b1};
196              end
197        
198              MD_COMP: begin
199                op_remainder_n  = {1'b0, next_remainder[31:0], op_numerator_q[div_counter_n]};
200                op_quotient_n   = next_quotient[31:0];
201                md_state_n      = (div_counter_q == 5'd1) ? MD_LAST : MD_COMP;
                                                             -7-  
                                                             ==>  
                                                             ==>  
202                // Division
203                alu_operand_a_o = {mac_res_q[31:0], 1'b1};         // it contains the remainder
204                alu_operand_b_o = {~op_denominator_q[31:0], 1'b1}; // -denominator two's compliment
205              end
206        
207              MD_LAST: begin
208                if (operator_i == MD_OP_DIV) begin
                   -8-  
209                  // this time we save the quotient in op_remainder_n (i.e. mac_res_q) since
210                  // we do not need anymore the remainder
211                  op_remainder_n = {1'b0, next_quotient};
                     ==>
212                end else begin
213                  // this time we do not save the quotient anymore since we need only the remainder
214                  op_remainder_n = {2'b0, next_remainder[31:0]};
                     ==>
215                end
216                // Division
217                alu_operand_a_o  = {mac_res_q[31:0], 1'b1};         // it contains the remainder
218                alu_operand_b_o  = {~op_denominator_q[31:0], 1'b1}; // -denominator two's compliment
219        
220                md_state_n = MD_CHANGE_SIGN;
221              end
222        
223              MD_CHANGE_SIGN: begin
224                md_state_n  = MD_FINISH;
225                if (operator_i == MD_OP_DIV) begin
                   -9-  
226                  op_remainder_n = (div_change_sign) ? {2'h0,alu_adder_i} : mac_res_q;
                                                        -10-  
                                                        ==>  
                                                        ==>  
227                end else begin
228                  op_remainder_n = (rem_change_sign) ? {2'h0,alu_adder_i} : mac_res_q;
                                                        -11-  
                                                        ==>  
                                                        ==>  
229                end
230                // ABS(Quotient) = 0 - Quotient (or Remainder)
231                alu_operand_a_o  = {32'h0  , 1'b1};
232                alu_operand_b_o  = {~mac_res_q[31:0], 1'b1};
233              end
234        
235              MD_FINISH: begin
236                md_state_n = MD_IDLE;
                   ==>
237                div_valid   = 1'b1;
238              end
239        
240              default: begin
241                md_state_n = MD_IDLE;
                   ==>

Branches:

-1-             -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- Status  
MD_IDLE         1   1   -   -   -   -   -   -   -    -    Covered 
MD_IDLE         1   0   -   -   -   -   -   -   -    -    Covered 
MD_IDLE         0   -   1   -   -   -   -   -   -    -    Covered 
MD_IDLE         0   -   0   -   -   -   -   -   -    -    Covered 
MD_ABS_A        -   -   -   1   -   -   -   -   -    -    Covered 
MD_ABS_A        -   -   -   0   -   -   -   -   -    -    Covered 
MD_ABS_B        -   -   -   -   1   -   -   -   -    -    Covered 
MD_ABS_B        -   -   -   -   0   -   -   -   -    -    Covered 
MD_COMP         -   -   -   -   -   1   -   -   -    -    Covered 
MD_COMP         -   -   -   -   -   0   -   -   -    -    Covered 
MD_LAST         -   -   -   -   -   -   1   -   -    -    Covered 
MD_LAST         -   -   -   -   -   -   0   -   -    -    Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   1   1    -    Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   1   0    -    Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   0   -    1    Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   0   -    0    Covered 
MD_FINISH       -   -   -   -   -   -   -   -   -    -    Covered 
default         -   -   -   -   -   -   -   -   -    -    Covered 


258            unique case (mult_state_q)
                      -1-  
259        
260              ALBL: begin
261                // al*bl
262                mult_op_a = op_a_i[`OP_L];
                   ==>
263                mult_op_b = op_b_i[`OP_L];
264                sign_a    = 1'b0;
265                sign_b    = 1'b0;
266                accum     = '0;
267                mac_res_n = mac_res;
268                mult_state_n = ALBH;
269              end
270        
271              ALBH: begin
272                // al*bh<<16
273                mult_op_a = op_a_i[`OP_L];
274                mult_op_b = op_b_i[`OP_H];
275                sign_a    = 1'b0;
276                sign_b    = signed_mode_i[1] & op_b_i[31];
277                // result of AL*BL (in mac_res_q) always unsigned with no carry, so carries_q always 00
278                accum     = {18'b0,mac_res_q[31:16]};
279                if (operator_i == MD_OP_MULL) begin
                   -2-  
280                  mac_res_n = {2'b0,mac_res[`OP_L],mac_res_q[`OP_L]};
                     ==>
281                end else begin
282                  // MD_OP_MULH
283                  mac_res_n = mac_res;
                     ==>
284                end
285                mult_state_n = AHBL;
286              end
287        
288              AHBL: begin
289                // ah*bl<<16
290                mult_op_a = op_a_i[`OP_H];
291                mult_op_b = op_b_i[`OP_L];
292                sign_a    = signed_mode_i[0] & op_a_i[31];
293                sign_b    = 1'b0;
294                if (operator_i == MD_OP_MULL) begin
                   -3-  
295                  accum        = {18'b0,mac_res_q[31:16]};
                     ==>
296                  mac_res_n    = {2'b0,mac_res[15:0],mac_res_q[15:0]};
297                  mult_valid   = 1'b1;
298                  mult_state_n = ALBL;
299                end else begin
300                  accum        = mac_res_q;
                     ==>
301                  mac_res_n    = mac_res;
302                  mult_state_n = AHBH;
303                end
304              end
305        
306              AHBH: begin
307                // only MD_OP_MULH here
308                // ah*bh
309                mult_op_a = op_a_i[`OP_H];
                   ==>
310                mult_op_b = op_b_i[`OP_H];
311                sign_a    = signed_mode_i[0] & op_a_i[31];
312                sign_b    = signed_mode_i[1] & op_b_i[31];
313                accum[17: 0]  = mac_res_q[33:16];
314                accum[33:18]  = {16{signed_mult & mac_res_q[33]}};
315                // result of AH*BL is not signed only if signed_mode_i == 2'b00
316                mac_res_n    = mac_res;
317                mult_state_n = ALBL;
318                mult_valid   = 1'b1;
319              end
320              default: begin
321                mult_state_n = ALBL;
                   ==>

Branches:

-1-     -2- -3- Status      
ALBL    -   -   Covered     
ALBH    1   -   Covered     
ALBH    0   -   Covered     
AHBL    -   1   Covered     
AHBL    -   0   Covered     
AHBH    -   -   Covered     
default -   -   Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.ex_block_i.gen_multdiv_fast.multdiv_i(x)
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 96.49 100.00 --      89.47 100.00 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 96.49 100.00 --      89.47 100.00 --     


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME              
 95.40  99.17 --      89.47  97.56 --     ibex_multdiv_fast 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME       
100.00 --     --     --     100.00 --     ex_block_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.ex_block_i.gen_multdiv_fast.multdiv_i(x)

             Line No.   Total   Covered  Percent
TOTAL                      119      119   100.00
ALWAYS             73       20       20   100.00
ALWAYS            131        3        3   100.00
ALWAYS            145       50       50   100.00
ALWAYS            249       46       46   100.00

72                        always_ff @(posedge clk_i or negedge rst_ni) begin : proc_mult_state_q
73         1/1              if (!rst_ni) begin
74         1/1                mult_state_q     <= ALBL;
75         1/1                mac_res_q        <= '0;
76         1/1                div_counter_q    <= '0;
77         1/1                md_state_q       <= MD_IDLE;
78         1/1                op_denominator_q <= '0;
79         1/1                op_numerator_q   <= '0;
80         1/1                op_quotient_q    <= '0;
81                          end else begin
82                      
83         1/1                if (mult_en_i) begin
84         1/1                  mult_state_q <= mult_state_n;
85                            end
                        MISSING_ELSE
86                      
87         1/1                if (div_en_i) begin
88         1/1                  div_counter_q    <= div_counter_n;
89         1/1                  op_denominator_q <= op_denominator_n;
90         1/1                  op_numerator_q   <= op_numerator_n;
91         1/1                  op_quotient_q    <= op_quotient_n;
92         1/1                  md_state_q       <= md_state_n;
93                            end
                        MISSING_ELSE
94                      
95         1/1                unique case(1'b1)
96                              mult_en_i:
97         1/1                    mac_res_q <= mac_res_n;
98                              div_en_i:
99         1/1                    mac_res_q <= op_remainder_n;
100                             default:
101        1/1                    mac_res_q <= mac_res_q;
102                            endcase
103                         end
104                       end
105                     
106                       assign signed_mult      = (signed_mode_i != 2'b00);
107                     
108                       assign multdiv_result_o = div_en_i ? mac_res_q[31:0] : mac_res_n[31:0];
109                     
110                       // The 2 MSBs of mac_res_ext (mac_res_ext[34:33]) are always equal since:
111                       // 1. The 2 MSBs of the multiplicants are always equal, and
112                       // 2. The 16 MSBs of the addend (accum[33:18]) are always equal.
113                       // Thus, it is safe to ignore mac_res_ext[34].
114                       assign mac_res_signed =
115                           $signed({sign_a, mult_op_a}) * $signed({sign_b, mult_op_b}) + $signed(accum);
116                       assign mac_res_ext    = $unsigned(mac_res_signed);
117                       assign mac_res        = mac_res_ext[33:0];
118                     
119                       assign res_adder_h    = alu_adder_ext_i[33:1];
120                     
121                       assign next_remainder = is_greater_equal ? res_adder_h[31:0] : mac_res_q[31:0];
122                       assign next_quotient  = is_greater_equal ? {1'b0,op_quotient_q} | {1'b0,one_shift} :
123                                                                  {1'b0,op_quotient_q};
124                     
125                       assign one_shift      = {31'b0, 1'b1} << div_counter_q;
126                     
127                       // The adder in the ALU computes alu_operand_a_o + alu_operand_b_o which means
128                       // Remainder - Divisor. If Remainder - Divisor >= 0, is_greater_equal is equal to 1,
129                       // the next Remainder is Remainder - Divisor contained in res_adder_h and the
130                       always_comb begin
131        1/1              if ((mac_res_q[31] ^ op_denominator_q[31]) == 1'b0) begin
132        1/1                is_greater_equal = (res_adder_h[31] == 1'b0);
133                         end else begin
134        1/1                is_greater_equal = mac_res_q[31];
135                         end
136                       end
137                     
138                       assign div_sign_a      = op_a_i[31] & signed_mode_i[0];
139                       assign div_sign_b      = op_b_i[31] & signed_mode_i[1];
140                       assign div_change_sign = div_sign_a ^ div_sign_b;
141                       assign rem_change_sign = div_sign_a;
142                     
143                     
144                       always_comb begin : md_fsm
145        1/1              div_counter_n    = div_counter_q - 5'h1;
146        1/1              op_remainder_n   = mac_res_q;
147        1/1              op_quotient_n    = op_quotient_q;
148        1/1              md_state_n       = md_state_q;
149        1/1              op_numerator_n   = op_numerator_q;
150        1/1              op_denominator_n = op_denominator_q;
151        1/1              alu_operand_a_o  = {32'h0  , 1'b1};
152        1/1              alu_operand_b_o  = {~op_b_i, 1'b1};
153        1/1              div_valid        = 1'b0;
154                     
155        1/1              unique case(md_state_q)
156                           MD_IDLE: begin
157        1/1                  if (operator_i == MD_OP_DIV) begin
158                               // Check if the Denominator is 0
159                               // quotient for division by 0
160        1/1                    op_remainder_n = '1;
161        1/1                    md_state_n     = equal_to_zero ? MD_FINISH : MD_ABS_A;
162                             end else begin
163                               // Check if the Denominator is 0
164                               // remainder for division by 0
165        1/1                    op_remainder_n = {2'b0, op_a_i};
166        1/1                    md_state_n     = equal_to_zero ? MD_FINISH : MD_ABS_A;
167                             end
168                             // 0 - B = 0 iff B == 0
169        1/1                  alu_operand_a_o  = {32'h0  , 1'b1};
170        1/1                  alu_operand_b_o  = {~op_b_i, 1'b1};
171        1/1                  div_counter_n    = 5'd31;
172                           end
173                     
174                           MD_ABS_A: begin
175                             // quotient
176        1/1                  op_quotient_n   = '0;
177                             // A abs value
178        1/1                  op_numerator_n  = div_sign_a ? alu_adder_i : op_a_i;
179        1/1                  md_state_n      = MD_ABS_B;
180        1/1                  div_counter_n   = 5'd31;
181                             // ABS(A) = 0 - A
182        1/1                  alu_operand_a_o = {32'h0  , 1'b1};
183        1/1                  alu_operand_b_o = {~op_a_i, 1'b1};
184                           end
185                     
186                           MD_ABS_B: begin
187                             // remainder
188        1/1                  op_remainder_n   = { 33'h0, op_numerator_q[31]};
189                             // B abs value
190        1/1                  op_denominator_n = div_sign_b ? alu_adder_i : op_b_i;
191        1/1                  md_state_n       = MD_COMP;
192        1/1                  div_counter_n    = 5'd31;
193                             // ABS(B) = 0 - B
194        1/1                  alu_operand_a_o  = {32'h0  , 1'b1};
195        1/1                  alu_operand_b_o  = {~op_b_i, 1'b1};
196                           end
197                     
198                           MD_COMP: begin
199        1/1                  op_remainder_n  = {1'b0, next_remainder[31:0], op_numerator_q[div_counter_n]};
200        1/1                  op_quotient_n   = next_quotient[31:0];
201        1/1                  md_state_n      = (div_counter_q == 5'd1) ? MD_LAST : MD_COMP;
202                             // Division
203        1/1                  alu_operand_a_o = {mac_res_q[31:0], 1'b1};         // it contains the remainder
204        1/1                  alu_operand_b_o = {~op_denominator_q[31:0], 1'b1}; // -denominator two's compliment
205                           end
206                     
207                           MD_LAST: begin
208        1/1                  if (operator_i == MD_OP_DIV) begin
209                               // this time we save the quotient in op_remainder_n (i.e. mac_res_q) since
210                               // we do not need anymore the remainder
211        1/1                    op_remainder_n = {1'b0, next_quotient};
212                             end else begin
213                               // this time we do not save the quotient anymore since we need only the remainder
214        1/1                    op_remainder_n = {2'b0, next_remainder[31:0]};
215                             end
216                             // Division
217        1/1                  alu_operand_a_o  = {mac_res_q[31:0], 1'b1};         // it contains the remainder
218        1/1                  alu_operand_b_o  = {~op_denominator_q[31:0], 1'b1}; // -denominator two's compliment
219                     
220        1/1                  md_state_n = MD_CHANGE_SIGN;
221                           end
222                     
223                           MD_CHANGE_SIGN: begin
224        1/1                  md_state_n  = MD_FINISH;
225        1/1                  if (operator_i == MD_OP_DIV) begin
226        1/1                    op_remainder_n = (div_change_sign) ? {2'h0,alu_adder_i} : mac_res_q;
227                             end else begin
228        1/1                    op_remainder_n = (rem_change_sign) ? {2'h0,alu_adder_i} : mac_res_q;
229                             end
230                             // ABS(Quotient) = 0 - Quotient (or Remainder)
231        1/1                  alu_operand_a_o  = {32'h0  , 1'b1};
232        1/1                  alu_operand_b_o  = {~mac_res_q[31:0], 1'b1};
233                           end
234                     
235                           MD_FINISH: begin
236        1/1                  md_state_n = MD_IDLE;
237        1/1                  div_valid   = 1'b1;
238                           end
239                     
240                           default: begin
241        1/1                  md_state_n = MD_IDLE;
242                           end
243                         endcase // md_state_q
244                       end
245                     
246                       assign valid_o = mult_valid | div_valid;
247                     
248                       always_comb begin : mult_fsm
249        1/1              mult_op_a    = op_a_i[`OP_L];
250        1/1              mult_op_b    = op_b_i[`OP_L];
251        1/1              sign_a       = 1'b0;
252        1/1              sign_b       = 1'b0;
253        1/1              accum        = mac_res_q;
254        1/1              mac_res_n    = mac_res;
255        1/1              mult_state_n = mult_state_q;
256        1/1              mult_valid   = 1'b0;
257                     
258        1/1              unique case (mult_state_q)
259                     
260                           ALBL: begin
261                             // al*bl
262        1/1                  mult_op_a = op_a_i[`OP_L];
263        1/1                  mult_op_b = op_b_i[`OP_L];
264        1/1                  sign_a    = 1'b0;
265        1/1                  sign_b    = 1'b0;
266        1/1                  accum     = '0;
267        1/1                  mac_res_n = mac_res;
268        1/1                  mult_state_n = ALBH;
269                           end
270                     
271                           ALBH: begin
272                             // al*bh<<16
273        1/1                  mult_op_a = op_a_i[`OP_L];
274        1/1                  mult_op_b = op_b_i[`OP_H];
275        1/1                  sign_a    = 1'b0;
276        1/1                  sign_b    = signed_mode_i[1] & op_b_i[31];
277                             // result of AL*BL (in mac_res_q) always unsigned with no carry, so carries_q always 00
278        1/1                  accum     = {18'b0,mac_res_q[31:16]};
279        1/1                  if (operator_i == MD_OP_MULL) begin
280        1/1                    mac_res_n = {2'b0,mac_res[`OP_L],mac_res_q[`OP_L]};
281                             end else begin
282                               // MD_OP_MULH
283        1/1                    mac_res_n = mac_res;
284                             end
285        1/1                  mult_state_n = AHBL;
286                           end
287                     
288                           AHBL: begin
289                             // ah*bl<<16
290        1/1                  mult_op_a = op_a_i[`OP_H];
291        1/1                  mult_op_b = op_b_i[`OP_L];
292        1/1                  sign_a    = signed_mode_i[0] & op_a_i[31];
293        1/1                  sign_b    = 1'b0;
294        1/1                  if (operator_i == MD_OP_MULL) begin
295        1/1                    accum        = {18'b0,mac_res_q[31:16]};
296        1/1                    mac_res_n    = {2'b0,mac_res[15:0],mac_res_q[15:0]};
297        1/1                    mult_valid   = 1'b1;
298        1/1                    mult_state_n = ALBL;
299                             end else begin
300        1/1                    accum        = mac_res_q;
301        1/1                    mac_res_n    = mac_res;
302        1/1                    mult_state_n = AHBH;
303                             end
304                           end
305                     
306                           AHBH: begin
307                             // only MD_OP_MULH here
308                             // ah*bh
309        1/1                  mult_op_a = op_a_i[`OP_H];
310        1/1                  mult_op_b = op_b_i[`OP_H];
311        1/1                  sign_a    = signed_mode_i[0] & op_a_i[31];
312        1/1                  sign_b    = signed_mode_i[1] & op_b_i[31];
313        1/1                  accum[17: 0]  = mac_res_q[33:16];
314        1/1                  accum[33:18]  = {16{signed_mult & mac_res_q[33]}};
315                             // result of AH*BL is not signed only if signed_mode_i == 2'b00
316        1/1                  mac_res_n    = mac_res;
317        1/1                  mult_state_n = ALBL;
318        1/1                  mult_valid   = 1'b1;
319                           end
320                           default: begin
321        excluded             mult_state_n = ALBL;

-------------------------------------------------------------------------------
FSM Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.ex_block_i.gen_multdiv_fast.multdiv_i(x)
Summary for FSM :: mult_state_q
            Total Covered Percent                         
States      4     4       100.00  (Not included in score) 
Transitions 6     6       100.00                          
Sequences   0     0                                       

State, Transition and Sequence Details for FSM :: mult_state_q
-------------------------------------------------------------------------------
states Line No. Covered 
AHBH   302      Covered 
AHBL   285      Covered 
ALBH   268      Covered 
ALBL   74       Covered 

transitions Line No. Covered 
AHBH->ALBL  74       Covered 
AHBL->AHBH  302      Covered 
AHBL->ALBL  74       Covered 
ALBH->AHBL  285      Covered 
ALBH->ALBL  74       Covered 
ALBL->ALBH  268      Covered 

Summary for FSM :: md_state_q
            Total Covered Percent                         
States      7     7       100.00  (Not included in score) 
Transitions 13    11      84.62                           
Sequences   0     0                                       

State, Transition and Sequence Details for FSM :: md_state_q
-------------------------------------------------------------------------------
states         Line No. Covered 
MD_ABS_A       161      Covered 
MD_ABS_B       179      Covered 
MD_CHANGE_SIGN 220      Covered 
MD_COMP        191      Covered 
MD_FINISH      161      Covered 
MD_IDLE        77       Covered 
MD_LAST        201      Covered 

transitions               Line No. Covered     
MD_ABS_A->MD_ABS_B        179      Covered     
MD_ABS_A->MD_IDLE         77       Covered     
MD_ABS_B->MD_COMP         191      Covered     
MD_ABS_B->MD_IDLE         77       Covered     
MD_CHANGE_SIGN->MD_FINISH 224      Covered     
MD_CHANGE_SIGN->MD_IDLE   77       Not Covered 
MD_COMP->MD_IDLE          77       Covered     
MD_COMP->MD_LAST          201      Covered     
MD_FINISH->MD_IDLE        77       Covered     
MD_IDLE->MD_ABS_A         161      Covered     
MD_IDLE->MD_FINISH        161      Covered     
MD_LAST->MD_CHANGE_SIGN   220      Covered     
MD_LAST->MD_IDLE          77       Not Covered 


-------------------------------------------------------------------------------
Branch Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.ex_block_i.gen_multdiv_fast.multdiv_i(x)
         Line No. Total Covered Percent 
Branches          40    40      100.00  
TERNARY  108      2     2       100.00  
TERNARY  121      2     2       100.00  
TERNARY  122      2     2       100.00  
IF       73       8     8       100.00  
IF       131      2     2       100.00  
CASE     155      18    18      100.00  
CASE     258      6     6       100.00  


108          assign multdiv_result_o = div_en_i ? mac_res_q[31:0] : mac_res_n[31:0];
                                                -1-  
                                                ==>  
                                                ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


121          assign next_remainder = is_greater_equal ? res_adder_h[31:0] : mac_res_q[31:0];
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


122          assign next_quotient  = is_greater_equal ? {1'b0,op_quotient_q} | {1'b0,one_shift} :
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


73             if (!rst_ni) begin
               -1-  
74               mult_state_q     <= ALBL;
                 ==>
75               mac_res_q        <= '0;
76               div_counter_q    <= '0;
77               md_state_q       <= MD_IDLE;
78               op_denominator_q <= '0;
79               op_numerator_q   <= '0;
80               op_quotient_q    <= '0;
81             end else begin
82         
83               if (mult_en_i) begin
                 -2-  
84                 mult_state_q <= mult_state_n;
                   ==>
85               end
                 MISSING_ELSE
                 ==>
86         
87               if (div_en_i) begin
                 -3-  
88                 div_counter_q    <= div_counter_n;
                   ==>
89                 op_denominator_q <= op_denominator_n;
90                 op_numerator_q   <= op_numerator_n;
91                 op_quotient_q    <= op_quotient_n;
92                 md_state_q       <= md_state_n;
93               end
                 MISSING_ELSE
                 ==>
94         
95               unique case(1'b1)
                        -4-  
96                 mult_en_i:
97                   mac_res_q <= mac_res_n;
                     ==>
98                 div_en_i:
99                   mac_res_q <= op_remainder_n;
                     ==>
100                default:
101                  mac_res_q <= mac_res_q;
                     ==>

Branches:

-1- -2- -3- -4-        Status  
1   -   -   -          Covered 
0   1   -   -          Covered 
0   0   -   -          Covered 
0   -   1   -          Covered 
0   -   0   -          Covered 
0   -   -   mult_en_i  Covered 
0   -   -   div_en_i   Covered 
0   -   -   default    Covered 


131            if ((mac_res_q[31] ^ op_denominator_q[31]) == 1'b0) begin
               -1-  
132              is_greater_equal = (res_adder_h[31] == 1'b0);
                 ==>
133            end else begin
134              is_greater_equal = mac_res_q[31];
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


155            unique case(md_state_q)
                      -1-  
156              MD_IDLE: begin
157                if (operator_i == MD_OP_DIV) begin
                   -2-  
158                  // Check if the Denominator is 0
159                  // quotient for division by 0
160                  op_remainder_n = '1;
161                  md_state_n     = equal_to_zero ? MD_FINISH : MD_ABS_A;
                                                    -3-  
                                                    ==>  
                                                    ==>  
162                end else begin
163                  // Check if the Denominator is 0
164                  // remainder for division by 0
165                  op_remainder_n = {2'b0, op_a_i};
166                  md_state_n     = equal_to_zero ? MD_FINISH : MD_ABS_A;
                                                    -4-  
                                                    ==>  
                                                    ==>  
167                end
168                // 0 - B = 0 iff B == 0
169                alu_operand_a_o  = {32'h0  , 1'b1};
170                alu_operand_b_o  = {~op_b_i, 1'b1};
171                div_counter_n    = 5'd31;
172              end
173        
174              MD_ABS_A: begin
175                // quotient
176                op_quotient_n   = '0;
177                // A abs value
178                op_numerator_n  = div_sign_a ? alu_adder_i : op_a_i;
                                                -5-  
                                                ==>  
                                                ==>  
179                md_state_n      = MD_ABS_B;
180                div_counter_n   = 5'd31;
181                // ABS(A) = 0 - A
182                alu_operand_a_o = {32'h0  , 1'b1};
183                alu_operand_b_o = {~op_a_i, 1'b1};
184              end
185        
186              MD_ABS_B: begin
187                // remainder
188                op_remainder_n   = { 33'h0, op_numerator_q[31]};
189                // B abs value
190                op_denominator_n = div_sign_b ? alu_adder_i : op_b_i;
                                                 -6-  
                                                 ==>  
                                                 ==>  
191                md_state_n       = MD_COMP;
192                div_counter_n    = 5'd31;
193                // ABS(B) = 0 - B
194                alu_operand_a_o  = {32'h0  , 1'b1};
195                alu_operand_b_o  = {~op_b_i, 1'b1};
196              end
197        
198              MD_COMP: begin
199                op_remainder_n  = {1'b0, next_remainder[31:0], op_numerator_q[div_counter_n]};
200                op_quotient_n   = next_quotient[31:0];
201                md_state_n      = (div_counter_q == 5'd1) ? MD_LAST : MD_COMP;
                                                             -7-  
                                                             ==>  
                                                             ==>  
202                // Division
203                alu_operand_a_o = {mac_res_q[31:0], 1'b1};         // it contains the remainder
204                alu_operand_b_o = {~op_denominator_q[31:0], 1'b1}; // -denominator two's compliment
205              end
206        
207              MD_LAST: begin
208                if (operator_i == MD_OP_DIV) begin
                   -8-  
209                  // this time we save the quotient in op_remainder_n (i.e. mac_res_q) since
210                  // we do not need anymore the remainder
211                  op_remainder_n = {1'b0, next_quotient};
                     ==>
212                end else begin
213                  // this time we do not save the quotient anymore since we need only the remainder
214                  op_remainder_n = {2'b0, next_remainder[31:0]};
                     ==>
215                end
216                // Division
217                alu_operand_a_o  = {mac_res_q[31:0], 1'b1};         // it contains the remainder
218                alu_operand_b_o  = {~op_denominator_q[31:0], 1'b1}; // -denominator two's compliment
219        
220                md_state_n = MD_CHANGE_SIGN;
221              end
222        
223              MD_CHANGE_SIGN: begin
224                md_state_n  = MD_FINISH;
225                if (operator_i == MD_OP_DIV) begin
                   -9-  
226                  op_remainder_n = (div_change_sign) ? {2'h0,alu_adder_i} : mac_res_q;
                                                        -10-  
                                                        ==>  
                                                        ==>  
227                end else begin
228                  op_remainder_n = (rem_change_sign) ? {2'h0,alu_adder_i} : mac_res_q;
                                                        -11-  
                                                        ==>  
                                                        ==>  
229                end
230                // ABS(Quotient) = 0 - Quotient (or Remainder)
231                alu_operand_a_o  = {32'h0  , 1'b1};
232                alu_operand_b_o  = {~mac_res_q[31:0], 1'b1};
233              end
234        
235              MD_FINISH: begin
236                md_state_n = MD_IDLE;
                   ==>
237                div_valid   = 1'b1;
238              end
239        
240              default: begin
241                md_state_n = MD_IDLE;
                   ==>

Branches:

-1-             -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- Status  
MD_IDLE         1   1   -   -   -   -   -   -   -    -    Covered 
MD_IDLE         1   0   -   -   -   -   -   -   -    -    Covered 
MD_IDLE         0   -   1   -   -   -   -   -   -    -    Covered 
MD_IDLE         0   -   0   -   -   -   -   -   -    -    Covered 
MD_ABS_A        -   -   -   1   -   -   -   -   -    -    Covered 
MD_ABS_A        -   -   -   0   -   -   -   -   -    -    Covered 
MD_ABS_B        -   -   -   -   1   -   -   -   -    -    Covered 
MD_ABS_B        -   -   -   -   0   -   -   -   -    -    Covered 
MD_COMP         -   -   -   -   -   1   -   -   -    -    Covered 
MD_COMP         -   -   -   -   -   0   -   -   -    -    Covered 
MD_LAST         -   -   -   -   -   -   1   -   -    -    Covered 
MD_LAST         -   -   -   -   -   -   0   -   -    -    Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   1   1    -    Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   1   0    -    Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   0   -    1    Covered 
MD_CHANGE_SIGN  -   -   -   -   -   -   -   0   -    0    Covered 
MD_FINISH       -   -   -   -   -   -   -   -   -    -    Covered 
default         -   -   -   -   -   -   -   -   -    -    Covered 


258            unique case (mult_state_q)
                      -1-  
259        
260              ALBL: begin
261                // al*bl
262                mult_op_a = op_a_i[`OP_L];
                   ==>
263                mult_op_b = op_b_i[`OP_L];
264                sign_a    = 1'b0;
265                sign_b    = 1'b0;
266                accum     = '0;
267                mac_res_n = mac_res;
268                mult_state_n = ALBH;
269              end
270        
271              ALBH: begin
272                // al*bh<<16
273                mult_op_a = op_a_i[`OP_L];
274                mult_op_b = op_b_i[`OP_H];
275                sign_a    = 1'b0;
276                sign_b    = signed_mode_i[1] & op_b_i[31];
277                // result of AL*BL (in mac_res_q) always unsigned with no carry, so carries_q always 00
278                accum     = {18'b0,mac_res_q[31:16]};
279                if (operator_i == MD_OP_MULL) begin
                   -2-  
280                  mac_res_n = {2'b0,mac_res[`OP_L],mac_res_q[`OP_L]};
                     ==>
281                end else begin
282                  // MD_OP_MULH
283                  mac_res_n = mac_res;
                     ==>
284                end
285                mult_state_n = AHBL;
286              end
287        
288              AHBL: begin
289                // ah*bl<<16
290                mult_op_a = op_a_i[`OP_H];
291                mult_op_b = op_b_i[`OP_L];
292                sign_a    = signed_mode_i[0] & op_a_i[31];
293                sign_b    = 1'b0;
294                if (operator_i == MD_OP_MULL) begin
                   -3-  
295                  accum        = {18'b0,mac_res_q[31:16]};
                     ==>
296                  mac_res_n    = {2'b0,mac_res[15:0],mac_res_q[15:0]};
297                  mult_valid   = 1'b1;
298                  mult_state_n = ALBL;
299                end else begin
300                  accum        = mac_res_q;
                     ==>
301                  mac_res_n    = mac_res;
302                  mult_state_n = AHBH;
303                end
304              end
305        
306              AHBH: begin
307                // only MD_OP_MULH here
308                // ah*bh
309                mult_op_a = op_a_i[`OP_H];
                   ==>
310                mult_op_b = op_b_i[`OP_H];
311                sign_a    = signed_mode_i[0] & op_a_i[31];
312                sign_b    = signed_mode_i[1] & op_b_i[31];
313                accum[17: 0]  = mac_res_q[33:16];
314                accum[33:18]  = {16{signed_mult & mac_res_q[33]}};
315                // result of AH*BL is not signed only if signed_mode_i == 2'b00
316                mac_res_n    = mac_res;
317                mult_state_n = ALBL;
318                mult_valid   = 1'b1;
319              end
320              default: begin
321                mult_state_n = ALBL;
                   ==> (Excluded)

Branches:

-1-     -2- -3- Status   
ALBL    -   -   Covered  
ALBH    1   -   Covered  
ALBH    0   -   Covered  
AHBL    -   1   Covered  
AHBL    -   0   Covered  
AHBH    -   -   Covered  
default -   -   Excluded 


===============================================================================
Module : ibex_if_stage
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 95.96  96.23 --     --      91.67 100.00 

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_if_stage.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                           
100.00 100.00 --     --     100.00 100.00 core_ibex_tb_top.dut.u_ibex_core.if_stage_i(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_if_stage

             Line No.   Total   Covered  Percent
TOTAL                       53       51    96.23
ALWAYS            107        6        5    83.33
ALWAYS            118        7        6    85.71
ALWAYS            163        3        3   100.00
ALWAYS            172       17       17   100.00
ALWAYS            230       20       20   100.00

106                       always_comb begin : exc_pc_mux
107        1/1              unique case (exc_pc_mux_i)
108        1/1                EXC_PC_EXC:     exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
109        1/1                EXC_PC_IRQ:     exc_pc = { csr_mtvec_i[31:8], 1'b0, irq_id[4:0], 2'b00 };
110        1/1                EXC_PC_DBD:     exc_pc = DmHaltAddr;
111        1/1                EXC_PC_DBG_EXC: exc_pc = DmExceptionAddr;
112        0/1     ==>        default:        exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
113                         endcase
114                       end
115                     
116                       // fetch address selection mux
117                       always_comb begin : fetch_addr_mux
118        1/1              unique case (pc_mux_i)
119        1/1                PC_BOOT: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
120        1/1                PC_JUMP: fetch_addr_n = jump_target_ex_i;
121        1/1                PC_EXC:  fetch_addr_n = exc_pc;                       // set PC to exception handler
122        1/1                PC_ERET: fetch_addr_n = csr_mepc_i;                   // restore PC when returning from EXC
123        1/1                PC_DRET: fetch_addr_n = csr_depc_i;
124        0/1     ==>        default: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
125                         endcase
126                       end
127                     
128                       // tell CS register file to initialize mtvec on boot
129                       assign csr_mtvec_init_o = (pc_mux_i == PC_BOOT) & pc_set_i;
130                     
131                       // prefetch buffer, caches a fixed number of instructions
132                       ibex_prefetch_buffer prefetch_buffer_i (
133                           .clk_i             ( clk_i                       ),
134                           .rst_ni            ( rst_ni                      ),
135                     
136                           .req_i             ( req_i                       ),
137                     
138                           .branch_i          ( branch_req                  ),
139                           .addr_i            ( {fetch_addr_n[31:1], 1'b0}  ),
140                     
141                           .ready_i           ( fetch_ready                 ),
142                           .valid_o           ( fetch_valid                 ),
143                           .rdata_o           ( fetch_rdata                 ),
144                           .addr_o            ( fetch_addr                  ),
145                           .err_o             ( fetch_err                   ),
146                     
147                           // goes to instruction memory / instruction cache
148                           .instr_req_o       ( instr_req_o                 ),
149                           .instr_addr_o      ( instr_addr_o                ),
150                           .instr_gnt_i       ( instr_gnt_i                 ),
151                           .instr_rvalid_i    ( instr_rvalid_i              ),
152                           .instr_rdata_i     ( instr_rdata_i               ),
153                           .instr_err_i       ( instr_err_i                 ),
154                           .instr_pmp_err_i   ( instr_pmp_err_i             ),
155                     
156                           // Prefetch Buffer Status
157                           .busy_o            ( prefetch_busy               )
158                       );
159                     
160                     
161                       // offset initialization state
162                       always_ff @(posedge clk_i or negedge rst_ni) begin
163        1/1              if (!rst_ni) begin
164        1/1                offset_in_init_q <= 1'b1;
165                         end else begin
166        1/1                offset_in_init_q <= offset_in_init_d;
167                         end
168                       end
169                     
170                       // offset initialization related transition logic
171                       always_comb begin
172        1/1              offset_in_init_d = offset_in_init_q;
173                     
174        1/1              fetch_ready      = 1'b0;
175        1/1              branch_req       = 1'b0;
176        1/1              have_instr       = 1'b0;
177                     
178        1/1              if (offset_in_init_q) begin
179                           // no valid instruction data for ID stage, assume aligned
180        1/1                if (req_i) begin
181        1/1                  branch_req       = 1'b1;
182        1/1                  offset_in_init_d = 1'b0;
183                           end
                        MISSING_ELSE
184                         end else begin
185                           // an instruction is ready for ID stage
186        1/1                if (fetch_valid) begin
187        1/1                  have_instr = 1'b1;
188                     
189        1/1                  if (req_i && if_id_pipe_reg_we) begin
190        1/1                    fetch_ready      = 1'b1;
191        1/1                    offset_in_init_d = 1'b0;
192                             end
                        MISSING_ELSE
193                           end
                        MISSING_ELSE
194                         end
195                     
196                         // take care of jumps and branches
197        1/1              if (pc_set_i) begin
198        1/1                have_instr       = 1'b0;
199                     
200                           // switch to new PC from ID stage
201        1/1                branch_req       = 1'b1;
202        1/1                offset_in_init_d = 1'b0;
203                         end
                        MISSING_ELSE
204                       end
205                     
206                       assign pc_if_o      = fetch_addr;
207                       assign if_busy_o    = prefetch_busy;
208                       assign perf_imiss_o = ~fetch_valid | branch_req;
209                     
210                       // compressed instruction decoding, or more precisely compressed instruction
211                       // expander
212                       //
213                       // since it does not matter where we decompress instructions, we do it here
214                       // to ease timing closure
215                       logic [31:0] instr_decompressed;
216                       logic        illegal_c_insn;
217                       logic        instr_is_compressed_int;
218                     
219                       ibex_compressed_decoder compressed_decoder_i (
220                           .clk_i           ( clk_i                   ),
221                           .rst_ni          ( rst_ni                  ),
222                           .instr_i         ( fetch_rdata             ),
223                           .instr_o         ( instr_decompressed      ),
224                           .is_compressed_o ( instr_is_compressed_int ),
225                           .illegal_instr_o ( illegal_c_insn          )
226                       );
227                     
228                       // IF-ID pipeline registers, frozen when the ID stage is stalled
229                       assign if_id_pipe_reg_we = have_instr & id_in_ready_i;
230        1/1          
231        1/1            always_ff @(posedge clk_i or negedge rst_ni) begin : if_id_pipeline_regs
232        1/1              if (!rst_ni) begin
233        1/1                instr_new_id_o             <= 1'b0;
234        1/1                instr_valid_id_o           <= 1'b0;
235        1/1                instr_rdata_id_o           <= '0;
236        1/1                instr_fetch_err_o          <= '0;
237        1/1                instr_rdata_c_id_o         <= '0;
238        1/1                instr_is_compressed_id_o   <= 1'b0;
239                           illegal_c_insn_id_o        <= 1'b0;
240        1/1                pc_id_o                    <= '0;
241        1/1              end else begin
242        1/1                instr_new_id_o             <= if_id_pipe_reg_we;
243        1/1                if (if_id_pipe_reg_we) begin
244        1/1                  instr_valid_id_o         <= 1'b1;
245        1/1                  instr_rdata_id_o         <= instr_decompressed;
246        1/1                  instr_fetch_err_o        <= fetch_err;
247        1/1                  instr_rdata_c_id_o       <= fetch_rdata[15:0];
248        1/1                  instr_is_compressed_id_o <= instr_is_compressed_int;
249        1/1                  illegal_c_insn_id_o      <= illegal_c_insn;
250        1/1                  pc_id_o                  <= pc_if_o;
251                           end else if (instr_valid_clear_i) begin
                        MISSING_ELSE

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_if_stage
         Line No. Total Covered Percent 
Branches          24    22      91.67   
CASE     107      5     4       80.00   
CASE     118      6     5       83.33   
IF       163      2     2       100.00  
IF       178      5     5       100.00  
IF       197      2     2       100.00  
IF       230      4     4       100.00  


107            unique case (exc_pc_mux_i)
                      -1-  
108              EXC_PC_EXC:     exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
                 ==>
109              EXC_PC_IRQ:     exc_pc = { csr_mtvec_i[31:8], 1'b0, irq_id[4:0], 2'b00 };
                 ==>
110              EXC_PC_DBD:     exc_pc = DmHaltAddr;
                 ==>
111              EXC_PC_DBG_EXC: exc_pc = DmExceptionAddr;
                 ==>
112              default:        exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
                 ==>

Branches:

-1-             Status      
EXC_PC_EXC      Covered     
EXC_PC_IRQ      Covered     
EXC_PC_DBD      Covered     
EXC_PC_DBG_EXC  Covered     
default         Not Covered 


118            unique case (pc_mux_i)
                      -1-  
119              PC_BOOT: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
                 ==>
120              PC_JUMP: fetch_addr_n = jump_target_ex_i;
                 ==>
121              PC_EXC:  fetch_addr_n = exc_pc;                       // set PC to exception handler
                 ==>
122              PC_ERET: fetch_addr_n = csr_mepc_i;                   // restore PC when returning from EXC
                 ==>
123              PC_DRET: fetch_addr_n = csr_depc_i;
                 ==>
124              default: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
                 ==>

Branches:

-1-      Status      
PC_BOOT  Covered     
PC_JUMP  Covered     
PC_EXC   Covered     
PC_ERET  Covered     
PC_DRET  Covered     
default  Not Covered 


163            if (!rst_ni) begin
               -1-  
164              offset_in_init_q <= 1'b1;
                 ==>
165            end else begin
166              offset_in_init_q <= offset_in_init_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


178            if (offset_in_init_q) begin
               -1-  
179              // no valid instruction data for ID stage, assume aligned
180              if (req_i) begin
                 -2-  
181                branch_req       = 1'b1;
                   ==>
182                offset_in_init_d = 1'b0;
183              end
                 MISSING_ELSE
                 ==>
184            end else begin
185              // an instruction is ready for ID stage
186              if (fetch_valid) begin
                 -3-  
187                have_instr = 1'b1;
188        
189                if (req_i && if_id_pipe_reg_we) begin
                   -4-             
190                  fetch_ready      = 1'b1;
                     ==>
191                  offset_in_init_d = 1'b0;
192                end
                   MISSING_ELSE
                   ==>
193              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- Status  
1   1   -   -   Covered 
1   0   -   -   Covered 
0   -   1   1   Covered 
0   -   1   0   Covered 
0   -   0   -   Covered 


197            if (pc_set_i) begin
               -1-  
198              have_instr       = 1'b0;
                 ==>
199        
200              // switch to new PC from ID stage
201              branch_req       = 1'b1;
202              offset_in_init_d = 1'b0;
203            end
               MISSING_ELSE
               ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


230        
           -1-
231          always_ff @(posedge clk_i or negedge rst_ni) begin : if_id_pipeline_regs
             ==>
232            if (!rst_ni) begin
233              instr_new_id_o             <= 1'b0;
234              instr_valid_id_o           <= 1'b0;
235              instr_rdata_id_o           <= '0;
236              instr_fetch_err_o          <= '0;
237              instr_rdata_c_id_o         <= '0;
238              instr_is_compressed_id_o   <= 1'b0;
239              illegal_c_insn_id_o        <= 1'b0;
240              pc_id_o                    <= '0;
241            end else begin
               -2-              
242              instr_new_id_o             <= if_id_pipe_reg_we;
                 ==>
243              if (if_id_pipe_reg_we) begin
244                instr_valid_id_o         <= 1'b1;
245                instr_rdata_id_o         <= instr_decompressed;
246                instr_fetch_err_o        <= fetch_err;
247                instr_rdata_c_id_o       <= fetch_rdata[15:0];
248                instr_is_compressed_id_o <= instr_is_compressed_int;
249                illegal_c_insn_id_o      <= illegal_c_insn;
                   -3-                                           
250                pc_id_o                  <= pc_if_o;
                   ==>
251              end else if (instr_valid_clear_i) begin
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status  
1   -   -   Covered 
0   1   -   Covered 
0   0   1   Covered 
0   0   0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_if_stage
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       4     4         100.00  4                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            4     4         100.00  4                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name         Attempts  Real Successes Failures Incomplete 
unnamed$$_10 159095193 159002193      0        0          
unnamed$$_11 159095193 1845           0        0          
unnamed$$_12 159095193 81863018       0        0          
unnamed$$_13 159095193 81863018       0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.if_stage_i(x)
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 100.00 


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME          
 95.96  96.23 --     --      91.67 100.00 ibex_if_stage 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME        
 98.10  99.07 --     --      97.14 --     u_ibex_core 


Subtrees :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                    
100.00 100.00 --     --     100.00 --     compressed_decoder_i(x) 
100.00 100.00 --     --     100.00 100.00 prefetch_buffer_i       



-------------------------------------------------------------------------------
Line Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.if_stage_i(x)

             Line No.   Total   Covered  Percent
TOTAL                       51       51   100.00
ALWAYS            107        5        5   100.00
ALWAYS            118        6        6   100.00
ALWAYS            163        3        3   100.00
ALWAYS            172       17       17   100.00
ALWAYS            230       20       20   100.00

106                       always_comb begin : exc_pc_mux
107        1/1              unique case (exc_pc_mux_i)
108        1/1                EXC_PC_EXC:     exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
109        1/1                EXC_PC_IRQ:     exc_pc = { csr_mtvec_i[31:8], 1'b0, irq_id[4:0], 2'b00 };
110        1/1                EXC_PC_DBD:     exc_pc = DmHaltAddr;
111        1/1                EXC_PC_DBG_EXC: exc_pc = DmExceptionAddr;
112        excluded           default:        exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
113                         endcase
114                       end
115                     
116                       // fetch address selection mux
117                       always_comb begin : fetch_addr_mux
118        1/1              unique case (pc_mux_i)
119        1/1                PC_BOOT: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
120        1/1                PC_JUMP: fetch_addr_n = jump_target_ex_i;
121        1/1                PC_EXC:  fetch_addr_n = exc_pc;                       // set PC to exception handler
122        1/1                PC_ERET: fetch_addr_n = csr_mepc_i;                   // restore PC when returning from EXC
123        1/1                PC_DRET: fetch_addr_n = csr_depc_i;
124        excluded           default: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
125                         endcase
126                       end
127                     
128                       // tell CS register file to initialize mtvec on boot
129                       assign csr_mtvec_init_o = (pc_mux_i == PC_BOOT) & pc_set_i;
130                     
131                       // prefetch buffer, caches a fixed number of instructions
132                       ibex_prefetch_buffer prefetch_buffer_i (
133                           .clk_i             ( clk_i                       ),
134                           .rst_ni            ( rst_ni                      ),
135                     
136                           .req_i             ( req_i                       ),
137                     
138                           .branch_i          ( branch_req                  ),
139                           .addr_i            ( {fetch_addr_n[31:1], 1'b0}  ),
140                     
141                           .ready_i           ( fetch_ready                 ),
142                           .valid_o           ( fetch_valid                 ),
143                           .rdata_o           ( fetch_rdata                 ),
144                           .addr_o            ( fetch_addr                  ),
145                           .err_o             ( fetch_err                   ),
146                     
147                           // goes to instruction memory / instruction cache
148                           .instr_req_o       ( instr_req_o                 ),
149                           .instr_addr_o      ( instr_addr_o                ),
150                           .instr_gnt_i       ( instr_gnt_i                 ),
151                           .instr_rvalid_i    ( instr_rvalid_i              ),
152                           .instr_rdata_i     ( instr_rdata_i               ),
153                           .instr_err_i       ( instr_err_i                 ),
154                           .instr_pmp_err_i   ( instr_pmp_err_i             ),
155                     
156                           // Prefetch Buffer Status
157                           .busy_o            ( prefetch_busy               )
158                       );
159                     
160                     
161                       // offset initialization state
162                       always_ff @(posedge clk_i or negedge rst_ni) begin
163        1/1              if (!rst_ni) begin
164        1/1                offset_in_init_q <= 1'b1;
165                         end else begin
166        1/1                offset_in_init_q <= offset_in_init_d;
167                         end
168                       end
169                     
170                       // offset initialization related transition logic
171                       always_comb begin
172        1/1              offset_in_init_d = offset_in_init_q;
173                     
174        1/1              fetch_ready      = 1'b0;
175        1/1              branch_req       = 1'b0;
176        1/1              have_instr       = 1'b0;
177                     
178        1/1              if (offset_in_init_q) begin
179                           // no valid instruction data for ID stage, assume aligned
180        1/1                if (req_i) begin
181        1/1                  branch_req       = 1'b1;
182        1/1                  offset_in_init_d = 1'b0;
183                           end
                        MISSING_ELSE
184                         end else begin
185                           // an instruction is ready for ID stage
186        1/1                if (fetch_valid) begin
187        1/1                  have_instr = 1'b1;
188                     
189        1/1                  if (req_i && if_id_pipe_reg_we) begin
190        1/1                    fetch_ready      = 1'b1;
191        1/1                    offset_in_init_d = 1'b0;
192                             end
                        MISSING_ELSE
193                           end
                        MISSING_ELSE
194                         end
195                     
196                         // take care of jumps and branches
197        1/1              if (pc_set_i) begin
198        1/1                have_instr       = 1'b0;
199                     
200                           // switch to new PC from ID stage
201        1/1                branch_req       = 1'b1;
202        1/1                offset_in_init_d = 1'b0;
203                         end
                        MISSING_ELSE
204                       end
205                     
206                       assign pc_if_o      = fetch_addr;
207                       assign if_busy_o    = prefetch_busy;
208                       assign perf_imiss_o = ~fetch_valid | branch_req;
209                     
210                       // compressed instruction decoding, or more precisely compressed instruction
211                       // expander
212                       //
213                       // since it does not matter where we decompress instructions, we do it here
214                       // to ease timing closure
215                       logic [31:0] instr_decompressed;
216                       logic        illegal_c_insn;
217                       logic        instr_is_compressed_int;
218                     
219                       ibex_compressed_decoder compressed_decoder_i (
220                           .clk_i           ( clk_i                   ),
221                           .rst_ni          ( rst_ni                  ),
222                           .instr_i         ( fetch_rdata             ),
223                           .instr_o         ( instr_decompressed      ),
224                           .is_compressed_o ( instr_is_compressed_int ),
225                           .illegal_instr_o ( illegal_c_insn          )
226                       );
227                     
228                       // IF-ID pipeline registers, frozen when the ID stage is stalled
229                       assign if_id_pipe_reg_we = have_instr & id_in_ready_i;
230        1/1          
231        1/1            always_ff @(posedge clk_i or negedge rst_ni) begin : if_id_pipeline_regs
232        1/1              if (!rst_ni) begin
233        1/1                instr_new_id_o             <= 1'b0;
234        1/1                instr_valid_id_o           <= 1'b0;
235        1/1                instr_rdata_id_o           <= '0;
236        1/1                instr_fetch_err_o          <= '0;
237        1/1                instr_rdata_c_id_o         <= '0;
238        1/1                instr_is_compressed_id_o   <= 1'b0;
239                           illegal_c_insn_id_o        <= 1'b0;
240        1/1                pc_id_o                    <= '0;
241        1/1              end else begin
242        1/1                instr_new_id_o             <= if_id_pipe_reg_we;
243        1/1                if (if_id_pipe_reg_we) begin
244        1/1                  instr_valid_id_o         <= 1'b1;
245        1/1                  instr_rdata_id_o         <= instr_decompressed;
246        1/1                  instr_fetch_err_o        <= fetch_err;
247        1/1                  instr_rdata_c_id_o       <= fetch_rdata[15:0];
248        1/1                  instr_is_compressed_id_o <= instr_is_compressed_int;
249        1/1                  illegal_c_insn_id_o      <= illegal_c_insn;
250        1/1                  pc_id_o                  <= pc_if_o;
251                           end else if (instr_valid_clear_i) begin
                        MISSING_ELSE

-------------------------------------------------------------------------------
Branch Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.if_stage_i(x)
         Line No. Total Covered Percent 
Branches          22    22      100.00  
CASE     107      4     4       100.00  
CASE     118      5     5       100.00  
IF       163      2     2       100.00  
IF       178      5     5       100.00  
IF       197      2     2       100.00  
IF       230      4     4       100.00  


107            unique case (exc_pc_mux_i)
                      -1-  
108              EXC_PC_EXC:     exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
                 ==>
109              EXC_PC_IRQ:     exc_pc = { csr_mtvec_i[31:8], 1'b0, irq_id[4:0], 2'b00 };
                 ==>
110              EXC_PC_DBD:     exc_pc = DmHaltAddr;
                 ==>
111              EXC_PC_DBG_EXC: exc_pc = DmExceptionAddr;
                 ==>
112              default:        exc_pc = { csr_mtvec_i[31:8], 8'h00                    };
                 ==> (Excluded)

Branches:

-1-             Status   
EXC_PC_EXC      Covered  
EXC_PC_IRQ      Covered  
EXC_PC_DBD      Covered  
EXC_PC_DBG_EXC  Covered  
default         Excluded 


118            unique case (pc_mux_i)
                      -1-  
119              PC_BOOT: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
                 ==>
120              PC_JUMP: fetch_addr_n = jump_target_ex_i;
                 ==>
121              PC_EXC:  fetch_addr_n = exc_pc;                       // set PC to exception handler
                 ==>
122              PC_ERET: fetch_addr_n = csr_mepc_i;                   // restore PC when returning from EXC
                 ==>
123              PC_DRET: fetch_addr_n = csr_depc_i;
                 ==>
124              default: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };
                 ==> (Excluded)

Branches:

-1-      Status   
PC_BOOT  Covered  
PC_JUMP  Covered  
PC_EXC   Covered  
PC_ERET  Covered  
PC_DRET  Covered  
default  Excluded 


163            if (!rst_ni) begin
               -1-  
164              offset_in_init_q <= 1'b1;
                 ==>
165            end else begin
166              offset_in_init_q <= offset_in_init_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


178            if (offset_in_init_q) begin
               -1-  
179              // no valid instruction data for ID stage, assume aligned
180              if (req_i) begin
                 -2-  
181                branch_req       = 1'b1;
                   ==>
182                offset_in_init_d = 1'b0;
183              end
                 MISSING_ELSE
                 ==>
184            end else begin
185              // an instruction is ready for ID stage
186              if (fetch_valid) begin
                 -3-  
187                have_instr = 1'b1;
188        
189                if (req_i && if_id_pipe_reg_we) begin
                   -4-             
190                  fetch_ready      = 1'b1;
                     ==>
191                  offset_in_init_d = 1'b0;
192                end
                   MISSING_ELSE
                   ==>
193              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- Status  
1   1   -   -   Covered 
1   0   -   -   Covered 
0   -   1   1   Covered 
0   -   1   0   Covered 
0   -   0   -   Covered 


197            if (pc_set_i) begin
               -1-  
198              have_instr       = 1'b0;
                 ==>
199        
200              // switch to new PC from ID stage
201              branch_req       = 1'b1;
202              offset_in_init_d = 1'b0;
203            end
               MISSING_ELSE
               ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


230        
           -1-
231          always_ff @(posedge clk_i or negedge rst_ni) begin : if_id_pipeline_regs
             ==>
232            if (!rst_ni) begin
233              instr_new_id_o             <= 1'b0;
234              instr_valid_id_o           <= 1'b0;
235              instr_rdata_id_o           <= '0;
236              instr_fetch_err_o          <= '0;
237              instr_rdata_c_id_o         <= '0;
238              instr_is_compressed_id_o   <= 1'b0;
239              illegal_c_insn_id_o        <= 1'b0;
240              pc_id_o                    <= '0;
241            end else begin
               -2-              
242              instr_new_id_o             <= if_id_pipe_reg_we;
                 ==>
243              if (if_id_pipe_reg_we) begin
244                instr_valid_id_o         <= 1'b1;
245                instr_rdata_id_o         <= instr_decompressed;
246                instr_fetch_err_o        <= fetch_err;
247                instr_rdata_c_id_o       <= fetch_rdata[15:0];
248                instr_is_compressed_id_o <= instr_is_compressed_int;
249                illegal_c_insn_id_o      <= illegal_c_insn;
                   -3-                                           
250                pc_id_o                  <= pc_if_o;
                   ==>
251              end else if (instr_valid_clear_i) begin
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status  
1   -   -   Covered 
0   1   -   Covered 
0   0   1   Covered 
0   0   0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.if_stage_i(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       4     4         100.00  4                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            4     4         100.00  4                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name         Attempts  Real Successes Failures Incomplete 
unnamed$$_10 159095193 159002193      0        0          
unnamed$$_11 159095193 1845           0        0          
unnamed$$_12 159095193 81863018       0        0          
unnamed$$_13 159095193 81863018       0        0          


===============================================================================
Module : ibex_alu
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 96.23  96.30 --     --      96.15 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_alu.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                                 
 98.15  96.30 --     --     100.00 --     core_ibex_tb_top.dut.u_ibex_core.ex_block_i.alu_i(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_alu

             Line No.   Total   Covered  Percent
TOTAL                       27       26    96.30
ALWAYS             45        4        4   100.00
ALWAYS            125        4        4   100.00
ALWAYS            143        3        3   100.00
ALWAYS            166        7        7   100.00
ALWAYS            186        9        8    88.89

44                        always_comb begin
45         1/1              adder_op_b_negate = 1'b0;
46                      
47         1/1              unique case (operator_i)
48                            // Adder OPs
49                            ALU_SUB,
50                      
51                            // Comparator OPs
52                            ALU_EQ,   ALU_NE,
53                            ALU_GE,   ALU_GEU,
54                            ALU_LT,   ALU_LTU,
55         1/1                ALU_SLT,  ALU_SLTU: adder_op_b_negate = 1'b1;
56                      
57         1/1                default:;
58                          endcase
59                        end
60                      
61                        // prepare operand a
62                        assign adder_in_a    = multdiv_en_i ? multdiv_operand_a_i : {operand_a_i,1'b1};
63                      
64                        // prepare operand b
65                        assign operand_b_neg = {operand_b_i,1'b0} ^ {33{adder_op_b_negate}};
66                        assign adder_in_b    = multdiv_en_i ? multdiv_operand_b_i : operand_b_neg ;
67                      
68                        // actual adder
69                        assign adder_result_ext_o = $unsigned(adder_in_a) + $unsigned(adder_in_b);
70                      
71                        assign adder_result       = adder_result_ext_o[32:1];
72                      
73                        assign adder_result_o     = adder_result;
74                      
75                        ///////////
76                        // Shift //
77                        ///////////
78                      
79                        logic        shift_left;         // should we shift left
80                        logic        shift_arithmetic;
81                      
82                        logic  [4:0] shift_amt;          // amount of shift, to the right
83                        logic [31:0] shift_op_a;         // input of the shifter
84                        logic [31:0] shift_result;
85                        logic [31:0] shift_right_result;
86                        logic [31:0] shift_left_result;
87                      
88                        assign shift_amt = operand_b_i[4:0];
89                      
90                        assign shift_left = (operator_i == ALU_SLL);
91                      
92                        assign shift_arithmetic = (operator_i == ALU_SRA);
93                      
94                        // choose the bit reversed or the normal input for shift operand a
95                        assign shift_op_a    = shift_left ? operand_a_rev : operand_a_i;
96                      
97                        // right shifts, we let the synthesizer optimize this
98                        logic [32:0] shift_op_a_32;
99                        assign shift_op_a_32 = {shift_arithmetic & shift_op_a[31], shift_op_a};
100                     
101                       // The MSB of shift_right_result_ext can safely be ignored. We just extend the input to always
102                       // do arithmetic shifts.
103                       logic signed [32:0] shift_right_result_signed;
104                       logic        [32:0] shift_right_result_ext;
105                       assign shift_right_result_signed = $signed(shift_op_a_32) >>> shift_amt[4:0];
106                       assign shift_right_result_ext    = $unsigned(shift_right_result_signed);
107                       assign shift_right_result        = shift_right_result_ext[31:0];
108                     
109                       // bit reverse the shift_right_result for left shifts
110                       for (genvar j = 0; j < 32; j++) begin : gen_rev_shift_right_result
111                         assign shift_left_result[j] = shift_right_result[31-j];
112                       end
113                     
114                       assign shift_result = shift_left ? shift_left_result : shift_right_result;
115                     
116                       ////////////////
117                       // Comparison //
118                       ////////////////
119                     
120                       logic is_equal;
121                       logic is_greater_equal;  // handles both signed and unsigned forms
122                       logic cmp_signed;
123                     
124                       always_comb begin
125        1/1              cmp_signed = 1'b0;
126                     
127        1/1              unique case (operator_i)
128                           ALU_GE,
129                           ALU_LT,
130                           ALU_SLT: begin
131        1/1                  cmp_signed = 1'b1;
132                           end
133                     
134        1/1                default:;
135                         endcase
136                       end
137                     
138                       assign is_equal = (adder_result == 32'b0);
139                       assign is_equal_result_o = is_equal;
140                     
141                       // Is greater equal
142                       always_comb begin
143        1/1              if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin
144        1/1                is_greater_equal = (adder_result[31] == 1'b0);
145                         end else begin
146        1/1                is_greater_equal = operand_a_i[31] ^ (cmp_signed);
147                         end
148                       end
149                     
150                       // GTE unsigned:
151                       // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
152                       // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
153                       // (a[31] == 1 && b[31] == 0) => 1
154                       // (a[31] == 0 && b[31] == 1) => 0
155                     
156                       // GTE signed:
157                       // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
158                       // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
159                       // (a[31] == 1 && b[31] == 0) => 0
160                       // (a[31] == 0 && b[31] == 1) => 1
161                     
162                       // generate comparison result
163                       logic cmp_result;
164                     
165                       always_comb begin
166        1/1              cmp_result = is_equal;
167                     
168        1/1              unique case (operator_i)
169        1/1                ALU_EQ:            cmp_result =  is_equal;
170        1/1                ALU_NE:            cmp_result = ~is_equal;
171        1/1                ALU_GE,  ALU_GEU:  cmp_result = is_greater_equal;
172                           ALU_LT,  ALU_LTU,
173        1/1                ALU_SLT, ALU_SLTU: cmp_result = ~is_greater_equal;
174                     
175        1/1                default:;
176                         endcase
177                       end
178                     
179                       assign comparison_result_o = cmp_result;
180                     
181                       ////////////////
182                       // Result mux //
183                       ////////////////
184                     
185                       always_comb begin
186        1/1              result_o   = '0;
187                     
188        1/1              unique case (operator_i)
189                           // Standard Operations
190        1/1                ALU_AND:  result_o = operand_a_i & operand_b_i;
191        1/1                ALU_OR:   result_o = operand_a_i | operand_b_i;
192        1/1                ALU_XOR:  result_o = operand_a_i ^ operand_b_i;
193                     
194                           // Adder Operations
195        1/1                ALU_ADD, ALU_SUB: result_o = adder_result;
196                     
197                           // Shift Operations
198                           ALU_SLL,
199        1/1                ALU_SRL, ALU_SRA: result_o = shift_result;
200                     
201                           // Comparison Operations
202                           ALU_EQ,   ALU_NE,
203                           ALU_GE,   ALU_GEU,
204                           ALU_LT,   ALU_LTU,
205        1/1                ALU_SLT,  ALU_SLTU: result_o = {31'h0,cmp_result};
206                     
207        0/1     ==>        default:;

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_alu
         Line No. Total Covered Percent 
Branches          26    25      96.15   
TERNARY  62       2     2       100.00  
TERNARY  66       2     2       100.00  
TERNARY  95       2     2       100.00  
TERNARY  114      2     2       100.00  
CASE     47       2     2       100.00  
CASE     127      2     2       100.00  
IF       143      2     2       100.00  
CASE     168      5     5       100.00  
CASE     188      7     6       85.71   


62           assign adder_in_a    = multdiv_en_i ? multdiv_operand_a_i : {operand_a_i,1'b1};
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


66           assign adder_in_b    = multdiv_en_i ? multdiv_operand_b_i : operand_b_neg ;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


95           assign shift_op_a    = shift_left ? operand_a_rev : operand_a_i;
                                               -1-  
                                               ==>  
                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


114          assign shift_result = shift_left ? shift_left_result : shift_right_result;
                                              -1-  
                                              ==>  
                                              ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


47             unique case (operator_i)
                      -1-  
48               // Adder OPs
49               ALU_SUB,
50         
51               // Comparator OPs
52               ALU_EQ,   ALU_NE,
53               ALU_GE,   ALU_GEU,
54               ALU_LT,   ALU_LTU,
55               ALU_SLT,  ALU_SLTU: adder_op_b_negate = 1'b1;
                 ==>
56         
57               default:;
                 ==>

Branches:

-1-                                                                   Status  
ALU_SUB ALU_EQ ALU_NE ALU_GE ALU_GEU ALU_LT ALU_LTU ALU_SLT ALU_SLTU  Covered 
default                                                               Covered 


127            unique case (operator_i)
                      -1-  
128              ALU_GE,
129              ALU_LT,
130              ALU_SLT: begin
131                cmp_signed = 1'b1;
                   ==>
132              end
133        
134              default:;
                 ==>

Branches:

-1-                    Status  
ALU_GE ALU_LT ALU_SLT  Covered 
default                Covered 


143            if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin
               -1-  
144              is_greater_equal = (adder_result[31] == 1'b0);
                 ==>
145            end else begin
146              is_greater_equal = operand_a_i[31] ^ (cmp_signed);
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


168            unique case (operator_i)
                      -1-  
169              ALU_EQ:            cmp_result =  is_equal;
                 ==>
170              ALU_NE:            cmp_result = ~is_equal;
                 ==>
171              ALU_GE,  ALU_GEU:  cmp_result = is_greater_equal;
                 ==>
172              ALU_LT,  ALU_LTU,
173              ALU_SLT, ALU_SLTU: cmp_result = ~is_greater_equal;
                 ==>
174        
175              default:;
                 ==>

Branches:

-1-                              Status  
ALU_EQ                           Covered 
ALU_NE                           Covered 
ALU_GE ALU_GEU                   Covered 
ALU_LT ALU_LTU ALU_SLT ALU_SLTU  Covered 
default                          Covered 


188            unique case (operator_i)
                      -1-  
189              // Standard Operations
190              ALU_AND:  result_o = operand_a_i & operand_b_i;
                 ==>
191              ALU_OR:   result_o = operand_a_i | operand_b_i;
                 ==>
192              ALU_XOR:  result_o = operand_a_i ^ operand_b_i;
                 ==>
193        
194              // Adder Operations
195              ALU_ADD, ALU_SUB: result_o = adder_result;
                 ==>
196        
197              // Shift Operations
198              ALU_SLL,
199              ALU_SRL, ALU_SRA: result_o = shift_result;
                 ==>
200        
201              // Comparison Operations
202              ALU_EQ,   ALU_NE,
203              ALU_GE,   ALU_GEU,
204              ALU_LT,   ALU_LTU,
205              ALU_SLT,  ALU_SLTU: result_o = {31'h0,cmp_result};
                 ==>
206        
207              default:;
                 ==>

Branches:

-1-                                                           Status      
ALU_AND                                                       Covered     
ALU_OR                                                        Covered     
ALU_XOR                                                       Covered     
ALU_ADD ALU_SUB                                               Covered     
ALU_SLL ALU_SRL ALU_SRA                                       Covered     
ALU_EQ ALU_NE ALU_GE ALU_GEU ALU_LT ALU_LTU ALU_SLT ALU_SLTU  Covered     
default                                                       Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.ex_block_i.alu_i(x)
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 98.15  96.30 --     --     100.00 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 98.15  96.30 --     --     100.00 --     


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME     
 96.23  96.30 --     --      96.15 --     ibex_alu 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME       
100.00 --     --     --     100.00 --     ex_block_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.ex_block_i.alu_i(x)

             Line No.   Total   Covered  Percent
TOTAL                       27       26    96.30
ALWAYS             45        4        4   100.00
ALWAYS            125        4        4   100.00
ALWAYS            143        3        3   100.00
ALWAYS            166        7        7   100.00
ALWAYS            186        9        8    88.89

44                        always_comb begin
45         1/1              adder_op_b_negate = 1'b0;
46                      
47         1/1              unique case (operator_i)
48                            // Adder OPs
49                            ALU_SUB,
50                      
51                            // Comparator OPs
52                            ALU_EQ,   ALU_NE,
53                            ALU_GE,   ALU_GEU,
54                            ALU_LT,   ALU_LTU,
55         1/1                ALU_SLT,  ALU_SLTU: adder_op_b_negate = 1'b1;
56                      
57         1/1                default:;
58                          endcase
59                        end
60                      
61                        // prepare operand a
62                        assign adder_in_a    = multdiv_en_i ? multdiv_operand_a_i : {operand_a_i,1'b1};
63                      
64                        // prepare operand b
65                        assign operand_b_neg = {operand_b_i,1'b0} ^ {33{adder_op_b_negate}};
66                        assign adder_in_b    = multdiv_en_i ? multdiv_operand_b_i : operand_b_neg ;
67                      
68                        // actual adder
69                        assign adder_result_ext_o = $unsigned(adder_in_a) + $unsigned(adder_in_b);
70                      
71                        assign adder_result       = adder_result_ext_o[32:1];
72                      
73                        assign adder_result_o     = adder_result;
74                      
75                        ///////////
76                        // Shift //
77                        ///////////
78                      
79                        logic        shift_left;         // should we shift left
80                        logic        shift_arithmetic;
81                      
82                        logic  [4:0] shift_amt;          // amount of shift, to the right
83                        logic [31:0] shift_op_a;         // input of the shifter
84                        logic [31:0] shift_result;
85                        logic [31:0] shift_right_result;
86                        logic [31:0] shift_left_result;
87                      
88                        assign shift_amt = operand_b_i[4:0];
89                      
90                        assign shift_left = (operator_i == ALU_SLL);
91                      
92                        assign shift_arithmetic = (operator_i == ALU_SRA);
93                      
94                        // choose the bit reversed or the normal input for shift operand a
95                        assign shift_op_a    = shift_left ? operand_a_rev : operand_a_i;
96                      
97                        // right shifts, we let the synthesizer optimize this
98                        logic [32:0] shift_op_a_32;
99                        assign shift_op_a_32 = {shift_arithmetic & shift_op_a[31], shift_op_a};
100                     
101                       // The MSB of shift_right_result_ext can safely be ignored. We just extend the input to always
102                       // do arithmetic shifts.
103                       logic signed [32:0] shift_right_result_signed;
104                       logic        [32:0] shift_right_result_ext;
105                       assign shift_right_result_signed = $signed(shift_op_a_32) >>> shift_amt[4:0];
106                       assign shift_right_result_ext    = $unsigned(shift_right_result_signed);
107                       assign shift_right_result        = shift_right_result_ext[31:0];
108                     
109                       // bit reverse the shift_right_result for left shifts
110                       for (genvar j = 0; j < 32; j++) begin : gen_rev_shift_right_result
111                         assign shift_left_result[j] = shift_right_result[31-j];
112                       end
113                     
114                       assign shift_result = shift_left ? shift_left_result : shift_right_result;
115                     
116                       ////////////////
117                       // Comparison //
118                       ////////////////
119                     
120                       logic is_equal;
121                       logic is_greater_equal;  // handles both signed and unsigned forms
122                       logic cmp_signed;
123                     
124                       always_comb begin
125        1/1              cmp_signed = 1'b0;
126                     
127        1/1              unique case (operator_i)
128                           ALU_GE,
129                           ALU_LT,
130                           ALU_SLT: begin
131        1/1                  cmp_signed = 1'b1;
132                           end
133                     
134        1/1                default:;
135                         endcase
136                       end
137                     
138                       assign is_equal = (adder_result == 32'b0);
139                       assign is_equal_result_o = is_equal;
140                     
141                       // Is greater equal
142                       always_comb begin
143        1/1              if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin
144        1/1                is_greater_equal = (adder_result[31] == 1'b0);
145                         end else begin
146        1/1                is_greater_equal = operand_a_i[31] ^ (cmp_signed);
147                         end
148                       end
149                     
150                       // GTE unsigned:
151                       // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
152                       // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
153                       // (a[31] == 1 && b[31] == 0) => 1
154                       // (a[31] == 0 && b[31] == 1) => 0
155                     
156                       // GTE signed:
157                       // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
158                       // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
159                       // (a[31] == 1 && b[31] == 0) => 0
160                       // (a[31] == 0 && b[31] == 1) => 1
161                     
162                       // generate comparison result
163                       logic cmp_result;
164                     
165                       always_comb begin
166        1/1              cmp_result = is_equal;
167                     
168        1/1              unique case (operator_i)
169        1/1                ALU_EQ:            cmp_result =  is_equal;
170        1/1                ALU_NE:            cmp_result = ~is_equal;
171        1/1                ALU_GE,  ALU_GEU:  cmp_result = is_greater_equal;
172                           ALU_LT,  ALU_LTU,
173        1/1                ALU_SLT, ALU_SLTU: cmp_result = ~is_greater_equal;
174                     
175        1/1                default:;
176                         endcase
177                       end
178                     
179                       assign comparison_result_o = cmp_result;
180                     
181                       ////////////////
182                       // Result mux //
183                       ////////////////
184                     
185                       always_comb begin
186        1/1              result_o   = '0;
187                     
188        1/1              unique case (operator_i)
189                           // Standard Operations
190        1/1                ALU_AND:  result_o = operand_a_i & operand_b_i;
191        1/1                ALU_OR:   result_o = operand_a_i | operand_b_i;
192        1/1                ALU_XOR:  result_o = operand_a_i ^ operand_b_i;
193                     
194                           // Adder Operations
195        1/1                ALU_ADD, ALU_SUB: result_o = adder_result;
196                     
197                           // Shift Operations
198                           ALU_SLL,
199        1/1                ALU_SRL, ALU_SRA: result_o = shift_result;
200                     
201                           // Comparison Operations
202                           ALU_EQ,   ALU_NE,
203                           ALU_GE,   ALU_GEU,
204                           ALU_LT,   ALU_LTU,
205        1/1                ALU_SLT,  ALU_SLTU: result_o = {31'h0,cmp_result};
206                     
207        0/1     ==>        default:;

-------------------------------------------------------------------------------
Branch Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.ex_block_i.alu_i(x)
         Line No. Total Covered Percent 
Branches          25    25      100.00  
TERNARY  62       2     2       100.00  
TERNARY  66       2     2       100.00  
TERNARY  95       2     2       100.00  
TERNARY  114      2     2       100.00  
CASE     47       2     2       100.00  
CASE     127      2     2       100.00  
IF       143      2     2       100.00  
CASE     168      5     5       100.00  
CASE     188      6     6       100.00  


62           assign adder_in_a    = multdiv_en_i ? multdiv_operand_a_i : {operand_a_i,1'b1};
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


66           assign adder_in_b    = multdiv_en_i ? multdiv_operand_b_i : operand_b_neg ;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


95           assign shift_op_a    = shift_left ? operand_a_rev : operand_a_i;
                                               -1-  
                                               ==>  
                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


114          assign shift_result = shift_left ? shift_left_result : shift_right_result;
                                              -1-  
                                              ==>  
                                              ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


47             unique case (operator_i)
                      -1-  
48               // Adder OPs
49               ALU_SUB,
50         
51               // Comparator OPs
52               ALU_EQ,   ALU_NE,
53               ALU_GE,   ALU_GEU,
54               ALU_LT,   ALU_LTU,
55               ALU_SLT,  ALU_SLTU: adder_op_b_negate = 1'b1;
                 ==>
56         
57               default:;
                 ==>

Branches:

-1-                                                                   Status  
ALU_SUB ALU_EQ ALU_NE ALU_GE ALU_GEU ALU_LT ALU_LTU ALU_SLT ALU_SLTU  Covered 
default                                                               Covered 


127            unique case (operator_i)
                      -1-  
128              ALU_GE,
129              ALU_LT,
130              ALU_SLT: begin
131                cmp_signed = 1'b1;
                   ==>
132              end
133        
134              default:;
                 ==>

Branches:

-1-                    Status  
ALU_GE ALU_LT ALU_SLT  Covered 
default                Covered 


143            if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin
               -1-  
144              is_greater_equal = (adder_result[31] == 1'b0);
                 ==>
145            end else begin
146              is_greater_equal = operand_a_i[31] ^ (cmp_signed);
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


168            unique case (operator_i)
                      -1-  
169              ALU_EQ:            cmp_result =  is_equal;
                 ==>
170              ALU_NE:            cmp_result = ~is_equal;
                 ==>
171              ALU_GE,  ALU_GEU:  cmp_result = is_greater_equal;
                 ==>
172              ALU_LT,  ALU_LTU,
173              ALU_SLT, ALU_SLTU: cmp_result = ~is_greater_equal;
                 ==>
174        
175              default:;
                 ==>

Branches:

-1-                              Status  
ALU_EQ                           Covered 
ALU_NE                           Covered 
ALU_GE ALU_GEU                   Covered 
ALU_LT ALU_LTU ALU_SLT ALU_SLTU  Covered 
default                          Covered 


188            unique case (operator_i)
                      -1-  
189              // Standard Operations
190              ALU_AND:  result_o = operand_a_i & operand_b_i;
                 ==>
191              ALU_OR:   result_o = operand_a_i | operand_b_i;
                 ==>
192              ALU_XOR:  result_o = operand_a_i ^ operand_b_i;
                 ==>
193        
194              // Adder Operations
195              ALU_ADD, ALU_SUB: result_o = adder_result;
                 ==>
196        
197              // Shift Operations
198              ALU_SLL,
199              ALU_SRL, ALU_SRA: result_o = shift_result;
                 ==>
200        
201              // Comparison Operations
202              ALU_EQ,   ALU_NE,
203              ALU_GE,   ALU_GEU,
204              ALU_LT,   ALU_LTU,
205              ALU_SLT,  ALU_SLTU: result_o = {31'h0,cmp_result};
                 ==>
206        
207              default:;
                 ==> (Excluded)

Branches:

-1-                                                           Status   
ALU_AND                                                       Covered  
ALU_OR                                                        Covered  
ALU_XOR                                                       Covered  
ALU_ADD ALU_SUB                                               Covered  
ALU_SLL ALU_SRL ALU_SRA                                       Covered  
ALU_EQ ALU_NE ALU_GE ALU_GEU ALU_LT ALU_LTU ALU_SLT ALU_SLTU  Covered  
default                                                       Excluded 


===============================================================================
Module : ibex_load_store_unit
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 96.33  94.97 --     100.00  90.36 100.00 

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_load_store_unit.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                                  
100.00 100.00 --     100.00 100.00 100.00 core_ibex_tb_top.dut.u_ibex_core.load_store_unit_i(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_load_store_unit

             Line No.   Total   Covered  Percent
TOTAL                      159      151    94.97
ALWAYS             99       29       25    86.21
ALWAYS            157        6        6   100.00
ALWAYS            172        4        4   100.00
ALWAYS            181       10       10   100.00
ALWAYS            197        4        4   100.00
ALWAYS            206        6        5    83.33
ALWAYS            221       14       13    92.86
ALWAYS            260       14       13    92.86
ALWAYS            299        5        4    80.00
ALWAYS            318       58       58   100.00
ALWAYS            443        9        9   100.00

98                      
99         1/1            always_comb begin
100                         unique case (data_type_ex_i) // Data type 00 Word, 01 Half word, 11,10 byte
101        1/1                2'b00: begin // Writing a word
102        1/1                  if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
103        1/1                    unique case (data_offset)
104        1/1                      2'b00:   data_be = 4'b1111;
105        1/1                      2'b01:   data_be = 4'b1110;
106        1/1                      2'b10:   data_be = 4'b1100;
107        1/1                      2'b11:   data_be = 4'b1000;
108                                 default: data_be = 4'b1111;
109                               endcase // case (data_offset)
110        1/1                  end else begin // second part of misaligned transaction
111        1/1                    unique case (data_offset)
112        1/1                      2'b00:   data_be = 4'b0000; // this is not used, but included for completeness
113        1/1                      2'b01:   data_be = 4'b0001;
114        1/1                      2'b10:   data_be = 4'b0011;
115        0/1     ==>              2'b11:   data_be = 4'b0111;
116                                 default: data_be = 4'b1111;
117                               endcase // case (data_offset)
118                             end
119                           end
120                     
121        1/1                2'b01: begin // Writing a half word
122        1/1                  if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
123        1/1                    unique case (data_offset)
124        1/1                      2'b00:   data_be = 4'b0011;
125        1/1                      2'b01:   data_be = 4'b0110;
126        1/1                      2'b10:   data_be = 4'b1100;
127        0/1     ==>              2'b11:   data_be = 4'b1000;
128                                 default: data_be = 4'b1111;
129                               endcase // case (data_offset)
130        1/1                  end else begin // second part of misaligned transaction
131                               data_be = 4'b0001;
132                             end
133                           end
134                     
135                           2'b10,
136        1/1                2'b11: begin // Writing a byte
137        1/1                  unique case (data_offset)
138        1/1                    2'b00:   data_be = 4'b0001;
139        1/1                    2'b01:   data_be = 4'b0010;
140        1/1                    2'b10:   data_be = 4'b0100;
141        0/1     ==>            2'b11:   data_be = 4'b1000;
142                               default: data_be = 4'b1111;
143                             endcase // case (data_offset)
144                           end
145        0/1     ==>  
146                           default:     data_be = 4'b1111;
147                         endcase // case (data_type_ex_i)
148                       end
149                     
150                       /////////////////////
151                       // WData alignment //
152                       /////////////////////
153                     
154                       // prepare data to be written to the memory
155                       // we handle misaligned accesses, half word and byte accesses here
156                       always_comb begin
157        1/1              unique case (data_offset)
158        1/1                2'b00:   data_wdata =  data_wdata_ex_i[31:0];
159        1/1                2'b01:   data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};
160        1/1                2'b10:   data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};
161        1/1                2'b11:   data_wdata = {data_wdata_ex_i[ 7:0], data_wdata_ex_i[31: 8]};
162        1/1                default: data_wdata =  data_wdata_ex_i[31:0];
163                         endcase // case (data_offset)
164                       end
165                     
166                       /////////////////////
167                       // RData alignment //
168                       /////////////////////
169                     
170                       // register for unaligned rdata
171                       always_ff @(posedge clk_i or negedge rst_ni) begin
172        1/1              if (!rst_ni) begin
173        1/1                rdata_q <= '0;
174        1/1              end else if (rdata_update) begin
175        1/1                rdata_q <= data_rdata_i[31:8];
176                         end
                        MISSING_ELSE
177                       end
178                     
179                       // registers for transaction control
180                       always_ff @(posedge clk_i or negedge rst_ni) begin
181        1/1              if (!rst_ni) begin
182        1/1                rdata_offset_q  <= 2'h0;
183        1/1                data_type_q     <= 2'h0;
184        1/1                data_sign_ext_q <= 1'b0;
185        1/1                data_we_q       <= 1'b0;
186        1/1              end else if (ctrl_update) begin
187        1/1                rdata_offset_q  <= data_offset;
188        1/1                data_type_q     <= data_type_ex_i;
189        1/1                data_sign_ext_q <= data_sign_ext_ex_i;
190        1/1                data_we_q       <= data_we_ex_i;
191                         end
                        MISSING_ELSE
192                       end
193                     
194                       // Store last address for mtval + AGU for misaligned transactions.
195                       // Do not update in case of errors, mtval needs the (first) failing address
196                       always_ff @(posedge clk_i or negedge rst_ni) begin
197        1/1              if (!rst_ni) begin
198        1/1                addr_last_q <= '0;
199        1/1              end else if (addr_update) begin
200        1/1                addr_last_q <= data_addr;
201                         end
                        MISSING_ELSE
202                       end
203                     
204                       // take care of misaligned words
205                       always_comb begin
206        1/1              unique case (rdata_offset_q)
207        1/1                2'b00:   rdata_w_ext =  data_rdata_i[31:0];
208        1/1                2'b01:   rdata_w_ext = {data_rdata_i[ 7:0], rdata_q[31:8]};
209        1/1                2'b10:   rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};
210        1/1                2'b11:   rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};
211        0/1     ==>        default: rdata_w_ext =  data_rdata_i[31:0];
212                         endcase
213                       end
214                     
215                       ////////////////////
216                       // Sign extension //
217                       ////////////////////
218                     
219                       // sign extension for half words
220                       always_comb begin
221        1/1              unique case (rdata_offset_q)
222                           2'b00: begin
223        1/1                  if (!data_sign_ext_q) begin
224        1/1                    rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
225                             end else begin
226        1/1                    rdata_h_ext = {{16{data_rdata_i[15]}}, data_rdata_i[15:0]};
227                             end
228                           end
229                     
230                           2'b01: begin
231        1/1                  if (!data_sign_ext_q) begin
232        1/1                    rdata_h_ext = {16'h0000, data_rdata_i[23:8]};
233                             end else begin
234        1/1                    rdata_h_ext = {{16{data_rdata_i[23]}}, data_rdata_i[23:8]};
235                             end
236                           end
237                     
238                           2'b10: begin
239        1/1                  if (!data_sign_ext_q) begin
240        1/1                    rdata_h_ext = {16'h0000, data_rdata_i[31:16]};
241                             end else begin
242        1/1                    rdata_h_ext = {{16{data_rdata_i[31]}}, data_rdata_i[31:16]};
243                             end
244                           end
245                     
246                           2'b11: begin
247        1/1                  if (!data_sign_ext_q) begin
248        1/1                    rdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};
249                             end else begin
250        1/1                    rdata_h_ext = {{16{data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};
251                             end
252                           end
253                     
254        0/1     ==>        default: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
255                         endcase // case (rdata_offset_q)
256                       end
257                     
258                       // sign extension for bytes
259                       always_comb begin
260        1/1              unique case (rdata_offset_q)
261                           2'b00: begin
262        1/1                  if (!data_sign_ext_q) begin
263        1/1                    rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
264                             end else begin
265        1/1                    rdata_b_ext = {{24{data_rdata_i[7]}}, data_rdata_i[7:0]};
266                             end
267                           end
268                     
269                           2'b01: begin
270        1/1                  if (!data_sign_ext_q) begin
271        1/1                    rdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};
272                             end else begin
273        1/1                    rdata_b_ext = {{24{data_rdata_i[15]}}, data_rdata_i[15:8]};
274                             end
275                           end
276                     
277                           2'b10: begin
278        1/1                  if (!data_sign_ext_q) begin
279        1/1                    rdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};
280                             end else begin
281        1/1                    rdata_b_ext = {{24{data_rdata_i[23]}}, data_rdata_i[23:16]};
282                             end
283                           end
284                     
285                           2'b11: begin
286        1/1                  if (!data_sign_ext_q) begin
287        1/1                    rdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};
288                             end else begin
289        1/1                    rdata_b_ext = {{24{data_rdata_i[31]}}, data_rdata_i[31:24]};
290                             end
291                           end
292                     
293        0/1     ==>        default: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
294                         endcase // case (rdata_offset_q)
295                       end
296                     
297                       // select word, half word or byte sign extended version
298                       always_comb begin
299        1/1              unique case (data_type_q)
300        1/1                2'b00:       data_rdata_ext = rdata_w_ext;
301        1/1                2'b01:       data_rdata_ext = rdata_h_ext;
302        1/1                2'b10,2'b11: data_rdata_ext = rdata_b_ext;
303        0/1     ==>        default:     data_rdata_ext = rdata_w_ext;
304                         endcase // case (data_type_q)
305                       end
306                     
307                       /////////////
308                       // LSU FSM //
309                       /////////////
310                     
311                       // check for misaligned accesses that need to be split into two word-aligned accesses
312                       assign split_misaligned_access =
313                           ((data_type_ex_i == 2'b00) && (data_offset != 2'b00)) || // misaligned word access
314                           ((data_type_ex_i == 2'b01) && (data_offset == 2'b11));   // misaligned half-word access
315                     
316                       // FSM
317                       always_comb begin
318        1/1              ls_fsm_ns       = ls_fsm_cs;
319                     
320        1/1              data_req_o          = 1'b0;
321        1/1              data_valid_o        = 1'b0;
322        1/1              addr_incr_req_o     = 1'b0;
323        1/1              handle_misaligned_d = handle_misaligned_q;
324        1/1              data_or_pmp_err     = 1'b0;
325        1/1              pmp_err_d           = pmp_err_q;
326        1/1              lsu_err_d           = lsu_err_q;
327                     
328        1/1              addr_update         = 1'b0;
329        1/1              ctrl_update         = 1'b0;
330        1/1              rdata_update        = 1'b0;
331                     
332        1/1              unique case (ls_fsm_cs)
333                     
334                           IDLE: begin
335        1/1                  if (data_req_ex_i) begin
336        1/1                    data_req_o = 1'b1;
337        1/1                    pmp_err_d  = data_pmp_err_i;
338        1/1                    lsu_err_d  = 1'b0;
339        1/1                    if (data_gnt_i) begin
340        1/1                      ctrl_update         = 1'b1;
341        1/1                      addr_update         = 1'b1;
342        1/1                      handle_misaligned_d = split_misaligned_access;
343        1/1                      ls_fsm_ns           = split_misaligned_access ? WAIT_RVALID_MIS : WAIT_RVALID;
344                               end else begin
345        1/1                      ls_fsm_ns           = split_misaligned_access ? WAIT_GNT_MIS    : WAIT_GNT;
346                               end
347                             end
                        MISSING_ELSE
348                           end
349                     
350                           WAIT_GNT_MIS: begin
351        1/1                  data_req_o = 1'b1;
352                             // data_pmp_err_i is valid during the address phase of a request. An error will block the
353                             // external request and so a data_gnt_i might never be signalled. The registered version
354                             // pmp_err_q is only updated for new address phases and so can be used in WAIT_GNT* and
355                             // WAIT_RVALID* states
356        1/1                  if (data_gnt_i || pmp_err_q) begin
357        1/1                    addr_update         = 1'b1;
358        1/1                    ctrl_update         = 1'b1;
359        1/1                    handle_misaligned_d = 1'b1;
360        1/1                    ls_fsm_ns           = WAIT_RVALID_MIS;
361                             end
                        MISSING_ELSE
362                           end
363                     
364                           WAIT_RVALID_MIS: begin
365                             // push out second request
366        1/1                  data_req_o = 1'b1;
367                             // tell ID/EX stage to update the address
368        1/1                  addr_incr_req_o = 1'b1;
369                     
370                             // first part rvalid is received, or gets a PMP error
371        1/1                  if (data_rvalid_i || pmp_err_q) begin
372                               // Update the PMP error for the second part
373        1/1                    pmp_err_d = data_pmp_err_i;
374                               // Record the error status of the first part
375        1/1                    lsu_err_d = data_err_i | pmp_err_q;
376                               // Capture the first rdata for loads
377        1/1                    rdata_update = ~data_we_q;
378                               // If already granted, wait for second rvalid
379        1/1                    ls_fsm_ns = data_gnt_i ? WAIT_RVALID : WAIT_GNT;
380                               // Update the address for the second part, if no error
381        1/1                    addr_update = data_gnt_i & ~(data_err_i | pmp_err_q);
382                     
383                             end else begin
384                               // first part rvalid is NOT received
385        1/1                    if (data_gnt_i) begin
386                                 // second grant is received
387        1/1                      ls_fsm_ns = WAIT_RVALID_DONE;
388                               end
                        MISSING_ELSE
389                             end
390                           end
391                     
392                           WAIT_GNT: begin
393                             // tell ID/EX stage to update the address
394        1/1                  addr_incr_req_o = handle_misaligned_q;
395        1/1                  data_req_o      = 1'b1;
396        1/1                  if (data_gnt_i || pmp_err_q) begin
397        1/1                    ctrl_update = 1'b1;
398                               // Update the address, unless there was an error
399        1/1                    addr_update = ~lsu_err_q;
400        1/1                    ls_fsm_ns   = WAIT_RVALID;
401                             end
                        MISSING_ELSE
402                           end
403                     
404                           WAIT_RVALID: begin
405        1/1                  if (data_rvalid_i || pmp_err_q) begin
406        1/1                    data_valid_o        = 1'b1;
407                               // Data error from either part
408        1/1                    data_or_pmp_err     = lsu_err_q | data_err_i | pmp_err_q;
409        1/1                    handle_misaligned_d = 1'b0;
410        1/1                    ls_fsm_ns           = IDLE;
411                             end else begin
412        1/1                    ls_fsm_ns           = WAIT_RVALID;
413                             end
414                           end
415                     
416                           WAIT_RVALID_DONE: begin
417                             // tell ID/EX stage to update the address (to make sure the
418                             // second address can be captured correctly for mtval and PMP checking)
419        1/1                  addr_incr_req_o = 1'b1;
420                             // Wait for the first rvalid, second request is already granted
421        1/1                  if (data_rvalid_i) begin
422                               // Update the pmp error for the second part
423        1/1                    pmp_err_d = data_pmp_err_i;
424                               // The first part cannot see a PMP error in this state
425        1/1                    lsu_err_d = data_err_i;
426                               // Now we can update the address for the second part if no error
427        1/1                    addr_update = ~data_err_i;
428                               // Capture the first rdata for loads
429        1/1                    rdata_update = ~data_we_q;
430                               // Wait for second rvalid
431        1/1                    ls_fsm_ns = WAIT_RVALID;
432                             end
                        MISSING_ELSE
433                           end
434                     
435                           default: begin
436        1/1                  ls_fsm_ns = IDLE;
437                           end
438                         endcase
439                       end
440                     
441                       // registers for FSM
442                       always_ff @(posedge clk_i or negedge rst_ni) begin
443        1/1              if (!rst_ni) begin
444        1/1                ls_fsm_cs           <= IDLE;
445        1/1                handle_misaligned_q <= '0;
446        1/1                pmp_err_q           <= '0;
447        1/1                lsu_err_q           <= '0;
448                         end else begin
449        1/1                ls_fsm_cs           <= ls_fsm_ns;
450        1/1                handle_misaligned_q <= handle_misaligned_d;
451        1/1                pmp_err_q           <= pmp_err_d;
452        1/1                lsu_err_q           <= lsu_err_d;

-------------------------------------------------------------------------------
FSM Coverage for Module : ibex_load_store_unit
Summary for FSM :: ls_fsm_cs
            Total Covered Percent                         
States      6     6       100.00  (Not included in score) 
Transitions 15    15      100.00                          
Sequences   0     0                                       

State, Transition and Sequence Details for FSM :: ls_fsm_cs
-------------------------------------------------------------------------------
states           Line No. Covered 
IDLE             444      Covered 
WAIT_GNT         345      Covered 
WAIT_GNT_MIS     345      Covered 
WAIT_RVALID      343      Covered 
WAIT_RVALID_DONE 387      Covered 
WAIT_RVALID_MIS  343      Covered 

transitions                       Line No. Covered 
IDLE->WAIT_GNT                    345      Covered 
IDLE->WAIT_GNT_MIS                345      Covered 
IDLE->WAIT_RVALID                 343      Covered 
IDLE->WAIT_RVALID_MIS             343      Covered 
WAIT_GNT->IDLE                    444      Covered 
WAIT_GNT->WAIT_RVALID             400      Covered 
WAIT_GNT_MIS->IDLE                444      Covered 
WAIT_GNT_MIS->WAIT_RVALID_MIS     360      Covered 
WAIT_RVALID->IDLE                 444      Covered 
WAIT_RVALID_DONE->IDLE            444      Covered 
WAIT_RVALID_DONE->WAIT_RVALID     431      Covered 
WAIT_RVALID_MIS->IDLE             444      Covered 
WAIT_RVALID_MIS->WAIT_GNT         379      Covered 
WAIT_RVALID_MIS->WAIT_RVALID      379      Covered 
WAIT_RVALID_MIS->WAIT_RVALID_DONE 387      Covered 


-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_load_store_unit
         Line No. Total Covered Percent 
Branches          83    75      90.36   
CASE     99       22    18      81.82   
CASE     157      5     5       100.00  
IF       172      3     3       100.00  
IF       181      3     3       100.00  
IF       197      3     3       100.00  
CASE     206      5     4       80.00   
CASE     221      9     8       88.89   
CASE     260      9     8       88.89   
CASE     299      4     3       75.00   
CASE     332      18    18      100.00  
IF       443      2     2       100.00  


99           always_comb begin
             -1-                 
100            unique case (data_type_ex_i) // Data type 00 Word, 01 Half word, 11,10 byte
101              2'b00: begin // Writing a word
                 -2-                              
102                if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
                   -3-                                                                                   
103                  unique case (data_offset)
                     ==>
104                    2'b00:   data_be = 4'b1111;
                       ==>
105                    2'b01:   data_be = 4'b1110;
                       ==>
106                    2'b10:   data_be = 4'b1100;
                       ==>
107                    2'b11:   data_be = 4'b1000;
                       ==>
108                    default: data_be = 4'b1111;
109                  endcase // case (data_offset)
110                end else begin // second part of misaligned transaction
                   -4-                                                       
111                  unique case (data_offset)
                     ==>
112                    2'b00:   data_be = 4'b0000; // this is not used, but included for completeness
                       ==>
113                    2'b01:   data_be = 4'b0001;
                       ==>
114                    2'b10:   data_be = 4'b0011;
                       ==>
115                    2'b11:   data_be = 4'b0111;
                       ==>
116                    default: data_be = 4'b1111;
117                  endcase // case (data_offset)
118                end
119              end
120        
121              2'b01: begin // Writing a half word
                 -5-                                   
122                if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
                   -6-                                                                                   
123                  unique case (data_offset)
                     ==>
124                    2'b00:   data_be = 4'b0011;
                       ==>
125                    2'b01:   data_be = 4'b0110;
                       ==>
126                    2'b10:   data_be = 4'b1100;
                       ==>
127                    2'b11:   data_be = 4'b1000;
                       ==>
128                    default: data_be = 4'b1111;
129                  endcase // case (data_offset)
130                end else begin // second part of misaligned transaction
                   ==>
131                  data_be = 4'b0001;
132                end
133              end
134        
135              2'b10,
136              2'b11: begin // Writing a byte
                 -7-                              
137                unique case (data_offset)
                   ==>
138                  2'b00:   data_be = 4'b0001;
                     ==>
139                  2'b01:   data_be = 4'b0010;
                     ==>
140                  2'b10:   data_be = 4'b0100;
                     ==>
141                  2'b11:   data_be = 4'b1000;
                     ==>
142                  default: data_be = 4'b1111;
143                endcase // case (data_offset)
144              end
145        
           ==>

Branches:

-1-          -2- -3-     -4-     -5- -6-     -7-     Status      
2'b00        1   2'b00   -       -   -       -       Covered     
2'b00        1   2'b01   -       -   -       -       Covered     
2'b00        1   2'b10   -       -   -       -       Covered     
2'b00        1   2'b11   -       -   -       -       Covered     
2'b00        1   default -       -   -       -       Covered     
2'b00        0   -       2'b00   -   -       -       Covered     
2'b00        0   -       2'b01   -   -       -       Covered     
2'b00        0   -       2'b10   -   -       -       Covered     
2'b00        0   -       2'b11   -   -       -       Covered     
2'b00        0   -       default -   -       -       Not Covered 
2'b01        -   -       -       1   2'b00   -       Covered     
2'b01        -   -       -       1   2'b01   -       Covered     
2'b01        -   -       -       1   2'b10   -       Covered     
2'b01        -   -       -       1   2'b11   -       Covered     
2'b01        -   -       -       1   default -       Not Covered 
2'b01        -   -       -       0   -       -       Covered     
2'b10 2'b11  -   -       -       -   -       2'b00   Covered     
2'b10 2'b11  -   -       -       -   -       2'b01   Covered     
2'b10 2'b11  -   -       -       -   -       2'b10   Covered     
2'b10 2'b11  -   -       -       -   -       2'b11   Covered     
2'b10 2'b11  -   -       -       -   -       default Not Covered 
default      -   -       -       -   -       -       Not Covered 


157            unique case (data_offset)
                      -1-  
158              2'b00:   data_wdata =  data_wdata_ex_i[31:0];
                 ==>
159              2'b01:   data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};
                 ==>
160              2'b10:   data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};
                 ==>
161              2'b11:   data_wdata = {data_wdata_ex_i[ 7:0], data_wdata_ex_i[31: 8]};
                 ==>
162              default: data_wdata =  data_wdata_ex_i[31:0];
                 ==>

Branches:

-1-     Status  
2'b00   Covered 
2'b01   Covered 
2'b10   Covered 
2'b11   Covered 
default Covered 


172            if (!rst_ni) begin
               -1-  
173              rdata_q <= '0;
                 ==>
174            end else if (rdata_update) begin
                        -2-  
175              rdata_q <= data_rdata_i[31:8];
                 ==>
176            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


181            if (!rst_ni) begin
               -1-  
182              rdata_offset_q  <= 2'h0;
                 ==>
183              data_type_q     <= 2'h0;
184              data_sign_ext_q <= 1'b0;
185              data_we_q       <= 1'b0;
186            end else if (ctrl_update) begin
                        -2-  
187              rdata_offset_q  <= data_offset;
                 ==>
188              data_type_q     <= data_type_ex_i;
189              data_sign_ext_q <= data_sign_ext_ex_i;
190              data_we_q       <= data_we_ex_i;
191            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


197            if (!rst_ni) begin
               -1-  
198              addr_last_q <= '0;
                 ==>
199            end else if (addr_update) begin
                        -2-  
200              addr_last_q <= data_addr;
                 ==>
201            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


206            unique case (rdata_offset_q)
                      -1-  
207              2'b00:   rdata_w_ext =  data_rdata_i[31:0];
                 ==>
208              2'b01:   rdata_w_ext = {data_rdata_i[ 7:0], rdata_q[31:8]};
                 ==>
209              2'b10:   rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};
                 ==>
210              2'b11:   rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};
                 ==>
211              default: rdata_w_ext =  data_rdata_i[31:0];
                 ==>

Branches:

-1-     Status      
2'b00   Covered     
2'b01   Covered     
2'b10   Covered     
2'b11   Covered     
default Not Covered 


221            unique case (rdata_offset_q)
                      -1-  
222              2'b00: begin
223                if (!data_sign_ext_q) begin
                   -2-  
224                  rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
                     ==>
225                end else begin
226                  rdata_h_ext = {{16{data_rdata_i[15]}}, data_rdata_i[15:0]};
                     ==>
227                end
228              end
229        
230              2'b01: begin
231                if (!data_sign_ext_q) begin
                   -3-  
232                  rdata_h_ext = {16'h0000, data_rdata_i[23:8]};
                     ==>
233                end else begin
234                  rdata_h_ext = {{16{data_rdata_i[23]}}, data_rdata_i[23:8]};
                     ==>
235                end
236              end
237        
238              2'b10: begin
239                if (!data_sign_ext_q) begin
                   -4-  
240                  rdata_h_ext = {16'h0000, data_rdata_i[31:16]};
                     ==>
241                end else begin
242                  rdata_h_ext = {{16{data_rdata_i[31]}}, data_rdata_i[31:16]};
                     ==>
243                end
244              end
245        
246              2'b11: begin
247                if (!data_sign_ext_q) begin
                   -5-  
248                  rdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};
                     ==>
249                end else begin
250                  rdata_h_ext = {{16{data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};
                     ==>
251                end
252              end
253        
254              default: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
                 ==>

Branches:

-1-     -2- -3- -4- -5- Status      
2'b00   1   -   -   -   Covered     
2'b00   0   -   -   -   Covered     
2'b01   -   1   -   -   Covered     
2'b01   -   0   -   -   Covered     
2'b10   -   -   1   -   Covered     
2'b10   -   -   0   -   Covered     
2'b11   -   -   -   1   Covered     
2'b11   -   -   -   0   Covered     
default -   -   -   -   Not Covered 


260            unique case (rdata_offset_q)
                      -1-  
261              2'b00: begin
262                if (!data_sign_ext_q) begin
                   -2-  
263                  rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
                     ==>
264                end else begin
265                  rdata_b_ext = {{24{data_rdata_i[7]}}, data_rdata_i[7:0]};
                     ==>
266                end
267              end
268        
269              2'b01: begin
270                if (!data_sign_ext_q) begin
                   -3-  
271                  rdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};
                     ==>
272                end else begin
273                  rdata_b_ext = {{24{data_rdata_i[15]}}, data_rdata_i[15:8]};
                     ==>
274                end
275              end
276        
277              2'b10: begin
278                if (!data_sign_ext_q) begin
                   -4-  
279                  rdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};
                     ==>
280                end else begin
281                  rdata_b_ext = {{24{data_rdata_i[23]}}, data_rdata_i[23:16]};
                     ==>
282                end
283              end
284        
285              2'b11: begin
286                if (!data_sign_ext_q) begin
                   -5-  
287                  rdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};
                     ==>
288                end else begin
289                  rdata_b_ext = {{24{data_rdata_i[31]}}, data_rdata_i[31:24]};
                     ==>
290                end
291              end
292        
293              default: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
                 ==>

Branches:

-1-     -2- -3- -4- -5- Status      
2'b00   1   -   -   -   Covered     
2'b00   0   -   -   -   Covered     
2'b01   -   1   -   -   Covered     
2'b01   -   0   -   -   Covered     
2'b10   -   -   1   -   Covered     
2'b10   -   -   0   -   Covered     
2'b11   -   -   -   1   Covered     
2'b11   -   -   -   0   Covered     
default -   -   -   -   Not Covered 


299            unique case (data_type_q)
                      -1-  
300              2'b00:       data_rdata_ext = rdata_w_ext;
                 ==>
301              2'b01:       data_rdata_ext = rdata_h_ext;
                 ==>
302              2'b10,2'b11: data_rdata_ext = rdata_b_ext;
                 ==>
303              default:     data_rdata_ext = rdata_w_ext;
                 ==>

Branches:

-1-          Status      
2'b00        Covered     
2'b01        Covered     
2'b10 2'b11  Covered     
default      Not Covered 


332            unique case (ls_fsm_cs)
                      -1-  
333        
334              IDLE: begin
335                if (data_req_ex_i) begin
                   -2-  
336                  data_req_o = 1'b1;
337                  pmp_err_d  = data_pmp_err_i;
338                  lsu_err_d  = 1'b0;
339                  if (data_gnt_i) begin
                     -3-  
340                    ctrl_update         = 1'b1;
341                    addr_update         = 1'b1;
342                    handle_misaligned_d = split_misaligned_access;
343                    ls_fsm_ns           = split_misaligned_access ? WAIT_RVALID_MIS : WAIT_RVALID;
                                                                     -4-  
                                                                     ==>  
                                                                     ==>  
344                  end else begin
345                    ls_fsm_ns           = split_misaligned_access ? WAIT_GNT_MIS    : WAIT_GNT;
                                                                     -5-  
                                                                     ==>  
                                                                     ==>  
346                  end
347                end
                   MISSING_ELSE
                   ==>
348              end
349        
350              WAIT_GNT_MIS: begin
351                data_req_o = 1'b1;
352                // data_pmp_err_i is valid during the address phase of a request. An error will block the
353                // external request and so a data_gnt_i might never be signalled. The registered version
354                // pmp_err_q is only updated for new address phases and so can be used in WAIT_GNT* and
355                // WAIT_RVALID* states
356                if (data_gnt_i || pmp_err_q) begin
                   -6-  
357                  addr_update         = 1'b1;
                     ==>
358                  ctrl_update         = 1'b1;
359                  handle_misaligned_d = 1'b1;
360                  ls_fsm_ns           = WAIT_RVALID_MIS;
361                end
                   MISSING_ELSE
                   ==>
362              end
363        
364              WAIT_RVALID_MIS: begin
365                // push out second request
366                data_req_o = 1'b1;
367                // tell ID/EX stage to update the address
368                addr_incr_req_o = 1'b1;
369        
370                // first part rvalid is received, or gets a PMP error
371                if (data_rvalid_i || pmp_err_q) begin
                   -7-  
372                  // Update the PMP error for the second part
373                  pmp_err_d = data_pmp_err_i;
374                  // Record the error status of the first part
375                  lsu_err_d = data_err_i | pmp_err_q;
376                  // Capture the first rdata for loads
377                  rdata_update = ~data_we_q;
378                  // If already granted, wait for second rvalid
379                  ls_fsm_ns = data_gnt_i ? WAIT_RVALID : WAIT_GNT;
                                            -8-  
                                            ==>  
                                            ==>  
380                  // Update the address for the second part, if no error
381                  addr_update = data_gnt_i & ~(data_err_i | pmp_err_q);
382        
383                end else begin
384                  // first part rvalid is NOT received
385                  if (data_gnt_i) begin
                     -9-  
386                    // second grant is received
387                    ls_fsm_ns = WAIT_RVALID_DONE;
                       ==>
388                  end
                     MISSING_ELSE
                     ==>
389                end
390              end
391        
392              WAIT_GNT: begin
393                // tell ID/EX stage to update the address
394                addr_incr_req_o = handle_misaligned_q;
395                data_req_o      = 1'b1;
396                if (data_gnt_i || pmp_err_q) begin
                   -10-  
397                  ctrl_update = 1'b1;
                     ==>
398                  // Update the address, unless there was an error
399                  addr_update = ~lsu_err_q;
400                  ls_fsm_ns   = WAIT_RVALID;
401                end
                   MISSING_ELSE
                   ==>
402              end
403        
404              WAIT_RVALID: begin
405                if (data_rvalid_i || pmp_err_q) begin
                   -11-  
406                  data_valid_o        = 1'b1;
                     ==>
407                  // Data error from either part
408                  data_or_pmp_err     = lsu_err_q | data_err_i | pmp_err_q;
409                  handle_misaligned_d = 1'b0;
410                  ls_fsm_ns           = IDLE;
411                end else begin
412                  ls_fsm_ns           = WAIT_RVALID;
                     ==>
413                end
414              end
415        
416              WAIT_RVALID_DONE: begin
417                // tell ID/EX stage to update the address (to make sure the
418                // second address can be captured correctly for mtval and PMP checking)
419                addr_incr_req_o = 1'b1;
420                // Wait for the first rvalid, second request is already granted
421                if (data_rvalid_i) begin
                   -12-  
422                  // Update the pmp error for the second part
423                  pmp_err_d = data_pmp_err_i;
                     ==>
424                  // The first part cannot see a PMP error in this state
425                  lsu_err_d = data_err_i;
426                  // Now we can update the address for the second part if no error
427                  addr_update = ~data_err_i;
428                  // Capture the first rdata for loads
429                  rdata_update = ~data_we_q;
430                  // Wait for second rvalid
431                  ls_fsm_ns = WAIT_RVALID;
432                end
                   MISSING_ELSE
                   ==>
433              end
434        
435              default: begin
436                ls_fsm_ns = IDLE;
                   ==>

Branches:

-1-               -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- -12- Status  
IDLE              1   1   1   -   -   -   -   -   -    -    -    Covered 
IDLE              1   1   0   -   -   -   -   -   -    -    -    Covered 
IDLE              1   0   -   1   -   -   -   -   -    -    -    Covered 
IDLE              1   0   -   0   -   -   -   -   -    -    -    Covered 
IDLE              0   -   -   -   -   -   -   -   -    -    -    Covered 
WAIT_GNT_MIS      -   -   -   -   1   -   -   -   -    -    -    Covered 
WAIT_GNT_MIS      -   -   -   -   0   -   -   -   -    -    -    Covered 
WAIT_RVALID_MIS   -   -   -   -   -   1   1   -   -    -    -    Covered 
WAIT_RVALID_MIS   -   -   -   -   -   1   0   -   -    -    -    Covered 
WAIT_RVALID_MIS   -   -   -   -   -   0   -   1   -    -    -    Covered 
WAIT_RVALID_MIS   -   -   -   -   -   0   -   0   -    -    -    Covered 
WAIT_GNT          -   -   -   -   -   -   -   -   1    -    -    Covered 
WAIT_GNT          -   -   -   -   -   -   -   -   0    -    -    Covered 
WAIT_RVALID       -   -   -   -   -   -   -   -   -    1    -    Covered 
WAIT_RVALID       -   -   -   -   -   -   -   -   -    0    -    Covered 
WAIT_RVALID_DONE  -   -   -   -   -   -   -   -   -    -    1    Covered 
WAIT_RVALID_DONE  -   -   -   -   -   -   -   -   -    -    0    Covered 
default           -   -   -   -   -   -   -   -   -    -    -    Covered 


443            if (!rst_ni) begin
               -1-  
444              ls_fsm_cs           <= IDLE;
                 ==>
445              handle_misaligned_q <= '0;
446              pmp_err_q           <= '0;
447              lsu_err_q           <= '0;
448            end else begin
449              ls_fsm_cs           <= ls_fsm_ns;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_load_store_unit
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       4     4         100.00  4                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            4     4         100.00  4                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name         Attempts  Real Successes Failures Incomplete 
unnamed$$_68 159095193 4648786        0        0          
unnamed$$_69 159095193 1803           0        0          
unnamed$$_70 159095193 27896040       0        0          
unnamed$$_71 159095193 27896040       0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.load_store_unit_i(x)
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 100.00 100.00 


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                 
 96.33  94.97 --     100.00  90.36 100.00 ibex_load_store_unit 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME        
 98.10  99.07 --     --      97.14 --     u_ibex_core 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.load_store_unit_i(x)

             Line No.   Total   Covered  Percent
TOTAL                      151      151   100.00
ALWAYS             99       25       25   100.00
ALWAYS            157        6        6   100.00
ALWAYS            172        4        4   100.00
ALWAYS            181       10       10   100.00
ALWAYS            197        4        4   100.00
ALWAYS            206        5        5   100.00
ALWAYS            221       13       13   100.00
ALWAYS            260       13       13   100.00
ALWAYS            299        4        4   100.00
ALWAYS            318       58       58   100.00
ALWAYS            443        9        9   100.00

98                      
99         1/1            always_comb begin
100                         unique case (data_type_ex_i) // Data type 00 Word, 01 Half word, 11,10 byte
101        1/1                2'b00: begin // Writing a word
102        1/1                  if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
103        1/1                    unique case (data_offset)
104        1/1                      2'b00:   data_be = 4'b1111;
105        1/1                      2'b01:   data_be = 4'b1110;
106        1/1                      2'b10:   data_be = 4'b1100;
107        1/1                      2'b11:   data_be = 4'b1000;
108                                 default: data_be = 4'b1111;
109                               endcase // case (data_offset)
110        1/1                  end else begin // second part of misaligned transaction
111        1/1                    unique case (data_offset)
112        1/1                      2'b00:   data_be = 4'b0000; // this is not used, but included for completeness
113        1/1                      2'b01:   data_be = 4'b0001;
114        1/1                      2'b10:   data_be = 4'b0011;
115        excluded                 2'b11:   data_be = 4'b0111;
116                                 default: data_be = 4'b1111;
117                               endcase // case (data_offset)
118                             end
119                           end
120                     
121        1/1                2'b01: begin // Writing a half word
122        1/1                  if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
123        1/1                    unique case (data_offset)
124        1/1                      2'b00:   data_be = 4'b0011;
125        1/1                      2'b01:   data_be = 4'b0110;
126        1/1                      2'b10:   data_be = 4'b1100;
127        excluded                 2'b11:   data_be = 4'b1000;
128                                 default: data_be = 4'b1111;
129                               endcase // case (data_offset)
130        1/1                  end else begin // second part of misaligned transaction
131                               data_be = 4'b0001;
132                             end
133                           end
134                     
135                           2'b10,
136        1/1                2'b11: begin // Writing a byte
137        1/1                  unique case (data_offset)
138        1/1                    2'b00:   data_be = 4'b0001;
139        1/1                    2'b01:   data_be = 4'b0010;
140        1/1                    2'b10:   data_be = 4'b0100;
141        excluded               2'b11:   data_be = 4'b1000;
142                               default: data_be = 4'b1111;
143                             endcase // case (data_offset)
144                           end
145        excluded     
146                           default:     data_be = 4'b1111;
147                         endcase // case (data_type_ex_i)
148                       end
149                     
150                       /////////////////////
151                       // WData alignment //
152                       /////////////////////
153                     
154                       // prepare data to be written to the memory
155                       // we handle misaligned accesses, half word and byte accesses here
156                       always_comb begin
157        1/1              unique case (data_offset)
158        1/1                2'b00:   data_wdata =  data_wdata_ex_i[31:0];
159        1/1                2'b01:   data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};
160        1/1                2'b10:   data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};
161        1/1                2'b11:   data_wdata = {data_wdata_ex_i[ 7:0], data_wdata_ex_i[31: 8]};
162        1/1                default: data_wdata =  data_wdata_ex_i[31:0];
163                         endcase // case (data_offset)
164                       end
165                     
166                       /////////////////////
167                       // RData alignment //
168                       /////////////////////
169                     
170                       // register for unaligned rdata
171                       always_ff @(posedge clk_i or negedge rst_ni) begin
172        1/1              if (!rst_ni) begin
173        1/1                rdata_q <= '0;
174        1/1              end else if (rdata_update) begin
175        1/1                rdata_q <= data_rdata_i[31:8];
176                         end
                        MISSING_ELSE
177                       end
178                     
179                       // registers for transaction control
180                       always_ff @(posedge clk_i or negedge rst_ni) begin
181        1/1              if (!rst_ni) begin
182        1/1                rdata_offset_q  <= 2'h0;
183        1/1                data_type_q     <= 2'h0;
184        1/1                data_sign_ext_q <= 1'b0;
185        1/1                data_we_q       <= 1'b0;
186        1/1              end else if (ctrl_update) begin
187        1/1                rdata_offset_q  <= data_offset;
188        1/1                data_type_q     <= data_type_ex_i;
189        1/1                data_sign_ext_q <= data_sign_ext_ex_i;
190        1/1                data_we_q       <= data_we_ex_i;
191                         end
                        MISSING_ELSE
192                       end
193                     
194                       // Store last address for mtval + AGU for misaligned transactions.
195                       // Do not update in case of errors, mtval needs the (first) failing address
196                       always_ff @(posedge clk_i or negedge rst_ni) begin
197        1/1              if (!rst_ni) begin
198        1/1                addr_last_q <= '0;
199        1/1              end else if (addr_update) begin
200        1/1                addr_last_q <= data_addr;
201                         end
                        MISSING_ELSE
202                       end
203                     
204                       // take care of misaligned words
205                       always_comb begin
206        1/1              unique case (rdata_offset_q)
207        1/1                2'b00:   rdata_w_ext =  data_rdata_i[31:0];
208        1/1                2'b01:   rdata_w_ext = {data_rdata_i[ 7:0], rdata_q[31:8]};
209        1/1                2'b10:   rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};
210        1/1                2'b11:   rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};
211        excluded           default: rdata_w_ext =  data_rdata_i[31:0];
212                         endcase
213                       end
214                     
215                       ////////////////////
216                       // Sign extension //
217                       ////////////////////
218                     
219                       // sign extension for half words
220                       always_comb begin
221        1/1              unique case (rdata_offset_q)
222                           2'b00: begin
223        1/1                  if (!data_sign_ext_q) begin
224        1/1                    rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
225                             end else begin
226        1/1                    rdata_h_ext = {{16{data_rdata_i[15]}}, data_rdata_i[15:0]};
227                             end
228                           end
229                     
230                           2'b01: begin
231        1/1                  if (!data_sign_ext_q) begin
232        1/1                    rdata_h_ext = {16'h0000, data_rdata_i[23:8]};
233                             end else begin
234        1/1                    rdata_h_ext = {{16{data_rdata_i[23]}}, data_rdata_i[23:8]};
235                             end
236                           end
237                     
238                           2'b10: begin
239        1/1                  if (!data_sign_ext_q) begin
240        1/1                    rdata_h_ext = {16'h0000, data_rdata_i[31:16]};
241                             end else begin
242        1/1                    rdata_h_ext = {{16{data_rdata_i[31]}}, data_rdata_i[31:16]};
243                             end
244                           end
245                     
246                           2'b11: begin
247        1/1                  if (!data_sign_ext_q) begin
248        1/1                    rdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};
249                             end else begin
250        1/1                    rdata_h_ext = {{16{data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};
251                             end
252                           end
253                     
254        excluded           default: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
255                         endcase // case (rdata_offset_q)
256                       end
257                     
258                       // sign extension for bytes
259                       always_comb begin
260        1/1              unique case (rdata_offset_q)
261                           2'b00: begin
262        1/1                  if (!data_sign_ext_q) begin
263        1/1                    rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
264                             end else begin
265        1/1                    rdata_b_ext = {{24{data_rdata_i[7]}}, data_rdata_i[7:0]};
266                             end
267                           end
268                     
269                           2'b01: begin
270        1/1                  if (!data_sign_ext_q) begin
271        1/1                    rdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};
272                             end else begin
273        1/1                    rdata_b_ext = {{24{data_rdata_i[15]}}, data_rdata_i[15:8]};
274                             end
275                           end
276                     
277                           2'b10: begin
278        1/1                  if (!data_sign_ext_q) begin
279        1/1                    rdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};
280                             end else begin
281        1/1                    rdata_b_ext = {{24{data_rdata_i[23]}}, data_rdata_i[23:16]};
282                             end
283                           end
284                     
285                           2'b11: begin
286        1/1                  if (!data_sign_ext_q) begin
287        1/1                    rdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};
288                             end else begin
289        1/1                    rdata_b_ext = {{24{data_rdata_i[31]}}, data_rdata_i[31:24]};
290                             end
291                           end
292                     
293        excluded           default: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
294                         endcase // case (rdata_offset_q)
295                       end
296                     
297                       // select word, half word or byte sign extended version
298                       always_comb begin
299        1/1              unique case (data_type_q)
300        1/1                2'b00:       data_rdata_ext = rdata_w_ext;
301        1/1                2'b01:       data_rdata_ext = rdata_h_ext;
302        1/1                2'b10,2'b11: data_rdata_ext = rdata_b_ext;
303        excluded           default:     data_rdata_ext = rdata_w_ext;
304                         endcase // case (data_type_q)
305                       end
306                     
307                       /////////////
308                       // LSU FSM //
309                       /////////////
310                     
311                       // check for misaligned accesses that need to be split into two word-aligned accesses
312                       assign split_misaligned_access =
313                           ((data_type_ex_i == 2'b00) && (data_offset != 2'b00)) || // misaligned word access
314                           ((data_type_ex_i == 2'b01) && (data_offset == 2'b11));   // misaligned half-word access
315                     
316                       // FSM
317                       always_comb begin
318        1/1              ls_fsm_ns       = ls_fsm_cs;
319                     
320        1/1              data_req_o          = 1'b0;
321        1/1              data_valid_o        = 1'b0;
322        1/1              addr_incr_req_o     = 1'b0;
323        1/1              handle_misaligned_d = handle_misaligned_q;
324        1/1              data_or_pmp_err     = 1'b0;
325        1/1              pmp_err_d           = pmp_err_q;
326        1/1              lsu_err_d           = lsu_err_q;
327                     
328        1/1              addr_update         = 1'b0;
329        1/1              ctrl_update         = 1'b0;
330        1/1              rdata_update        = 1'b0;
331                     
332        1/1              unique case (ls_fsm_cs)
333                     
334                           IDLE: begin
335        1/1                  if (data_req_ex_i) begin
336        1/1                    data_req_o = 1'b1;
337        1/1                    pmp_err_d  = data_pmp_err_i;
338        1/1                    lsu_err_d  = 1'b0;
339        1/1                    if (data_gnt_i) begin
340        1/1                      ctrl_update         = 1'b1;
341        1/1                      addr_update         = 1'b1;
342        1/1                      handle_misaligned_d = split_misaligned_access;
343        1/1                      ls_fsm_ns           = split_misaligned_access ? WAIT_RVALID_MIS : WAIT_RVALID;
344                               end else begin
345        1/1                      ls_fsm_ns           = split_misaligned_access ? WAIT_GNT_MIS    : WAIT_GNT;
346                               end
347                             end
                        MISSING_ELSE
348                           end
349                     
350                           WAIT_GNT_MIS: begin
351        1/1                  data_req_o = 1'b1;
352                             // data_pmp_err_i is valid during the address phase of a request. An error will block the
353                             // external request and so a data_gnt_i might never be signalled. The registered version
354                             // pmp_err_q is only updated for new address phases and so can be used in WAIT_GNT* and
355                             // WAIT_RVALID* states
356        1/1                  if (data_gnt_i || pmp_err_q) begin
357        1/1                    addr_update         = 1'b1;
358        1/1                    ctrl_update         = 1'b1;
359        1/1                    handle_misaligned_d = 1'b1;
360        1/1                    ls_fsm_ns           = WAIT_RVALID_MIS;
361                             end
                        MISSING_ELSE
362                           end
363                     
364                           WAIT_RVALID_MIS: begin
365                             // push out second request
366        1/1                  data_req_o = 1'b1;
367                             // tell ID/EX stage to update the address
368        1/1                  addr_incr_req_o = 1'b1;
369                     
370                             // first part rvalid is received, or gets a PMP error
371        1/1                  if (data_rvalid_i || pmp_err_q) begin
372                               // Update the PMP error for the second part
373        1/1                    pmp_err_d = data_pmp_err_i;
374                               // Record the error status of the first part
375        1/1                    lsu_err_d = data_err_i | pmp_err_q;
376                               // Capture the first rdata for loads
377        1/1                    rdata_update = ~data_we_q;
378                               // If already granted, wait for second rvalid
379        1/1                    ls_fsm_ns = data_gnt_i ? WAIT_RVALID : WAIT_GNT;
380                               // Update the address for the second part, if no error
381        1/1                    addr_update = data_gnt_i & ~(data_err_i | pmp_err_q);
382                     
383                             end else begin
384                               // first part rvalid is NOT received
385        1/1                    if (data_gnt_i) begin
386                                 // second grant is received
387        1/1                      ls_fsm_ns = WAIT_RVALID_DONE;
388                               end
                        MISSING_ELSE
389                             end
390                           end
391                     
392                           WAIT_GNT: begin
393                             // tell ID/EX stage to update the address
394        1/1                  addr_incr_req_o = handle_misaligned_q;
395        1/1                  data_req_o      = 1'b1;
396        1/1                  if (data_gnt_i || pmp_err_q) begin
397        1/1                    ctrl_update = 1'b1;
398                               // Update the address, unless there was an error
399        1/1                    addr_update = ~lsu_err_q;
400        1/1                    ls_fsm_ns   = WAIT_RVALID;
401                             end
                        MISSING_ELSE
402                           end
403                     
404                           WAIT_RVALID: begin
405        1/1                  if (data_rvalid_i || pmp_err_q) begin
406        1/1                    data_valid_o        = 1'b1;
407                               // Data error from either part
408        1/1                    data_or_pmp_err     = lsu_err_q | data_err_i | pmp_err_q;
409        1/1                    handle_misaligned_d = 1'b0;
410        1/1                    ls_fsm_ns           = IDLE;
411                             end else begin
412        1/1                    ls_fsm_ns           = WAIT_RVALID;
413                             end
414                           end
415                     
416                           WAIT_RVALID_DONE: begin
417                             // tell ID/EX stage to update the address (to make sure the
418                             // second address can be captured correctly for mtval and PMP checking)
419        1/1                  addr_incr_req_o = 1'b1;
420                             // Wait for the first rvalid, second request is already granted
421        1/1                  if (data_rvalid_i) begin
422                               // Update the pmp error for the second part
423        1/1                    pmp_err_d = data_pmp_err_i;
424                               // The first part cannot see a PMP error in this state
425        1/1                    lsu_err_d = data_err_i;
426                               // Now we can update the address for the second part if no error
427        1/1                    addr_update = ~data_err_i;
428                               // Capture the first rdata for loads
429        1/1                    rdata_update = ~data_we_q;
430                               // Wait for second rvalid
431        1/1                    ls_fsm_ns = WAIT_RVALID;
432                             end
                        MISSING_ELSE
433                           end
434                     
435                           default: begin
436        1/1                  ls_fsm_ns = IDLE;
437                           end
438                         endcase
439                       end
440                     
441                       // registers for FSM
442                       always_ff @(posedge clk_i or negedge rst_ni) begin
443        1/1              if (!rst_ni) begin
444        1/1                ls_fsm_cs           <= IDLE;
445        1/1                handle_misaligned_q <= '0;
446        1/1                pmp_err_q           <= '0;
447        1/1                lsu_err_q           <= '0;
448                         end else begin
449        1/1                ls_fsm_cs           <= ls_fsm_ns;
450        1/1                handle_misaligned_q <= handle_misaligned_d;
451        1/1                pmp_err_q           <= pmp_err_d;
452        1/1                lsu_err_q           <= lsu_err_d;

-------------------------------------------------------------------------------
FSM Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.load_store_unit_i(x)
Summary for FSM :: ls_fsm_cs
            Total Covered Percent                         
States      6     6       100.00  (Not included in score) 
Transitions 15    15      100.00                          
Sequences   0     0                                       

State, Transition and Sequence Details for FSM :: ls_fsm_cs
-------------------------------------------------------------------------------
states           Line No. Covered 
IDLE             444      Covered 
WAIT_GNT         345      Covered 
WAIT_GNT_MIS     345      Covered 
WAIT_RVALID      343      Covered 
WAIT_RVALID_DONE 387      Covered 
WAIT_RVALID_MIS  343      Covered 

transitions                       Line No. Covered 
IDLE->WAIT_GNT                    345      Covered 
IDLE->WAIT_GNT_MIS                345      Covered 
IDLE->WAIT_RVALID                 343      Covered 
IDLE->WAIT_RVALID_MIS             343      Covered 
WAIT_GNT->IDLE                    444      Covered 
WAIT_GNT->WAIT_RVALID             400      Covered 
WAIT_GNT_MIS->IDLE                444      Covered 
WAIT_GNT_MIS->WAIT_RVALID_MIS     360      Covered 
WAIT_RVALID->IDLE                 444      Covered 
WAIT_RVALID_DONE->IDLE            444      Covered 
WAIT_RVALID_DONE->WAIT_RVALID     431      Covered 
WAIT_RVALID_MIS->IDLE             444      Covered 
WAIT_RVALID_MIS->WAIT_GNT         379      Covered 
WAIT_RVALID_MIS->WAIT_RVALID      379      Covered 
WAIT_RVALID_MIS->WAIT_RVALID_DONE 387      Covered 


-------------------------------------------------------------------------------
Branch Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.load_store_unit_i(x)
         Line No. Total Covered Percent 
Branches          75    75      100.00  
CASE     99       18    18      100.00  
CASE     157      5     5       100.00  
IF       172      3     3       100.00  
IF       181      3     3       100.00  
IF       197      3     3       100.00  
CASE     206      4     4       100.00  
CASE     221      8     8       100.00  
CASE     260      8     8       100.00  
CASE     299      3     3       100.00  
CASE     332      18    18      100.00  
IF       443      2     2       100.00  


99           always_comb begin
             -1-                 
100            unique case (data_type_ex_i) // Data type 00 Word, 01 Half word, 11,10 byte
101              2'b00: begin // Writing a word
                 -2-                              
102                if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
                   -3-                                                                                   
103                  unique case (data_offset)
                     ==>
104                    2'b00:   data_be = 4'b1111;
                       ==>
105                    2'b01:   data_be = 4'b1110;
                       ==>
106                    2'b10:   data_be = 4'b1100;
                       ==>
107                    2'b11:   data_be = 4'b1000;
                       ==>
108                    default: data_be = 4'b1111;
109                  endcase // case (data_offset)
110                end else begin // second part of misaligned transaction
                   -4-                                                       
111                  unique case (data_offset)
                     ==>
112                    2'b00:   data_be = 4'b0000; // this is not used, but included for completeness
                       ==>
113                    2'b01:   data_be = 4'b0001;
                       ==>
114                    2'b10:   data_be = 4'b0011;
                       ==>
115                    2'b11:   data_be = 4'b0111;
                       ==> (Excluded)
116                    default: data_be = 4'b1111;
117                  endcase // case (data_offset)
118                end
119              end
120        
121              2'b01: begin // Writing a half word
                 -5-                                   
122                if (!handle_misaligned_q) begin // first part of potentially misaligned transaction
                   -6-                                                                                   
123                  unique case (data_offset)
                     ==>
124                    2'b00:   data_be = 4'b0011;
                       ==>
125                    2'b01:   data_be = 4'b0110;
                       ==>
126                    2'b10:   data_be = 4'b1100;
                       ==>
127                    2'b11:   data_be = 4'b1000;
                       ==> (Excluded)
128                    default: data_be = 4'b1111;
129                  endcase // case (data_offset)
130                end else begin // second part of misaligned transaction
                   ==>
131                  data_be = 4'b0001;
132                end
133              end
134        
135              2'b10,
136              2'b11: begin // Writing a byte
                 -7-                              
137                unique case (data_offset)
                   ==>
138                  2'b00:   data_be = 4'b0001;
                     ==>
139                  2'b01:   data_be = 4'b0010;
                     ==>
140                  2'b10:   data_be = 4'b0100;
                     ==>
141                  2'b11:   data_be = 4'b1000;
                     ==> (Excluded)
142                  default: data_be = 4'b1111;
143                endcase // case (data_offset)
144              end
145        
           ==> (Excluded)

Branches:

-1-          -2- -3-     -4-     -5- -6-     -7-     Status   
2'b00        1   2'b00   -       -   -       -       Covered  
2'b00        1   2'b01   -       -   -       -       Covered  
2'b00        1   2'b10   -       -   -       -       Covered  
2'b00        1   2'b11   -       -   -       -       Covered  
2'b00        1   default -       -   -       -       Covered  
2'b00        0   -       2'b00   -   -       -       Covered  
2'b00        0   -       2'b01   -   -       -       Covered  
2'b00        0   -       2'b10   -   -       -       Covered  
2'b00        0   -       2'b11   -   -       -       Covered  
2'b00        0   -       default -   -       -       Excluded 
2'b01        -   -       -       1   2'b00   -       Covered  
2'b01        -   -       -       1   2'b01   -       Covered  
2'b01        -   -       -       1   2'b10   -       Covered  
2'b01        -   -       -       1   2'b11   -       Covered  
2'b01        -   -       -       1   default -       Excluded 
2'b01        -   -       -       0   -       -       Covered  
2'b10 2'b11  -   -       -       -   -       2'b00   Covered  
2'b10 2'b11  -   -       -       -   -       2'b01   Covered  
2'b10 2'b11  -   -       -       -   -       2'b10   Covered  
2'b10 2'b11  -   -       -       -   -       2'b11   Covered  
2'b10 2'b11  -   -       -       -   -       default Excluded 
default      -   -       -       -   -       -       Excluded 


157            unique case (data_offset)
                      -1-  
158              2'b00:   data_wdata =  data_wdata_ex_i[31:0];
                 ==>
159              2'b01:   data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};
                 ==>
160              2'b10:   data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};
                 ==>
161              2'b11:   data_wdata = {data_wdata_ex_i[ 7:0], data_wdata_ex_i[31: 8]};
                 ==>
162              default: data_wdata =  data_wdata_ex_i[31:0];
                 ==>

Branches:

-1-     Status  
2'b00   Covered 
2'b01   Covered 
2'b10   Covered 
2'b11   Covered 
default Covered 


172            if (!rst_ni) begin
               -1-  
173              rdata_q <= '0;
                 ==>
174            end else if (rdata_update) begin
                        -2-  
175              rdata_q <= data_rdata_i[31:8];
                 ==>
176            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


181            if (!rst_ni) begin
               -1-  
182              rdata_offset_q  <= 2'h0;
                 ==>
183              data_type_q     <= 2'h0;
184              data_sign_ext_q <= 1'b0;
185              data_we_q       <= 1'b0;
186            end else if (ctrl_update) begin
                        -2-  
187              rdata_offset_q  <= data_offset;
                 ==>
188              data_type_q     <= data_type_ex_i;
189              data_sign_ext_q <= data_sign_ext_ex_i;
190              data_we_q       <= data_we_ex_i;
191            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


197            if (!rst_ni) begin
               -1-  
198              addr_last_q <= '0;
                 ==>
199            end else if (addr_update) begin
                        -2-  
200              addr_last_q <= data_addr;
                 ==>
201            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


206            unique case (rdata_offset_q)
                      -1-  
207              2'b00:   rdata_w_ext =  data_rdata_i[31:0];
                 ==>
208              2'b01:   rdata_w_ext = {data_rdata_i[ 7:0], rdata_q[31:8]};
                 ==>
209              2'b10:   rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};
                 ==>
210              2'b11:   rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};
                 ==>
211              default: rdata_w_ext =  data_rdata_i[31:0];
                 ==> (Excluded)

Branches:

-1-     Status   
2'b00   Covered  
2'b01   Covered  
2'b10   Covered  
2'b11   Covered  
default Excluded 


221            unique case (rdata_offset_q)
                      -1-  
222              2'b00: begin
223                if (!data_sign_ext_q) begin
                   -2-  
224                  rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
                     ==>
225                end else begin
226                  rdata_h_ext = {{16{data_rdata_i[15]}}, data_rdata_i[15:0]};
                     ==>
227                end
228              end
229        
230              2'b01: begin
231                if (!data_sign_ext_q) begin
                   -3-  
232                  rdata_h_ext = {16'h0000, data_rdata_i[23:8]};
                     ==>
233                end else begin
234                  rdata_h_ext = {{16{data_rdata_i[23]}}, data_rdata_i[23:8]};
                     ==>
235                end
236              end
237        
238              2'b10: begin
239                if (!data_sign_ext_q) begin
                   -4-  
240                  rdata_h_ext = {16'h0000, data_rdata_i[31:16]};
                     ==>
241                end else begin
242                  rdata_h_ext = {{16{data_rdata_i[31]}}, data_rdata_i[31:16]};
                     ==>
243                end
244              end
245        
246              2'b11: begin
247                if (!data_sign_ext_q) begin
                   -5-  
248                  rdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};
                     ==>
249                end else begin
250                  rdata_h_ext = {{16{data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};
                     ==>
251                end
252              end
253        
254              default: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};
                 ==> (Excluded)

Branches:

-1-     -2- -3- -4- -5- Status   
2'b00   1   -   -   -   Covered  
2'b00   0   -   -   -   Covered  
2'b01   -   1   -   -   Covered  
2'b01   -   0   -   -   Covered  
2'b10   -   -   1   -   Covered  
2'b10   -   -   0   -   Covered  
2'b11   -   -   -   1   Covered  
2'b11   -   -   -   0   Covered  
default -   -   -   -   Excluded 


260            unique case (rdata_offset_q)
                      -1-  
261              2'b00: begin
262                if (!data_sign_ext_q) begin
                   -2-  
263                  rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
                     ==>
264                end else begin
265                  rdata_b_ext = {{24{data_rdata_i[7]}}, data_rdata_i[7:0]};
                     ==>
266                end
267              end
268        
269              2'b01: begin
270                if (!data_sign_ext_q) begin
                   -3-  
271                  rdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};
                     ==>
272                end else begin
273                  rdata_b_ext = {{24{data_rdata_i[15]}}, data_rdata_i[15:8]};
                     ==>
274                end
275              end
276        
277              2'b10: begin
278                if (!data_sign_ext_q) begin
                   -4-  
279                  rdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};
                     ==>
280                end else begin
281                  rdata_b_ext = {{24{data_rdata_i[23]}}, data_rdata_i[23:16]};
                     ==>
282                end
283              end
284        
285              2'b11: begin
286                if (!data_sign_ext_q) begin
                   -5-  
287                  rdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};
                     ==>
288                end else begin
289                  rdata_b_ext = {{24{data_rdata_i[31]}}, data_rdata_i[31:24]};
                     ==>
290                end
291              end
292        
293              default: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};
                 ==> (Excluded)

Branches:

-1-     -2- -3- -4- -5- Status   
2'b00   1   -   -   -   Covered  
2'b00   0   -   -   -   Covered  
2'b01   -   1   -   -   Covered  
2'b01   -   0   -   -   Covered  
2'b10   -   -   1   -   Covered  
2'b10   -   -   0   -   Covered  
2'b11   -   -   -   1   Covered  
2'b11   -   -   -   0   Covered  
default -   -   -   -   Excluded 


299            unique case (data_type_q)
                      -1-  
300              2'b00:       data_rdata_ext = rdata_w_ext;
                 ==>
301              2'b01:       data_rdata_ext = rdata_h_ext;
                 ==>
302              2'b10,2'b11: data_rdata_ext = rdata_b_ext;
                 ==>
303              default:     data_rdata_ext = rdata_w_ext;
                 ==> (Excluded)

Branches:

-1-          Status   
2'b00        Covered  
2'b01        Covered  
2'b10 2'b11  Covered  
default      Excluded 


332            unique case (ls_fsm_cs)
                      -1-  
333        
334              IDLE: begin
335                if (data_req_ex_i) begin
                   -2-  
336                  data_req_o = 1'b1;
337                  pmp_err_d  = data_pmp_err_i;
338                  lsu_err_d  = 1'b0;
339                  if (data_gnt_i) begin
                     -3-  
340                    ctrl_update         = 1'b1;
341                    addr_update         = 1'b1;
342                    handle_misaligned_d = split_misaligned_access;
343                    ls_fsm_ns           = split_misaligned_access ? WAIT_RVALID_MIS : WAIT_RVALID;
                                                                     -4-  
                                                                     ==>  
                                                                     ==>  
344                  end else begin
345                    ls_fsm_ns           = split_misaligned_access ? WAIT_GNT_MIS    : WAIT_GNT;
                                                                     -5-  
                                                                     ==>  
                                                                     ==>  
346                  end
347                end
                   MISSING_ELSE
                   ==>
348              end
349        
350              WAIT_GNT_MIS: begin
351                data_req_o = 1'b1;
352                // data_pmp_err_i is valid during the address phase of a request. An error will block the
353                // external request and so a data_gnt_i might never be signalled. The registered version
354                // pmp_err_q is only updated for new address phases and so can be used in WAIT_GNT* and
355                // WAIT_RVALID* states
356                if (data_gnt_i || pmp_err_q) begin
                   -6-  
357                  addr_update         = 1'b1;
                     ==>
358                  ctrl_update         = 1'b1;
359                  handle_misaligned_d = 1'b1;
360                  ls_fsm_ns           = WAIT_RVALID_MIS;
361                end
                   MISSING_ELSE
                   ==>
362              end
363        
364              WAIT_RVALID_MIS: begin
365                // push out second request
366                data_req_o = 1'b1;
367                // tell ID/EX stage to update the address
368                addr_incr_req_o = 1'b1;
369        
370                // first part rvalid is received, or gets a PMP error
371                if (data_rvalid_i || pmp_err_q) begin
                   -7-  
372                  // Update the PMP error for the second part
373                  pmp_err_d = data_pmp_err_i;
374                  // Record the error status of the first part
375                  lsu_err_d = data_err_i | pmp_err_q;
376                  // Capture the first rdata for loads
377                  rdata_update = ~data_we_q;
378                  // If already granted, wait for second rvalid
379                  ls_fsm_ns = data_gnt_i ? WAIT_RVALID : WAIT_GNT;
                                            -8-  
                                            ==>  
                                            ==>  
380                  // Update the address for the second part, if no error
381                  addr_update = data_gnt_i & ~(data_err_i | pmp_err_q);
382        
383                end else begin
384                  // first part rvalid is NOT received
385                  if (data_gnt_i) begin
                     -9-  
386                    // second grant is received
387                    ls_fsm_ns = WAIT_RVALID_DONE;
                       ==>
388                  end
                     MISSING_ELSE
                     ==>
389                end
390              end
391        
392              WAIT_GNT: begin
393                // tell ID/EX stage to update the address
394                addr_incr_req_o = handle_misaligned_q;
395                data_req_o      = 1'b1;
396                if (data_gnt_i || pmp_err_q) begin
                   -10-  
397                  ctrl_update = 1'b1;
                     ==>
398                  // Update the address, unless there was an error
399                  addr_update = ~lsu_err_q;
400                  ls_fsm_ns   = WAIT_RVALID;
401                end
                   MISSING_ELSE
                   ==>
402              end
403        
404              WAIT_RVALID: begin
405                if (data_rvalid_i || pmp_err_q) begin
                   -11-  
406                  data_valid_o        = 1'b1;
                     ==>
407                  // Data error from either part
408                  data_or_pmp_err     = lsu_err_q | data_err_i | pmp_err_q;
409                  handle_misaligned_d = 1'b0;
410                  ls_fsm_ns           = IDLE;
411                end else begin
412                  ls_fsm_ns           = WAIT_RVALID;
                     ==>
413                end
414              end
415        
416              WAIT_RVALID_DONE: begin
417                // tell ID/EX stage to update the address (to make sure the
418                // second address can be captured correctly for mtval and PMP checking)
419                addr_incr_req_o = 1'b1;
420                // Wait for the first rvalid, second request is already granted
421                if (data_rvalid_i) begin
                   -12-  
422                  // Update the pmp error for the second part
423                  pmp_err_d = data_pmp_err_i;
                     ==>
424                  // The first part cannot see a PMP error in this state
425                  lsu_err_d = data_err_i;
426                  // Now we can update the address for the second part if no error
427                  addr_update = ~data_err_i;
428                  // Capture the first rdata for loads
429                  rdata_update = ~data_we_q;
430                  // Wait for second rvalid
431                  ls_fsm_ns = WAIT_RVALID;
432                end
                   MISSING_ELSE
                   ==>
433              end
434        
435              default: begin
436                ls_fsm_ns = IDLE;
                   ==>

Branches:

-1-               -2- -3- -4- -5- -6- -7- -8- -9- -10- -11- -12- Status  
IDLE              1   1   1   -   -   -   -   -   -    -    -    Covered 
IDLE              1   1   0   -   -   -   -   -   -    -    -    Covered 
IDLE              1   0   -   1   -   -   -   -   -    -    -    Covered 
IDLE              1   0   -   0   -   -   -   -   -    -    -    Covered 
IDLE              0   -   -   -   -   -   -   -   -    -    -    Covered 
WAIT_GNT_MIS      -   -   -   -   1   -   -   -   -    -    -    Covered 
WAIT_GNT_MIS      -   -   -   -   0   -   -   -   -    -    -    Covered 
WAIT_RVALID_MIS   -   -   -   -   -   1   1   -   -    -    -    Covered 
WAIT_RVALID_MIS   -   -   -   -   -   1   0   -   -    -    -    Covered 
WAIT_RVALID_MIS   -   -   -   -   -   0   -   1   -    -    -    Covered 
WAIT_RVALID_MIS   -   -   -   -   -   0   -   0   -    -    -    Covered 
WAIT_GNT          -   -   -   -   -   -   -   -   1    -    -    Covered 
WAIT_GNT          -   -   -   -   -   -   -   -   0    -    -    Covered 
WAIT_RVALID       -   -   -   -   -   -   -   -   -    1    -    Covered 
WAIT_RVALID       -   -   -   -   -   -   -   -   -    0    -    Covered 
WAIT_RVALID_DONE  -   -   -   -   -   -   -   -   -    -    1    Covered 
WAIT_RVALID_DONE  -   -   -   -   -   -   -   -   -    -    0    Covered 
default           -   -   -   -   -   -   -   -   -    -    -    Covered 


443            if (!rst_ni) begin
               -1-  
444              ls_fsm_cs           <= IDLE;
                 ==>
445              handle_misaligned_q <= '0;
446              pmp_err_q           <= '0;
447              lsu_err_q           <= '0;
448            end else begin
449              ls_fsm_cs           <= ls_fsm_ns;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.load_store_unit_i(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       4     4         100.00  4                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            4     4         100.00  4                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name         Attempts  Real Successes Failures Incomplete 
unnamed$$_68 159095193 4648786        0        0          
unnamed$$_69 159095193 1803           0        0          
unnamed$$_70 159095193 27896040       0        0          
unnamed$$_71 159095193 27896040       0        0          


===============================================================================
Module : ibex_core
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 98.10  99.07 --     --      97.14 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_core.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                             
 98.10  99.07 --     --      97.14 --     core_ibex_tb_top.dut.u_ibex_core 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_core

             Line No.   Total   Covered  Percent
TOTAL                      107      106    99.07
ALWAYS            274        3        3   100.00
ALWAYS            704       41       41   100.00
ALWAYS            751        7        7   100.00
ALWAYS            762        7        7   100.00
ALWAYS            774        5        4    80.00
ALWAYS            783        3        3   100.00
ALWAYS            792        5        5   100.00
ALWAYS            801        5        5   100.00
ALWAYS            813       10       10   100.00
ALWAYS            831        5        5   100.00
ALWAYS            841        3        3   100.00
ALWAYS            848        5        5   100.00
ALWAYS            863        5        5   100.00
ALWAYS            876        3        3   100.00

273                       always_ff @(posedge clk_i or negedge rst_ni) begin
274        1/1              if (!rst_ni) begin
275        1/1                core_busy_q <= 1'b0;
276                         end else begin
277        1/1                core_busy_q <= core_busy_d;
278                         end
279                       end
280                     
281                       assign clock_en     = core_busy_q | debug_req_i | irq_pending | irq_nm_i;
282                       assign core_sleep_o = ~clock_en;
283                     
284                       // main clock gate of the core
285                       // generates all clocks except the one for the debug unit which is
286                       // independent
287                       prim_clock_gating core_clock_gate_i (
288                           .clk_i     ( clk_i           ),
289                           .en_i      ( clock_en        ),
290                           .test_en_i ( test_en_i       ),
291                           .clk_o     ( clk             )
292                       );
293                     
294                       //////////////
295                       // IF stage //
296                       //////////////
297                     
298                       ibex_if_stage #(
299                           .DmHaltAddr       ( DmHaltAddr      ),
300                           .DmExceptionAddr  ( DmExceptionAddr )
301                       ) if_stage_i (
302                           .clk_i                    ( clk                    ),
303                           .rst_ni                   ( rst_ni                 ),
304                     
305                           .boot_addr_i              ( boot_addr_i            ),
306                           .req_i                    ( instr_req_int          ), // instruction request control
307                     
308                           // instruction cache interface
309                           .instr_req_o              ( instr_req_out          ),
310                           .instr_addr_o             ( instr_addr_o           ),
311                           .instr_gnt_i              ( instr_gnt_i            ),
312                           .instr_rvalid_i           ( instr_rvalid_i         ),
313                           .instr_rdata_i            ( instr_rdata_i          ),
314                           .instr_err_i              ( instr_err_i            ),
315                           .instr_pmp_err_i          ( pmp_req_err[PMP_I]     ),
316                     
317                           // outputs to ID stage
318                           .instr_valid_id_o         ( instr_valid_id         ),
319                           .instr_new_id_o           ( instr_new_id           ),
320                           .instr_rdata_id_o         ( instr_rdata_id         ),
321                           .instr_rdata_c_id_o       ( instr_rdata_c_id       ),
322                           .instr_is_compressed_id_o ( instr_is_compressed_id ),
323                           .instr_fetch_err_o        ( instr_fetch_err        ),
324                           .illegal_c_insn_id_o      ( illegal_c_insn_id      ),
325                           .pc_if_o                  ( pc_if                  ),
326                           .pc_id_o                  ( pc_id                  ),
327                     
328                           // control signals
329                           .instr_valid_clear_i      ( instr_valid_clear      ),
330                           .pc_set_i                 ( pc_set                 ),
331                           .pc_mux_i                 ( pc_mux_id              ),
332                           .exc_pc_mux_i             ( exc_pc_mux_id          ),
333                           .exc_cause                ( exc_cause              ),
334                     
335                           // jump targets
336                           .jump_target_ex_i         ( jump_target_ex         ),
337                     
338                           // CSRs
339                           .csr_mepc_i               ( csr_mepc               ), // exception return address
340                           .csr_depc_i               ( csr_depc               ), // debug return address
341                           .csr_mtvec_i              ( csr_mtvec              ), // trap-vector base address
342                           .csr_mtvec_init_o         ( csr_mtvec_init         ),
343                     
344                           // pipeline stalls
345                           .id_in_ready_i            ( id_in_ready            ),
346                     
347                           .if_busy_o                ( if_busy                ),
348                           .perf_imiss_o             ( perf_imiss             )
349                       );
350                     
351                       // Qualify the instruction request with PMP error
352                       assign instr_req_o = instr_req_out & ~pmp_req_err[PMP_I];
353                     
354                       //////////////
355                       // ID stage //
356                       //////////////
357                     
358                       ibex_id_stage #(
359                           .RV32E ( RV32E ),
360                           .RV32M ( RV32M )
361                       ) id_stage_i (
362                           .clk_i                        ( clk                    ),
363                           .rst_ni                       ( rst_ni                 ),
364                     
365                           .test_en_i                    ( test_en_i              ),
366                     
367                           // Processor Enable
368                           .fetch_enable_i               ( fetch_enable_i         ),
369                           .ctrl_busy_o                  ( ctrl_busy              ),
370                           .illegal_insn_o               ( illegal_insn_id        ),
371                     
372                           // from/to IF-ID pipeline register
373                           .instr_valid_i                ( instr_valid_id         ),
374                           .instr_new_i                  ( instr_new_id           ),
375                           .instr_rdata_i                ( instr_rdata_id         ),
376                           .instr_rdata_c_i              ( instr_rdata_c_id       ),
377                           .instr_is_compressed_i        ( instr_is_compressed_id ),
378                     
379                           // Jumps and branches
380                           .branch_decision_i            ( branch_decision        ),
381                     
382                           // IF and ID control signals
383                           .id_in_ready_o                ( id_in_ready            ),
384                           .instr_valid_clear_o          ( instr_valid_clear      ),
385                           .instr_req_o                  ( instr_req_int          ),
386                           .pc_set_o                     ( pc_set                 ),
387                           .pc_mux_o                     ( pc_mux_id              ),
388                           .exc_pc_mux_o                 ( exc_pc_mux_id          ),
389                           .exc_cause_o                  ( exc_cause              ),
390                     
391                           .instr_fetch_err_i            ( instr_fetch_err        ),
392                           .illegal_c_insn_i             ( illegal_c_insn_id      ),
393                     
394                           .pc_id_i                      ( pc_id                  ),
395                     
396                           // Stalls
397                           .ex_valid_i                   ( ex_valid               ),
398                           .lsu_valid_i                  ( lsu_data_valid         ),
399                     
400                           .alu_operator_ex_o            ( alu_operator_ex        ),
401                           .alu_operand_a_ex_o           ( alu_operand_a_ex       ),
402                           .alu_operand_b_ex_o           ( alu_operand_b_ex       ),
403                     
404                           .mult_en_ex_o                 ( mult_en_ex             ),
405                           .div_en_ex_o                  ( div_en_ex              ),
406                           .multdiv_operator_ex_o        ( multdiv_operator_ex    ),
407                           .multdiv_signed_mode_ex_o     ( multdiv_signed_mode_ex ),
408                           .multdiv_operand_a_ex_o       ( multdiv_operand_a_ex   ),
409                           .multdiv_operand_b_ex_o       ( multdiv_operand_b_ex   ),
410                     
411                           // CSR ID/EX
412                           .csr_access_o                 ( csr_access             ),
413                           .csr_op_o                     ( csr_op                 ),
414                           .csr_save_if_o                ( csr_save_if            ), // control signal to save PC
415                           .csr_save_id_o                ( csr_save_id            ), // control signal to save PC
416                           .csr_restore_mret_id_o        ( csr_restore_mret_id    ), // restore mstatus upon DRET
417                           .csr_restore_dret_id_o        ( csr_restore_dret_id    ), // restore mstatus upon MRET
418                           .csr_save_cause_o             ( csr_save_cause         ),
419                           .csr_mtval_o                  ( csr_mtval              ),
420                           .priv_mode_i                  ( priv_mode_id           ),
421                           .csr_mstatus_tw_i             ( csr_mstatus_tw         ),
422                           .illegal_csr_insn_i           ( illegal_csr_insn_id    ),
423                     
424                           // LSU
425                           .data_req_ex_o                ( data_req_ex            ), // to load store unit
426                           .data_we_ex_o                 ( data_we_ex             ), // to load store unit
427                           .data_type_ex_o               ( data_type_ex           ), // to load store unit
428                           .data_sign_ext_ex_o           ( data_sign_ext_ex       ), // to load store unit
429                           .data_wdata_ex_o              ( data_wdata_ex          ), // to load store unit
430                     
431                           .lsu_addr_incr_req_i          ( lsu_addr_incr_req      ),
432                           .lsu_addr_last_i              ( lsu_addr_last          ),
433                     
434                           .lsu_load_err_i               ( lsu_load_err           ),
435                           .lsu_store_err_i              ( lsu_store_err          ),
436                     
437                           // Interrupt Signals
438                           .csr_mstatus_mie_i            ( csr_mstatus_mie        ),
439                           .csr_msip_i                   ( csr_msip               ),
440                           .csr_mtip_i                   ( csr_mtip               ),
441                           .csr_meip_i                   ( csr_meip               ),
442                           .csr_mfip_i                   ( csr_mfip               ),
443                           .irq_pending_i                ( irq_pending            ),
444                           .irq_nm_i                     ( irq_nm_i               ),
445                           .nmi_mode_o                   ( nmi_mode               ),
446                     
447                           // Debug Signal
448                           .debug_mode_o                 ( debug_mode             ),
449                           .debug_cause_o                ( debug_cause            ),
450                           .debug_csr_save_o             ( debug_csr_save         ),
451                           .debug_req_i                  ( debug_req_i            ),
452                           .debug_single_step_i          ( debug_single_step      ),
453                           .debug_ebreakm_i              ( debug_ebreakm          ),
454                           .debug_ebreaku_i              ( debug_ebreaku          ),
455                           .trigger_match_i              ( trigger_match          ),
456                     
457                           // write data to commit in the register file
458                           .regfile_wdata_lsu_i          ( regfile_wdata_lsu      ),
459                           .regfile_wdata_ex_i           ( regfile_wdata_ex       ),
460                           .csr_rdata_i                  ( csr_rdata              ),
461                     
462                     `ifdef RVFI
463                           .rfvi_reg_raddr_ra_o          ( rvfi_rs1_addr_id       ),
464                           .rfvi_reg_rdata_ra_o          ( rvfi_rs1_data_id       ),
465                           .rfvi_reg_raddr_rb_o          ( rvfi_rs2_addr_id       ),
466                           .rfvi_reg_rdata_rb_o          ( rvfi_rs2_data_id       ),
467                           .rfvi_reg_waddr_rd_o          ( rvfi_rd_addr_id        ),
468                           .rfvi_reg_wdata_rd_o          ( rvfi_rd_wdata_id       ),
469                           .rfvi_reg_we_o                ( rvfi_rd_we_id          ),
470                     `endif
471                     
472                           // Performance Counters
473                           .perf_jump_o                  ( perf_jump              ),
474                           .perf_branch_o                ( perf_branch            ),
475                           .perf_tbranch_o               ( perf_tbranch           ),
476                           .instr_ret_o                  ( instr_ret              ),
477                           .instr_ret_compressed_o       ( instr_ret_compressed   )
478                       );
479                     
480                       // for RVFI only
481                       assign unused_illegal_insn_id = illegal_insn_id;
482                     
483                       ibex_ex_block #(
484                           .RV32M                      ( RV32M                    ),
485                           .MultiplierImplementation   ( MultiplierImplementation )
486                       ) ex_block_i (
487                           .clk_i                      ( clk                      ),
488                           .rst_ni                     ( rst_ni                   ),
489                     
490                           // ALU signal from ID stage
491                           .alu_operator_i             ( alu_operator_ex          ),
492                           .alu_operand_a_i            ( alu_operand_a_ex         ),
493                           .alu_operand_b_i            ( alu_operand_b_ex         ),
494                     
495                           // Multipler/Divider signal from ID stage
496                           .multdiv_operator_i         ( multdiv_operator_ex      ),
497                           .mult_en_i                  ( mult_en_ex               ),
498                           .div_en_i                   ( div_en_ex                ),
499                           .multdiv_signed_mode_i      ( multdiv_signed_mode_ex   ),
500                           .multdiv_operand_a_i        ( multdiv_operand_a_ex     ),
501                           .multdiv_operand_b_i        ( multdiv_operand_b_ex     ),
502                     
503                           // Outputs
504                           .alu_adder_result_ex_o      ( alu_adder_result_ex      ), // to LSU
505                           .regfile_wdata_ex_o         ( regfile_wdata_ex         ), // to ID
506                     
507                           .jump_target_o              ( jump_target_ex           ), // to IF
508                           .branch_decision_o          ( branch_decision          ), // to ID
509                     
510                           .ex_valid_o                 ( ex_valid                 )
511                       );
512                     
513                       /////////////////////
514                       // Load/store unit //
515                       /////////////////////
516                     
517                       assign data_req_o = data_req_out & ~pmp_req_err[PMP_D];
518                     
519                       ibex_load_store_unit  load_store_unit_i (
520                           .clk_i                 ( clk                 ),
521                           .rst_ni                ( rst_ni              ),
522                     
523                           // data interface
524                           .data_req_o            ( data_req_out        ),
525                           .data_gnt_i            ( data_gnt_i          ),
526                           .data_rvalid_i         ( data_rvalid_i       ),
527                           .data_err_i            ( data_err_i          ),
528                           .data_pmp_err_i        ( pmp_req_err[PMP_D]  ),
529                     
530                           .data_addr_o           ( data_addr_o         ),
531                           .data_we_o             ( data_we_o           ),
532                           .data_be_o             ( data_be_o           ),
533                           .data_wdata_o          ( data_wdata_o        ),
534                           .data_rdata_i          ( data_rdata_i        ),
535                     
536                           // signals to/from ID/EX stage
537                           .data_we_ex_i          ( data_we_ex          ),
538                           .data_type_ex_i        ( data_type_ex        ),
539                           .data_wdata_ex_i       ( data_wdata_ex       ),
540                           .data_sign_ext_ex_i    ( data_sign_ext_ex    ),
541                     
542                           .data_rdata_ex_o       ( regfile_wdata_lsu   ),
543                           .data_req_ex_i         ( data_req_ex         ),
544                     
545                           .adder_result_ex_i     ( alu_adder_result_ex ),
546                     
547                           .addr_incr_req_o       ( lsu_addr_incr_req   ),
548                           .addr_last_o           ( lsu_addr_last       ),
549                           .data_valid_o          ( lsu_data_valid      ),
550                     
551                           // exception signals
552                           .load_err_o            ( lsu_load_err        ),
553                           .store_err_o           ( lsu_store_err       ),
554                     
555                           .busy_o                ( lsu_busy            )
556                       );
557                     
558                     
559                       /////////////////////////////////////////
560                       // CSRs (Control and Status Registers) //
561                       /////////////////////////////////////////
562                     
563                       assign csr_wdata  = alu_operand_a_ex;
564                       assign csr_addr   = csr_num_e'(csr_access ? alu_operand_b_ex[11:0] : 12'b0);
565                     
566                       assign perf_load  = data_req_o & data_gnt_i & (~data_we_o);
567                       assign perf_store = data_req_o & data_gnt_i & data_we_o;
568                     
569                       // CSR access is qualified by instruction fetch error
570                       assign valid_csr_id = instr_new_id & ~instr_fetch_err;
571                     
572                       ibex_cs_registers #(
573                           .DbgTriggerEn     ( DbgTriggerEn     ),
574                           .MHPMCounterNum   ( MHPMCounterNum   ),
575                           .MHPMCounterWidth ( MHPMCounterWidth ),
576                           .PMPEnable        ( PMPEnable        ),
577                           .PMPGranularity   ( PMPGranularity   ),
578                           .PMPNumRegions    ( PMPNumRegions    ),
579                           .RV32E            ( RV32E            ),
580                           .RV32M            ( RV32M            )
581                       ) cs_registers_i (
582                           .clk_i                   ( clk                    ),
583                           .rst_ni                  ( rst_ni                 ),
584                     
585                           // Hart ID from outside
586                           .hart_id_i               ( hart_id_i              ),
587                           .priv_mode_id_o          ( priv_mode_id           ),
588                           .priv_mode_if_o          ( priv_mode_if           ),
589                           .priv_mode_lsu_o         ( priv_mode_lsu          ),
590                     
591                           // mtvec
592                           .csr_mtvec_o             ( csr_mtvec              ),
593                           .csr_mtvec_init_i        ( csr_mtvec_init         ),
594                           .boot_addr_i             ( boot_addr_i            ),
595                     
596                           // Interface to CSRs (SRAM like)
597                           .csr_access_i            ( csr_access             ),
598                           .csr_addr_i              ( csr_addr               ),
599                           .csr_wdata_i             ( csr_wdata              ),
600                           .csr_op_i                ( csr_op                 ),
601                           .csr_rdata_o             ( csr_rdata              ),
602                     
603                           // Interrupt related control signals
604                           .irq_software_i          ( irq_software_i         ),
605                           .irq_timer_i             ( irq_timer_i            ),
606                           .irq_external_i          ( irq_external_i         ),
607                           .irq_fast_i              ( irq_fast_i             ),
608                           .irq_pending_o           ( irq_pending            ),
609                           .nmi_mode_i              ( nmi_mode               ),
610                           .csr_msip_o              ( csr_msip               ),
611                           .csr_mtip_o              ( csr_mtip               ),
612                           .csr_meip_o              ( csr_meip               ),
613                           .csr_mfip_o              ( csr_mfip               ),
614                           .csr_mstatus_mie_o       ( csr_mstatus_mie        ),
615                           .csr_mstatus_tw_o        ( csr_mstatus_tw         ),
616                           .csr_mepc_o              ( csr_mepc               ),
617                     
618                           // PMP
619                           .csr_pmp_cfg_o           ( csr_pmp_cfg            ),
620                           .csr_pmp_addr_o          ( csr_pmp_addr           ),
621                     
622                           // debug
623                           .csr_depc_o              ( csr_depc               ),
624                           .debug_mode_i            ( debug_mode             ),
625                           .debug_cause_i           ( debug_cause            ),
626                           .debug_csr_save_i        ( debug_csr_save         ),
627                           .debug_single_step_o     ( debug_single_step      ),
628                           .debug_ebreakm_o         ( debug_ebreakm          ),
629                           .debug_ebreaku_o         ( debug_ebreaku          ),
630                           .trigger_match_o         ( trigger_match          ),
631                     
632                           .pc_if_i                 ( pc_if                  ),
633                           .pc_id_i                 ( pc_id                  ),
634                     
635                           .csr_save_if_i           ( csr_save_if            ),
636                           .csr_save_id_i           ( csr_save_id            ),
637                           .csr_restore_mret_i      ( csr_restore_mret_id    ),
638                           .csr_restore_dret_i      ( csr_restore_dret_id    ),
639                           .csr_save_cause_i        ( csr_save_cause         ),
640                           .csr_mcause_i            ( exc_cause              ),
641                           .csr_mtval_i             ( csr_mtval              ),
642                           .illegal_csr_insn_o      ( illegal_csr_insn_id    ),
643                     
644                           .instr_new_id_i          ( valid_csr_id           ),
645                     
646                           // performance counter related signals
647                           .instr_ret_i             ( instr_ret              ),
648                           .instr_ret_compressed_i  ( instr_ret_compressed   ),
649                           .imiss_i                 ( perf_imiss             ),
650                           .pc_set_i                ( pc_set                 ),
651                           .jump_i                  ( perf_jump              ),
652                           .branch_i                ( perf_branch            ),
653                           .branch_taken_i          ( perf_tbranch           ),
654                           .mem_load_i              ( perf_load              ),
655                           .mem_store_i             ( perf_store             ),
656                           .lsu_busy_i              ( lsu_busy               )
657                       );
658                     
659                       if (PMPEnable) begin : g_pmp
660                         logic [33:0] pmp_req_addr [PMP_NUM_CHAN];
661                         pmp_req_e    pmp_req_type [PMP_NUM_CHAN];
662                         priv_lvl_e   pmp_priv_lvl [PMP_NUM_CHAN];
663                     
664                         assign pmp_req_addr[PMP_I] = {2'b00,instr_addr_o[31:0]};
665                         assign pmp_req_type[PMP_I] = PMP_ACC_EXEC;
666                         assign pmp_priv_lvl[PMP_I] = priv_mode_if;
667                         assign pmp_req_addr[PMP_D] = {2'b00,data_addr_o[31:0]};
668                         assign pmp_req_type[PMP_D] = data_we_o ? PMP_ACC_WRITE : PMP_ACC_READ;
669                         assign pmp_priv_lvl[PMP_D] = priv_mode_lsu;
670                     
671                         ibex_pmp #(
672                             .PMPGranularity        ( PMPGranularity ),
673                             .PMPNumChan            ( PMP_NUM_CHAN   ),
674                             .PMPNumRegions         ( PMPNumRegions  )
675                         ) pmp_i (
676                             .clk_i                 ( clk            ),
677                             .rst_ni                ( rst_ni         ),
678                             // Interface to CSRs
679                             .csr_pmp_cfg_i         ( csr_pmp_cfg    ),
680                             .csr_pmp_addr_i        ( csr_pmp_addr   ),
681                             .priv_mode_i           ( pmp_priv_lvl   ),
682                             // Access checking channels
683                             .pmp_req_addr_i        ( pmp_req_addr   ),
684                             .pmp_req_type_i        ( pmp_req_type   ),
685                             .pmp_req_err_o         ( pmp_req_err    )
686                         );
687                       end else begin : g_no_pmp
688                         // Unused signal tieoff
689                         priv_lvl_e unused_priv_lvl_if, unused_priv_lvl_ls;
690                         logic [33:0] unused_csr_pmp_addr [PMPNumRegions];
691                         pmp_cfg_t    unused_csr_pmp_cfg  [PMPNumRegions];
692                         assign unused_priv_lvl_if = priv_mode_if;
693                         assign unused_priv_lvl_ls = priv_mode_lsu;
694                         assign unused_csr_pmp_addr = csr_pmp_addr;
695                         assign unused_csr_pmp_cfg = csr_pmp_cfg;
696                     
697                         // Output tieoff
698                         assign pmp_req_err[PMP_I] = 1'b0;
699                         assign pmp_req_err[PMP_D] = 1'b0;
700                       end
701                     
702                     `ifdef RVFI
703                       always_ff @(posedge clk or negedge rst_ni) begin
704        1/1              if (!rst_ni) begin
705        1/1                rvfi_halt              <= '0;
706        1/1                rvfi_trap              <= '0;
707        1/1                rvfi_intr              <= '0;
708        1/1                rvfi_order             <= '0;
709        1/1                rvfi_insn              <= '0;
710        1/1                rvfi_mode              <= {PRIV_LVL_M};
711        1/1                rvfi_rs1_addr          <= '0;
712        1/1                rvfi_rs2_addr          <= '0;
713        1/1                rvfi_pc_rdata          <= '0;
714        1/1                rvfi_pc_wdata          <= '0;
715        1/1                rvfi_mem_rmask         <= '0;
716        1/1                rvfi_mem_wmask         <= '0;
717        1/1                rvfi_valid             <= '0;
718        1/1                rvfi_rs1_rdata         <= '0;
719        1/1                rvfi_rs2_rdata         <= '0;
720        1/1                rvfi_rd_wdata          <= '0;
721        1/1                rvfi_rd_addr           <= '0;
722        1/1                rvfi_mem_rdata         <= '0;
723        1/1                rvfi_mem_wdata         <= '0;
724        1/1                rvfi_mem_addr          <= '0;
725                         end else begin
726        1/1                rvfi_halt              <= '0;
727        1/1                rvfi_trap              <= illegal_insn_id;
728        1/1                rvfi_intr              <= rvfi_intr_d;
729        1/1                rvfi_order             <= rvfi_order + 64'(rvfi_valid);
730        1/1                rvfi_insn              <= rvfi_insn_id;
731        1/1                rvfi_mode              <= {priv_mode_id};
732        1/1                rvfi_rs1_addr          <= rvfi_rs1_addr_id;
733        1/1                rvfi_rs2_addr          <= rvfi_rs2_addr_id;
734        1/1                rvfi_pc_rdata          <= pc_id;
735        1/1                rvfi_pc_wdata          <= pc_if;
736        1/1                rvfi_mem_rmask         <= rvfi_mem_mask_int;
737        1/1                rvfi_mem_wmask         <= data_we_o ? rvfi_mem_mask_int : 4'b0000;
738        1/1                rvfi_valid             <= instr_ret;
739        1/1                rvfi_rs1_rdata         <= rvfi_rs1_data_d;
740        1/1                rvfi_rs2_rdata         <= rvfi_rs2_data_d;
741        1/1                rvfi_rd_wdata          <= rvfi_rd_wdata_d;
742        1/1                rvfi_rd_addr           <= rvfi_rd_addr_d;
743        1/1                rvfi_mem_rdata         <= rvfi_mem_rdata_d;
744        1/1                rvfi_mem_wdata         <= rvfi_mem_wdata_d;
745        1/1                rvfi_mem_addr          <= rvfi_mem_addr_d;
746                         end
747                       end
748                     
749                       // Keep the mem data stable for each instruction cycle
750                       always_comb begin
751        1/1              if (rvfi_insn_new_d && lsu_data_valid) begin
752        1/1                rvfi_mem_addr_d  = alu_adder_result_ex;
753        1/1                rvfi_mem_rdata_d = regfile_wdata_lsu;
754        1/1                rvfi_mem_wdata_d = data_wdata_ex;
755                         end else begin
756        1/1                rvfi_mem_addr_d  = rvfi_mem_addr_q;
757        1/1                rvfi_mem_rdata_d = rvfi_mem_rdata_q;
758        1/1                rvfi_mem_wdata_d = rvfi_mem_wdata_q;
759                         end
760                       end
761                       always_ff @(posedge clk or negedge rst_ni) begin
762        1/1              if (!rst_ni) begin
763        1/1                rvfi_mem_addr_q  <= '0;
764        1/1                rvfi_mem_rdata_q <= '0;
765        1/1                rvfi_mem_wdata_q <= '0;
766                         end else begin
767        1/1                rvfi_mem_addr_q  <= rvfi_mem_addr_d;
768        1/1                rvfi_mem_rdata_q <= rvfi_mem_rdata_d;
769        1/1                rvfi_mem_wdata_q <= rvfi_mem_wdata_d;
770                         end
771                       end
772                       // Byte enable based on data type
773                       always_comb begin
774        1/1              unique case (data_type_ex)
775        1/1                2'b00:   rvfi_mem_mask_int = 4'b1111;
776        1/1                2'b01:   rvfi_mem_mask_int = 4'b0011;
777        1/1                2'b10:   rvfi_mem_mask_int = 4'b0001;
778        0/1     ==>        default: rvfi_mem_mask_int = 4'b0000;
779                         endcase
780                       end
781                     
782                       always_comb begin
783        1/1              if (instr_is_compressed_id) begin
784        1/1                rvfi_insn_id = {16'b0, instr_rdata_c_id};
785                         end else begin
786        1/1                rvfi_insn_id = instr_rdata_id;
787                         end
788                       end
789                     
790                       // Source register data are kept stable for each instruction cycle
791                       always_comb begin
792        1/1              if (instr_new_id) begin
793        1/1                rvfi_rs1_data_d = rvfi_rs1_data_id;
794        1/1                rvfi_rs2_data_d = rvfi_rs2_data_id;
795                         end else begin
796        1/1                rvfi_rs1_data_d = rvfi_rs1_data_q;
797        1/1                rvfi_rs2_data_d = rvfi_rs2_data_q;
798                         end
799                       end
800                       always_ff @(posedge clk or negedge rst_ni) begin
801        1/1              if (!rst_ni) begin
802        1/1                rvfi_rs1_data_q <= '0;
803        1/1                rvfi_rs2_data_q <= '0;
804                         end else begin
805        1/1                rvfi_rs1_data_q <= rvfi_rs1_data_d;
806        1/1                rvfi_rs2_data_q <= rvfi_rs2_data_d;
807                         end
808                       end
809                     
810                       // RD write register is refreshed only once per cycle and
811                       // then it is kept stable for the cycle.
812                       always_comb begin
813        1/1              if (rvfi_insn_new_d) begin
814        1/1                if (!rvfi_rd_we_id) begin
815        1/1                  rvfi_rd_addr_d    = '0;
816        1/1                  rvfi_rd_wdata_d   = '0;
817                           end else begin
818        1/1                  rvfi_rd_addr_d = rvfi_rd_addr_id;
819        1/1                  if (rvfi_rd_addr_id == 5'h0) begin
820        1/1                    rvfi_rd_wdata_d = '0;
821                             end else begin
822        1/1                    rvfi_rd_wdata_d = rvfi_rd_wdata_id;
823                             end
824                           end
825                         end else begin
826        1/1                rvfi_rd_addr_d    = rvfi_rd_addr_q;
827        1/1                rvfi_rd_wdata_d   = rvfi_rd_wdata_q;
828                         end
829                       end
830                       always_ff @(posedge clk or negedge rst_ni) begin
831        1/1              if (!rst_ni) begin
832        1/1                rvfi_rd_addr_q    <= '0;
833        1/1                rvfi_rd_wdata_q   <= '0;
834                         end else begin
835        1/1                rvfi_rd_addr_q    <= rvfi_rd_addr_d;
836        1/1                rvfi_rd_wdata_q   <= rvfi_rd_wdata_d;
837                         end
838                       end
839                     
840                       always_comb begin
841        1/1              if (instr_new_id) begin
842        1/1                rvfi_insn_new_d = 1'b1;
843                         end else begin
844        1/1                rvfi_insn_new_d = rvfi_insn_new_q;
845                         end
846                       end
847                       always_ff @(posedge clk or negedge rst_ni) begin
848        1/1              if (!rst_ni) begin
849        1/1                rvfi_insn_new_q <= 1'b0;
850                         end else begin
851        1/1                if (instr_ret) begin
852        1/1                  rvfi_insn_new_q <= 1'b0;
853                           end else begin
854        1/1                  rvfi_insn_new_q <= rvfi_insn_new_d;
855                           end
856                         end
857                       end
858                     
859                       // generate rvfi_intr_d
860                       assign rvfi_intr_d = rvfi_set_trap_pc_q & rvfi_insn_new_d;
861                     
862                       always_comb begin
863        1/1              rvfi_set_trap_pc_d = rvfi_set_trap_pc_q;
864                     
865        1/1              if (pc_set && pc_mux_id == PC_EXC &&
866                             (exc_pc_mux_id == EXC_PC_EXC || exc_pc_mux_id == EXC_PC_IRQ)) begin
867                           // PC is set to enter a trap handler
868        1/1                rvfi_set_trap_pc_d = 1'b1;
869        1/1              end else if (rvfi_set_trap_pc_q && instr_ret) begin
870                           // first instruction has been executed after PC is set to trap handler
871        1/1                rvfi_set_trap_pc_d = 1'b0;
872                         end
                        MISSING_ELSE
873                       end
874                     
875                       always_ff @(posedge clk or negedge rst_ni) begin
876        1/1              if (!rst_ni) begin
877        1/1                rvfi_set_trap_pc_q <= 1'b0;
878                         end else begin
879        1/1                rvfi_set_trap_pc_q <= rvfi_set_trap_pc_d;

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_core
         Line No. Total Covered Percent 
Branches          35    34      97.14   
IF       274      2     2       100.00  
IF       704      3     3       100.00  
IF       751      2     2       100.00  
IF       762      2     2       100.00  
CASE     774      4     3       75.00   
IF       783      2     2       100.00  
IF       792      2     2       100.00  
IF       801      2     2       100.00  
IF       813      4     4       100.00  
IF       831      2     2       100.00  
IF       841      2     2       100.00  
IF       848      3     3       100.00  
IF       865      3     3       100.00  
IF       876      2     2       100.00  


274            if (!rst_ni) begin
               -1-  
275              core_busy_q <= 1'b0;
                 ==>
276            end else begin
277              core_busy_q <= core_busy_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


704            if (!rst_ni) begin
               -1-  
705              rvfi_halt              <= '0;
                 ==>
706              rvfi_trap              <= '0;
707              rvfi_intr              <= '0;
708              rvfi_order             <= '0;
709              rvfi_insn              <= '0;
710              rvfi_mode              <= {PRIV_LVL_M};
711              rvfi_rs1_addr          <= '0;
712              rvfi_rs2_addr          <= '0;
713              rvfi_pc_rdata          <= '0;
714              rvfi_pc_wdata          <= '0;
715              rvfi_mem_rmask         <= '0;
716              rvfi_mem_wmask         <= '0;
717              rvfi_valid             <= '0;
718              rvfi_rs1_rdata         <= '0;
719              rvfi_rs2_rdata         <= '0;
720              rvfi_rd_wdata          <= '0;
721              rvfi_rd_addr           <= '0;
722              rvfi_mem_rdata         <= '0;
723              rvfi_mem_wdata         <= '0;
724              rvfi_mem_addr          <= '0;
725            end else begin
726              rvfi_halt              <= '0;
727              rvfi_trap              <= illegal_insn_id;
728              rvfi_intr              <= rvfi_intr_d;
729              rvfi_order             <= rvfi_order + 64'(rvfi_valid);
730              rvfi_insn              <= rvfi_insn_id;
731              rvfi_mode              <= {priv_mode_id};
732              rvfi_rs1_addr          <= rvfi_rs1_addr_id;
733              rvfi_rs2_addr          <= rvfi_rs2_addr_id;
734              rvfi_pc_rdata          <= pc_id;
735              rvfi_pc_wdata          <= pc_if;
736              rvfi_mem_rmask         <= rvfi_mem_mask_int;
737              rvfi_mem_wmask         <= data_we_o ? rvfi_mem_mask_int : 4'b0000;
                                                     -2-  
                                                     ==>  
                                                     ==>  

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


751            if (rvfi_insn_new_d && lsu_data_valid) begin
               -1-  
752              rvfi_mem_addr_d  = alu_adder_result_ex;
                 ==>
753              rvfi_mem_rdata_d = regfile_wdata_lsu;
754              rvfi_mem_wdata_d = data_wdata_ex;
755            end else begin
756              rvfi_mem_addr_d  = rvfi_mem_addr_q;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


762            if (!rst_ni) begin
               -1-  
763              rvfi_mem_addr_q  <= '0;
                 ==>
764              rvfi_mem_rdata_q <= '0;
765              rvfi_mem_wdata_q <= '0;
766            end else begin
767              rvfi_mem_addr_q  <= rvfi_mem_addr_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


774            unique case (data_type_ex)
                      -1-  
775              2'b00:   rvfi_mem_mask_int = 4'b1111;
                 ==>
776              2'b01:   rvfi_mem_mask_int = 4'b0011;
                 ==>
777              2'b10:   rvfi_mem_mask_int = 4'b0001;
                 ==>
778              default: rvfi_mem_mask_int = 4'b0000;
                 ==>

Branches:

-1-     Status      
2'b00   Covered     
2'b01   Covered     
2'b10   Covered     
default Not Covered 


783            if (instr_is_compressed_id) begin
               -1-  
784              rvfi_insn_id = {16'b0, instr_rdata_c_id};
                 ==>
785            end else begin
786              rvfi_insn_id = instr_rdata_id;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


792            if (instr_new_id) begin
               -1-  
793              rvfi_rs1_data_d = rvfi_rs1_data_id;
                 ==>
794              rvfi_rs2_data_d = rvfi_rs2_data_id;
795            end else begin
796              rvfi_rs1_data_d = rvfi_rs1_data_q;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


801            if (!rst_ni) begin
               -1-  
802              rvfi_rs1_data_q <= '0;
                 ==>
803              rvfi_rs2_data_q <= '0;
804            end else begin
805              rvfi_rs1_data_q <= rvfi_rs1_data_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


813            if (rvfi_insn_new_d) begin
               -1-  
814              if (!rvfi_rd_we_id) begin
                 -2-  
815                rvfi_rd_addr_d    = '0;
                   ==>
816                rvfi_rd_wdata_d   = '0;
817              end else begin
818                rvfi_rd_addr_d = rvfi_rd_addr_id;
819                if (rvfi_rd_addr_id == 5'h0) begin
                   -3-  
820                  rvfi_rd_wdata_d = '0;
                     ==>
821                end else begin
822                  rvfi_rd_wdata_d = rvfi_rd_wdata_id;
                     ==>
823                end
824              end
825            end else begin
826              rvfi_rd_addr_d    = rvfi_rd_addr_q;
                 ==>

Branches:

-1- -2- -3- Status  
1   1   -   Covered 
1   0   1   Covered 
1   0   0   Covered 
0   -   -   Covered 


831            if (!rst_ni) begin
               -1-  
832              rvfi_rd_addr_q    <= '0;
                 ==>
833              rvfi_rd_wdata_q   <= '0;
834            end else begin
835              rvfi_rd_addr_q    <= rvfi_rd_addr_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


841            if (instr_new_id) begin
               -1-  
842              rvfi_insn_new_d = 1'b1;
                 ==>
843            end else begin
844              rvfi_insn_new_d = rvfi_insn_new_q;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


848            if (!rst_ni) begin
               -1-  
849              rvfi_insn_new_q <= 1'b0;
                 ==>
850            end else begin
851              if (instr_ret) begin
                 -2-  
852                rvfi_insn_new_q <= 1'b0;
                   ==>
853              end else begin
854                rvfi_insn_new_q <= rvfi_insn_new_d;
                   ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


865            if (pc_set && pc_mux_id == PC_EXC &&
               -1-  
866                (exc_pc_mux_id == EXC_PC_EXC || exc_pc_mux_id == EXC_PC_IRQ)) begin
867              // PC is set to enter a trap handler
868              rvfi_set_trap_pc_d = 1'b1;
                 ==>
869            end else if (rvfi_set_trap_pc_q && instr_ret) begin
                        -2-  
870              // first instruction has been executed after PC is set to trap handler
871              rvfi_set_trap_pc_d = 1'b0;
                 ==>
872            end
               MISSING_ELSE
               ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


876            if (!rst_ni) begin
               -1-  
877              rvfi_set_trap_pc_q <= 1'b0;
                 ==>
878            end else begin
879              rvfi_set_trap_pc_q <= rvfi_set_trap_pc_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 98.10  99.07 --     --      97.14 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 94.53  99.01 --      81.97  97.15 100.00 


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME      
 98.10  99.07 --     --      97.14 --     ibex_core 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME 
100.00 --     100.00 --     --     --     dut  


Subtrees :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                 
100.00 100.00 --     --     100.00 --     core_clock_gate_i    
 94.75  97.45 --     --      92.05 --     cs_registers_i(x)    
 96.26  99.32 --      89.47 100.00 --     ex_block_i           
 90.39  99.07 --      66.67  95.83 100.00 id_stage_i           
100.00 100.00 --     --     100.00 100.00 if_stage_i(x)        
100.00 100.00 --     100.00 100.00 100.00 load_store_unit_i(x) 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_decoder
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 98.50  99.22 --     --      97.78 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_decoder.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                                     
 98.69  99.61 --     --      97.78 --     core_ibex_tb_top.dut.u_ibex_core.id_stage_i.decoder_i(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_decoder

             Line No.   Total   Covered  Percent
TOTAL                      256      254    99.22
ALWAYS            133        3        3   100.00
ALWAYS            147        7        7   100.00
ALWAYS            174      246      244    99.19

132                         assign illegal_reg_rv32e = 1'b0;
133        1/1            end
134                     
135                       ///////////////////////
136                       // CSR operand check //
137        1/1            ///////////////////////
138                       always_comb begin : csr_operand_check
139        1/1              csr_op_o = csr_op;
140                     
                        MISSING_ELSE
141                         // CSRRSI/CSRRCI must not write 0 to CSRs (uimm[4:0]=='0)
142                         // CSRRS/CSRRC must not write from x0 to CSRs (rs1=='0)
143                         if ((csr_op == CSR_OP_SET || csr_op == CSR_OP_CLEAR) &&
144                             instr[`REG_S1] == '0) begin
145                           csr_op_o = CSR_OP_READ;
146                         end
147        1/1            end
148                     
149                       /////////////////////////////////
150                       // CSR-related pipline flushes //
151                       /////////////////////////////////
152                       always_comb begin : csr_pipeline_flushes
153                         csr_pipe_flush_o = 1'b0;
154        1/1          
155        1/1              // A pipeline flush is needed to let the controller react after modifying certain CSRs:
156                         // - When enabling interrupts, pending IRQs become visible to the controller only during
157        1/1              //   the next cycle. If during that cycle the core disables interrupts again, it does not
158                         //   see any pending IRQs and consequently does not start to handle interrupts.
                        MISSING_ELSE
159        1/1              // - When modifying debug CSRs - TODO: Check if this is really needed
160        1/1              if (csr_access_o == 1'b1 && (csr_op_o == CSR_OP_WRITE || csr_op_o == CSR_OP_SET)) begin
161                           if (csr_num_e'(instr[31:20]) == CSR_MSTATUS   ||
162                               csr_num_e'(instr[31:20]) == CSR_MIE) begin
163                             csr_pipe_flush_o = 1'b1;
164        1/1                end
165                         end else if (csr_access_o == 1'b1 && csr_op_o != CSR_OP_READ) begin
                        MISSING_ELSE
166                           if (csr_num_e'(instr[31:20]) == CSR_DCSR      ||
                        MISSING_ELSE
167                               csr_num_e'(instr[31:20]) == CSR_DPC       ||
168                               csr_num_e'(instr[31:20]) == CSR_DSCRATCH0 ||
169                               csr_num_e'(instr[31:20]) == CSR_DSCRATCH1) begin
170                             csr_pipe_flush_o = 1'b1;
171                           end
172                         end
173                       end
174        1/1          
175        1/1            /////////////
176        1/1            // Decoder //
177        1/1            /////////////
178        1/1          
179        1/1            always_comb begin
180                         jump_in_dec_o               = 1'b0;
181        1/1              jump_set_o                  = 1'b0;
182        1/1              branch_in_dec_o             = 1'b0;
183                         alu_operator_o              = ALU_SLTU;
184        1/1              alu_op_a_mux_sel_o          = OP_A_IMM;
185        1/1              alu_op_b_mux_sel_o          = OP_B_IMM;
186        1/1          
187        1/1              imm_a_mux_sel_o             = IMM_A_ZERO;
188                         imm_b_mux_sel_o             = IMM_B_I;
189        1/1          
190        1/1              mult_en_o                   = 1'b0;
191                         div_en_o                    = 1'b0;
192        1/1              multdiv_operator_o          = MD_OP_MULL;
193        1/1              multdiv_signed_mode_o       = 2'b00;
194        1/1          
195                         regfile_wdata_sel_o         = RF_WD_EX;
196        1/1              regfile_we                  = 1'b0;
197        1/1          
198        1/1              csr_access_o                = 1'b0;
199        1/1              csr_illegal                 = 1'b0;
200                         csr_op                      = CSR_OP_READ;
201        1/1          
202        1/1              data_we_o                   = 1'b0;
203        1/1              data_type_o                 = 2'b00;
204        1/1              data_sign_extension_o       = 1'b0;
205        1/1              data_req_o                  = 1'b0;
206        1/1          
207                         illegal_insn                = 1'b0;
208        1/1              ebrk_insn_o                 = 1'b0;
209                         mret_insn_o                 = 1'b0;
210        1/1              dret_insn_o                 = 1'b0;
211                         ecall_insn_o                = 1'b0;
212                         wfi_insn_o                  = 1'b0;
213                     
214                         opcode                      = opcode_e'(instr[6:0]);
215                     
216                         unique case (opcode)
217        1/1          
218        1/1                ///////////
219                           // Jumps //
220        1/1                ///////////
221        1/1          
222        1/1                OPCODE_JAL: begin   // Jump and Link
223        1/1                  jump_in_dec_o         = 1'b1;
224        1/1                  if (instr_new_i) begin
225        1/1                    // Calculate jump target
226                               alu_op_a_mux_sel_o  = OP_A_CURRPC;
227                               alu_op_b_mux_sel_o  = OP_B_IMM;
228        1/1                    imm_b_mux_sel_o     = IMM_B_J;
229        1/1                    alu_operator_o      = ALU_ADD;
230        1/1                    regfile_we          = 1'b0;
231        1/1                    jump_set_o          = 1'b1;
232        1/1                  end else begin
233                               // Calculate and store PC+4
234                               alu_op_a_mux_sel_o  = OP_A_CURRPC;
235                               alu_op_b_mux_sel_o  = OP_B_IMM;
236                               imm_b_mux_sel_o     = IMM_B_INCR_PC;
237        1/1                    alu_operator_o      = ALU_ADD;
238        1/1                    regfile_we          = 1'b1;
239                             end
240        1/1                end
241        1/1          
242        1/1                OPCODE_JALR: begin  // Jump and Link Register
243        1/1                  jump_in_dec_o         = 1'b1;
244        1/1                  if (instr_new_i) begin
245        1/1                    // Calculate jump target
246                               alu_op_a_mux_sel_o  = OP_A_REG_A;
247                               alu_op_b_mux_sel_o  = OP_B_IMM;
248        1/1                    imm_b_mux_sel_o     = IMM_B_I;
249        1/1                    alu_operator_o      = ALU_ADD;
250        1/1                    regfile_we          = 1'b0;
251        1/1                    jump_set_o          = 1'b1;
252        1/1                  end else begin
253                               // Calculate and store PC+4
254        1/1                    alu_op_a_mux_sel_o  = OP_A_CURRPC;
255        1/1                    alu_op_b_mux_sel_o  = OP_B_IMM;
256                               imm_b_mux_sel_o     = IMM_B_INCR_PC;
                        MISSING_ELSE
257                               alu_operator_o      = ALU_ADD;
258                               regfile_we          = 1'b1;
259                             end
260        1/1                  if (instr[14:12] != 3'b0) begin
261                               illegal_insn = 1'b1;
262        1/1                  end
263        1/1                end
264        1/1          
265        1/1                OPCODE_BRANCH: begin // Branch
266        1/1                  branch_in_dec_o       = 1'b1;
267        1/1                  // Check branch condition selection
268        1/1                  unique case (instr[14:12])
269        1/1                    3'b000:  alu_operator_o = ALU_EQ;
270                               3'b001:  alu_operator_o = ALU_NE;
271        1/1                    3'b100:  alu_operator_o = ALU_LT;
272                               3'b101:  alu_operator_o = ALU_GE;
273        1/1                    3'b110:  alu_operator_o = ALU_LTU;
274        1/1                    3'b111:  alu_operator_o = ALU_GEU;
275                               default: illegal_insn   = 1'b1;
276                             endcase
277        1/1                  if (instr_new_i) begin
278        1/1                    // Evaluate branch condition
279        1/1                    alu_op_a_mux_sel_o  = OP_A_REG_A;
280        1/1                    alu_op_b_mux_sel_o  = OP_B_REG_B;
281        1/1                  end else begin
282                               // Calculate jump target in EX
283                               alu_op_a_mux_sel_o  = OP_A_CURRPC;
284                               alu_op_b_mux_sel_o  = OP_B_IMM;
285                               imm_b_mux_sel_o     = IMM_B_B;
286                               alu_operator_o      = ALU_ADD;
287                               regfile_we          = 1'b0;
288                             end
289                           end
290        1/1          
291        1/1                ////////////////
292        1/1                // Load/store //
293        1/1                ////////////////
294        1/1          
295                           OPCODE_STORE: begin
296        1/1                  alu_op_a_mux_sel_o = OP_A_REG_A;
297                             alu_op_b_mux_sel_o = OP_B_REG_B;
298        1/1                  data_req_o         = 1'b1;
299        1/1                  data_we_o          = 1'b1;
300                             alu_operator_o     = ALU_ADD;
301                     
302        1/1                  if (!instr[14]) begin
303                               // offset from immediate
304                               imm_b_mux_sel_o     = IMM_B_S;
305                               alu_op_b_mux_sel_o  = OP_B_IMM;
306        1/1                  end else begin
307        1/1                    // Register offset is illegal since no register c available
308        1/1                    illegal_insn = 1'b1;
309        1/1                  end
310        1/1          
311                             // store size
312                             unique case (instr[13:12])
313                               2'b00:   data_type_o  = 2'b10; // SB
314                               2'b01:   data_type_o  = 2'b01; // SH
315        1/1                    2'b10:   data_type_o  = 2'b00; // SW
316        1/1                    default: illegal_insn = 1'b1;
317        1/1                  endcase
318        1/1                end
319        1/1          
320                           OPCODE_LOAD: begin
321                             alu_op_a_mux_sel_o  = OP_A_REG_A;
322        1/1                  data_req_o          = 1'b1;
323        1/1                  regfile_wdata_sel_o = RF_WD_LSU;
324        1/1                  regfile_we          = 1'b1;
325                             data_type_o         = 2'b00;
326                     
327        1/1                  // offset from immediate
328                             alu_operator_o      = ALU_ADD;
329                             alu_op_b_mux_sel_o  = OP_B_IMM;
330        1/1                  imm_b_mux_sel_o     = IMM_B_I;
331        1/1          
332        1/1                  // sign/zero extension
333                             data_sign_extension_o = ~instr[14];
334        1/1          
335        1/1                  // load size
336        0/1     ==>          unique case (instr[13:12])
337                               2'b00: data_type_o = 2'b10; // LB(U)
                        MISSING_ELSE
338                               2'b01: data_type_o = 2'b01; // LH(U)
339                               2'b10: begin
340        1/1                      data_type_o = 2'b00;      // LW
341                                 if (instr[14]) begin
342                                   illegal_insn = 1'b1;    // LWU does not exist
343                                 end
344                               end
345                               default: begin
346                                 illegal_insn = 1'b1;
347                               end
348                             endcase
349                           end
350        1/1          
351        1/1                /////////
352        1/1                // ALU //
353        1/1                /////////
354        1/1          
355        1/1                OPCODE_LUI: begin  // Load Upper Immediate
356                             alu_op_a_mux_sel_o  = OP_A_IMM;
357                             alu_op_b_mux_sel_o  = OP_B_IMM;
358                             imm_a_mux_sel_o     = IMM_A_ZERO;
359        1/1                  imm_b_mux_sel_o     = IMM_B_U;
360        1/1                  alu_operator_o      = ALU_ADD;
361        1/1                  regfile_we          = 1'b1;
362        1/1                end
363        1/1          
364                           OPCODE_AUIPC: begin  // Add Upper Immediate to PC
365                             alu_op_a_mux_sel_o  = OP_A_CURRPC;
366                             alu_op_b_mux_sel_o  = OP_B_IMM;
367        1/1                  imm_b_mux_sel_o     = IMM_B_U;
368        1/1                  alu_operator_o      = ALU_ADD;
369        1/1                  regfile_we          = 1'b1;
370        1/1                end
371                     
372        1/1                OPCODE_OP_IMM: begin // Register-Immediate ALU Operations
373        1/1                  alu_op_a_mux_sel_o  = OP_A_REG_A;
374        1/1                  alu_op_b_mux_sel_o  = OP_B_IMM;
375        1/1                  imm_b_mux_sel_o     = IMM_B_I;
376        1/1                  regfile_we          = 1'b1;
377        1/1          
378        1/1                  unique case (instr[14:12])
379                               3'b000: alu_operator_o = ALU_ADD;  // Add Immediate
380                               3'b010: alu_operator_o = ALU_SLT;  // Set to one if Lower Than Immediate
381        1/1                    3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned
382        1/1                    3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate
383        1/1                    3'b110: alu_operator_o = ALU_OR;   // Or with Immediate
384                               3'b111: alu_operator_o = ALU_AND;  // And with Immediate
                        MISSING_ELSE
385                     
386                               3'b001: begin
387                                 alu_operator_o = ALU_SLL;  // Shift Left Logical by Immediate
388        1/1                      if (instr[31:25] != 7'b0) begin
389        1/1                        illegal_insn = 1'b1;
390        1/1                      end
391        1/1                    end
392                     
393        1/1                    3'b101: begin
394                                 if (instr[31:25] == 7'b0) begin
395                                   alu_operator_o = ALU_SRL;  // Shift Right Logical by Immediate
396                                 end else if (instr[31:25] == 7'b010_0000) begin
397                                   alu_operator_o = ALU_SRA;  // Shift Right Arithmetically by Immediate
398        0/1     ==>              end else begin
399                                   illegal_insn   = 1'b1;
400                                 end
401                               end
402                     
403                               default: begin
404        1/1                      alu_operator_o = ALU_SLTU;
405        1/1                    end
406        1/1                  endcase
407                           end
408        1/1          
409        1/1                OPCODE_OP: begin  // Register-Register ALU operation
410                             alu_op_a_mux_sel_o = OP_A_REG_A;
411        1/1                  alu_op_b_mux_sel_o = OP_B_REG_B;
412                             regfile_we         = 1'b1;
413        1/1          
414        1/1                  if (instr[31]) begin
415        1/1                    illegal_insn = 1'b1;
416        1/1                  end else begin
417        1/1                    unique case ({instr[30:25], instr[14:12]})
418        1/1                      // RV32I ALU operations
419        1/1                      {6'b00_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add
420        1/1                      {6'b10_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub
421        1/1                      {6'b00_0000, 3'b010}: alu_operator_o = ALU_SLT;   // Set Lower Than
422        1/1                      {6'b00_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned
423                                 {6'b00_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor
424                                 {6'b00_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or
425                                 {6'b00_0000, 3'b111}: alu_operator_o = ALU_AND;   // And
426        1/1                      {6'b00_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical
427        1/1                      {6'b00_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical
428        1/1                      {6'b10_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic
429        1/1          
430        1/1                      // supported RV32M instructions
431                                 {6'b00_0001, 3'b000}: begin // mul
432                                   alu_operator_o        = ALU_ADD;
433        1/1                        multdiv_operator_o    = MD_OP_MULL;
434        1/1                        mult_en_o             = RV32M ? 1'b1 : 1'b0;
435        1/1                        multdiv_signed_mode_o = 2'b00;
436        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
437        1/1                      end
438                                 {6'b00_0001, 3'b001}: begin // mulh
439                                   alu_operator_o        = ALU_ADD;
440        1/1                        multdiv_operator_o    = MD_OP_MULH;
441        1/1                        mult_en_o             = RV32M ? 1'b1 : 1'b0;
442        1/1                        multdiv_signed_mode_o = 2'b11;
443        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
444        1/1                      end
445                                 {6'b00_0001, 3'b010}: begin // mulhsu
446                                   alu_operator_o        = ALU_ADD;
447        1/1                        multdiv_operator_o    = MD_OP_MULH;
448        1/1                        mult_en_o             = RV32M ? 1'b1 : 1'b0;
449        1/1                        multdiv_signed_mode_o = 2'b01;
450        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
451        1/1                      end
452                                 {6'b00_0001, 3'b011}: begin // mulhu
453                                   alu_operator_o        = ALU_ADD;
454        1/1                        multdiv_operator_o    = MD_OP_MULH;
455        1/1                        mult_en_o             = RV32M ? 1'b1 : 1'b0;
456        1/1                        multdiv_signed_mode_o = 2'b00;
457        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
458        1/1                      end
459                                 {6'b00_0001, 3'b100}: begin // div
460                                   alu_operator_o        = ALU_ADD;
461        1/1                        multdiv_operator_o    = MD_OP_DIV;
462        1/1                        div_en_o              = RV32M ? 1'b1 : 1'b0;
463        1/1                        multdiv_signed_mode_o = 2'b11;
464        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
465        1/1                      end
466                                 {6'b00_0001, 3'b101}: begin // divu
467                                   alu_operator_o        = ALU_ADD;
468        1/1                        multdiv_operator_o    = MD_OP_DIV;
469        1/1                        div_en_o              = RV32M ? 1'b1 : 1'b0;
470        1/1                        multdiv_signed_mode_o = 2'b00;
471        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
472        1/1                      end
473                                 {6'b00_0001, 3'b110}: begin // rem
474                                   alu_operator_o        = ALU_ADD;
475        1/1                        multdiv_operator_o    = MD_OP_REM;
476        1/1                        div_en_o              = RV32M ? 1'b1 : 1'b0;
477        1/1                        multdiv_signed_mode_o = 2'b11;
478        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
479        1/1                      end
480                                 {6'b00_0001, 3'b111}: begin // remu
481                                   alu_operator_o        = ALU_ADD;
482        1/1                        multdiv_operator_o    = MD_OP_REM;
483                                   div_en_o              = RV32M ? 1'b1 : 1'b0;
484                                   multdiv_signed_mode_o = 2'b00;
485                                   illegal_insn          = RV32M ? 1'b0 : 1'b1;
486                                 end
487                                 default: begin
488                                   illegal_insn = 1'b1;
489                                 end
490                               endcase
491                             end
492                           end
493                     
494                           /////////////
495                           // Special //
496        1/1                /////////////
497                     
498        1/1                OPCODE_MISC_MEM: begin
499        1/1                  // For now, treat the FENCE (funct3 == 000) instruction as a NOP.  This may not be correct
500        1/1                  // in a system with caches and should be revisited.
501        1/1                  // FENCE.I will flush the IF stage and prefetch buffer but nothing else.
502                             unique case (instr[14:12])
503                               3'b000: begin
504                                 alu_operator_o     = ALU_ADD; // nop
505                                 alu_op_a_mux_sel_o = OP_A_REG_A;
506                                 alu_op_b_mux_sel_o = OP_B_IMM;
507        1/1                      regfile_we         = 1'b0;
508                               end
509        1/1                    3'b001: begin
510        1/1                      // FENCE.I is implemented as a jump to the next PC, this gives the required flushing
511        1/1                      // behaviour (iside prefetch buffer flushed and response to any outstanding iside
512        1/1                      // requests will be ignored).
513        1/1                      jump_in_dec_o      = 1'b1;
514                     
515        1/1                      alu_op_a_mux_sel_o = OP_A_CURRPC;
516        1/1                      alu_op_b_mux_sel_o = OP_B_IMM;
517                                 imm_b_mux_sel_o    = IMM_B_INCR_PC;
                        MISSING_ELSE
518                                 alu_operator_o     = ALU_ADD;
519                                 regfile_we         = 1'b0;
520        1/1          
521                                 if (instr_new_i) begin
522                                   jump_set_o       = 1'b1;
523                                 end
524                               end
525                               default: begin
526        1/1                      illegal_insn       = 1'b1;
527                               end
528        1/1                  endcase
529        1/1                end
530        1/1          
531                           OPCODE_SYSTEM: begin
532                             if (instr[14:12] == 3'b000) begin
533        1/1                    // non CSR related SYSTEM instructions
534                               alu_op_a_mux_sel_o = OP_A_REG_A;
535                               alu_op_b_mux_sel_o = OP_B_IMM;
536                               unique case (instr[31:20])
537        1/1                      12'h000:  // ECALL
538                                   // environment (system) call
539                                   ecall_insn_o = 1'b1;
540        1/1          
541                                 12'h001:  // ebreak
542                                   // debugger trap
543        1/1                        ebrk_insn_o = 1'b1;
544                     
545                                 12'h302:  // mret
546        1/1                        mret_insn_o = 1'b1;
547                     
548                                 12'h7b2:  // dret
549        1/1                        dret_insn_o = 1'b1;
550                     
551                                 12'h105:  // wfi
552                                   wfi_insn_o = 1'b1;
553        1/1          
554        1/1                      default:
555                                   illegal_insn = 1'b1;
                        MISSING_ELSE
556                               endcase
557                     
558        1/1                    // rs1 and rd must be 0
559        1/1                    if (instr[`REG_S1] != 5'b0 || instr[`REG_D] != 5'b0) begin
560        1/1                      illegal_insn = 1'b1;
561        1/1                    end
562        1/1                  end else begin
563        1/1                    // instruction to read/modify CSR
564                               csr_access_o        = 1'b1;
565        1/1                    regfile_wdata_sel_o = RF_WD_CSR;
566                               regfile_we          = 1'b1;
567        1/1                    alu_op_b_mux_sel_o  = OP_B_IMM;
568                               imm_a_mux_sel_o     = IMM_A_Z;
569        1/1                    imm_b_mux_sel_o     = IMM_B_I;  // CSR address is encoded in I imm
570                     
571                               if (instr[14]) begin
572        1/1                      // rs1 field is used as immediate
573        1/1                      alu_op_a_mux_sel_o = OP_A_IMM;
574        1/1                    end else begin
575        1/1                      alu_op_a_mux_sel_o = OP_A_REG_A;
576        1/1                    end
577                     
578                               unique case (instr[13:12])
579        1/1                      2'b01:   csr_op = CSR_OP_WRITE;
580                                 2'b10:   csr_op = CSR_OP_SET;
581                                 2'b11:   csr_op = CSR_OP_CLEAR;
582                                 default: csr_illegal = 1'b1;
583                               endcase
584        1/1          
585                               illegal_insn = csr_illegal;
586                             end
587                     
588                           end
589        1/1                default: begin
590        1/1                  illegal_insn = 1'b1;
591                           end
                        MISSING_ELSE
592                         endcase
593                     
594                         // make sure illegal compressed instructions cause illegal instruction exceptions
595                         if (illegal_c_insn_i) begin
596                           illegal_insn = 1'b1;
597                         end
598        1/1          
599        1/1              // make sure illegal instructions detected in the decoder do not propagate from decoder
600        1/1              // into register file, LSU, EX, WB, CSRs, PC
601        1/1              // NOTE: instructions can also be detected to be illegal inside the CSRs (upon accesses with
602        1/1              // insufficient privileges), or when accessing non-available registers in RV32E,
603        1/1              // these cases are not handled here
604        1/1              if (illegal_insn) begin
605        1/1                regfile_we      = 1'b0;
606        1/1                data_req_o      = 1'b0;
607        1/1                data_we_o       = 1'b0;
608                           mult_en_o       = 1'b0;
                        MISSING_ELSE

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_decoder
         Line No. Total Covered Percent 
Branches          90    88      97.78   
IF       137      2     2       100.00  
IF       154      5     5       100.00  
CASE     210      79    77      97.47   
IF       589      2     2       100.00  
IF       598      2     2       100.00  


137          ///////////////////////
                                    -1-
138          always_comb begin : csr_operand_check
139            csr_op_o = csr_op;
               ==>
140        
           MISSING_ELSE
           ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


154        
           -1-
155            // A pipeline flush is needed to let the controller react after modifying certain CSRs:
                                                                                                      -2-
156            // - When enabling interrupts, pending IRQs become visible to the controller only during
157            //   the next cycle. If during that cycle the core disables interrupts again, it does not
               ==>
158            //   see any pending IRQs and consequently does not start to handle interrupts.
               MISSING_ELSE
               ==>
159            // - When modifying debug CSRs - TODO: Check if this is really needed
                                                                                    -3-
160            if (csr_access_o == 1'b1 && (csr_op_o == CSR_OP_WRITE || csr_op_o == CSR_OP_SET)) begin
               -4-  
161              if (csr_num_e'(instr[31:20]) == CSR_MSTATUS   ||
162                  csr_num_e'(instr[31:20]) == CSR_MIE) begin
163                csr_pipe_flush_o = 1'b1;
164              end
                 ==>
165            end else if (csr_access_o == 1'b1 && csr_op_o != CSR_OP_READ) begin
               MISSING_ELSE
               ==>
166              if (csr_num_e'(instr[31:20]) == CSR_DCSR      ||
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- Status  
1   1   -   -   Covered 
1   0   -   -   Covered 
0   -   1   1   Covered 
0   -   1   0   Covered 
0   -   0   -   Covered 


210            dret_insn_o                 = 1'b0;
               -1-                                   
211            ecall_insn_o                = 1'b0;
212            wfi_insn_o                  = 1'b0;
213        
214            opcode                      = opcode_e'(instr[6:0]);
215        
216            unique case (opcode)
217        
218              ///////////
                            -2-
219              // Jumps //
220              ///////////
                 ==>
221        
222              OPCODE_JAL: begin   // Jump and Link
223                jump_in_dec_o         = 1'b1;
224                if (instr_new_i) begin
225                  // Calculate jump target
226                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
227                  alu_op_b_mux_sel_o  = OP_B_IMM;
228                  imm_b_mux_sel_o     = IMM_B_J;
                     ==>
229                  alu_operator_o      = ALU_ADD;
230                  regfile_we          = 1'b0;
231                  jump_set_o          = 1'b1;
232                end else begin
233                  // Calculate and store PC+4
234                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
235                  alu_op_b_mux_sel_o  = OP_B_IMM;
236                  imm_b_mux_sel_o     = IMM_B_INCR_PC;
237                  alu_operator_o      = ALU_ADD;
238                  regfile_we          = 1'b1;
                     -3-                           
239                end
240              end
                 ==>
241        
242              OPCODE_JALR: begin  // Jump and Link Register
243                jump_in_dec_o         = 1'b1;
244                if (instr_new_i) begin
245                  // Calculate jump target
246                  alu_op_a_mux_sel_o  = OP_A_REG_A;
247                  alu_op_b_mux_sel_o  = OP_B_IMM;
248                  imm_b_mux_sel_o     = IMM_B_I;
                     ==>
249                  alu_operator_o      = ALU_ADD;
250                  regfile_we          = 1'b0;
251                  jump_set_o          = 1'b1;
252                end else begin
253                  // Calculate and store PC+4
254                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
                     -4-                                  
255                  alu_op_b_mux_sel_o  = OP_B_IMM;
                     ==>
256                  imm_b_mux_sel_o     = IMM_B_INCR_PC;
                     MISSING_ELSE
                     ==>
257                  alu_operator_o      = ALU_ADD;
258                  regfile_we          = 1'b1;
259                end
260                if (instr[14:12] != 3'b0) begin
261                  illegal_insn = 1'b1;
262                end
                   -5-   
263              end
                 ==>
264        
           ==>
265              OPCODE_BRANCH: begin // Branch
                 ==>
266                branch_in_dec_o       = 1'b1;
                   ==>
267                // Check branch condition selection
                   ==>
268                unique case (instr[14:12])
                   ==>
269                  3'b000:  alu_operator_o = ALU_EQ;
                     ==>
270                  3'b001:  alu_operator_o = ALU_NE;
271                  3'b100:  alu_operator_o = ALU_LT;
                     -6-                                 
272                  3'b101:  alu_operator_o = ALU_GE;
273                  3'b110:  alu_operator_o = ALU_LTU;
                     ==>
274                  3'b111:  alu_operator_o = ALU_GEU;
275                  default: illegal_insn   = 1'b1;
276                endcase
277                if (instr_new_i) begin
                   ==>
278                  // Evaluate branch condition
279                  alu_op_a_mux_sel_o  = OP_A_REG_A;
280                  alu_op_b_mux_sel_o  = OP_B_REG_B;
281                end else begin
282                  // Calculate jump target in EX
283                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
284                  alu_op_b_mux_sel_o  = OP_B_IMM;
285                  imm_b_mux_sel_o     = IMM_B_B;
286                  alu_operator_o      = ALU_ADD;
287                  regfile_we          = 1'b0;
288                end
289              end
290        
291              ////////////////
292              // Load/store //
293              ////////////////
294        
295              OPCODE_STORE: begin
296                alu_op_a_mux_sel_o = OP_A_REG_A;
                   -7-                                
297                alu_op_b_mux_sel_o = OP_B_REG_B;
298                data_req_o         = 1'b1;
                   ==>
299                data_we_o          = 1'b1;
300                alu_operator_o     = ALU_ADD;
301        
302                if (!instr[14]) begin
                   ==>
303                  // offset from immediate
304                  imm_b_mux_sel_o     = IMM_B_S;
305                  alu_op_b_mux_sel_o  = OP_B_IMM;
306                end else begin
                   -8-              
307                  // Register offset is illegal since no register c available
                     ==>
308                  illegal_insn = 1'b1;
                     ==>
309                end
                   ==>
310        
           ==>
311                // store size
312                unique case (instr[13:12])
313                  2'b00:   data_type_o  = 2'b10; // SB
314                  2'b01:   data_type_o  = 2'b01; // SH
315                  2'b10:   data_type_o  = 2'b00; // SW
316                  default: illegal_insn = 1'b1;
317                endcase
318              end
319        
320              OPCODE_LOAD: begin
321                alu_op_a_mux_sel_o  = OP_A_REG_A;
322                data_req_o          = 1'b1;
323                regfile_wdata_sel_o = RF_WD_LSU;
324                regfile_we          = 1'b1;
325                data_type_o         = 2'b00;
326        
327                // offset from immediate
328                alu_operator_o      = ALU_ADD;
329                alu_op_b_mux_sel_o  = OP_B_IMM;
330                imm_b_mux_sel_o     = IMM_B_I;
                   -9-                              
331        
           ==>
332                // sign/zero extension
                   ==>
333                data_sign_extension_o = ~instr[14];
334        
335                // load size
                               -10-
336                unique case (instr[13:12])
                   ==>
337                  2'b00: data_type_o = 2'b10; // LB(U)
                     MISSING_ELSE
                     ==>
338                  2'b01: data_type_o = 2'b01; // LH(U)
339                  2'b10: begin
340                    data_type_o = 2'b00;      // LW
                       ==>
341                    if (instr[14]) begin
342                      illegal_insn = 1'b1;    // LWU does not exist
343                    end
344                  end
345                  default: begin
346                    illegal_insn = 1'b1;
347                  end
348                endcase
349              end
350        
           ==>
351              /////////
352              // ALU //
353              /////////
354        
355              OPCODE_LUI: begin  // Load Upper Immediate
356                alu_op_a_mux_sel_o  = OP_A_IMM;
357                alu_op_b_mux_sel_o  = OP_B_IMM;
358                imm_a_mux_sel_o     = IMM_A_ZERO;
359                imm_b_mux_sel_o     = IMM_B_U;
                   ==>
360                alu_operator_o      = ALU_ADD;
361                regfile_we          = 1'b1;
362              end
363        
364              OPCODE_AUIPC: begin  // Add Upper Immediate to PC
365                alu_op_a_mux_sel_o  = OP_A_CURRPC;
366                alu_op_b_mux_sel_o  = OP_B_IMM;
367                imm_b_mux_sel_o     = IMM_B_U;
368                alu_operator_o      = ALU_ADD;
369                regfile_we          = 1'b1;
370              end
371        
372              OPCODE_OP_IMM: begin // Register-Immediate ALU Operations
                 -11-                                                         
373                alu_op_a_mux_sel_o  = OP_A_REG_A;
                   ==>
374                alu_op_b_mux_sel_o  = OP_B_IMM;
                   ==>
375                imm_b_mux_sel_o     = IMM_B_I;
                   ==>
376                regfile_we          = 1'b1;
                   ==>
377        
           ==>
378                unique case (instr[14:12])
                   ==>
379                  3'b000: alu_operator_o = ALU_ADD;  // Add Immediate
380                  3'b010: alu_operator_o = ALU_SLT;  // Set to one if Lower Than Immediate
381                  3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned
382                  3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate
                     -12-                                                                 
383                  3'b110: alu_operator_o = ALU_OR;   // Or with Immediate
                     ==>
384                  3'b111: alu_operator_o = ALU_AND;  // And with Immediate
                     MISSING_ELSE
                     ==>
385        
386                  3'b001: begin
387                    alu_operator_o = ALU_SLL;  // Shift Left Logical by Immediate
388                    if (instr[31:25] != 7'b0) begin
                       -13-  
389                      illegal_insn = 1'b1;
                         ==>
390                    end
                       -14-   
391                  end
                     ==>
392        
393                  3'b101: begin
                     ==>
394                    if (instr[31:25] == 7'b0) begin
395                      alu_operator_o = ALU_SRL;  // Shift Right Logical by Immediate
396                    end else if (instr[31:25] == 7'b010_0000) begin
397                      alu_operator_o = ALU_SRA;  // Shift Right Arithmetically by Immediate
398                    end else begin
                       ==>
399                      illegal_insn   = 1'b1;
400                    end
401                  end
402        
403                  default: begin
404                    alu_operator_o = ALU_SLTU;
405                  end
406                endcase
407              end
408        
           -15-
409              OPCODE_OP: begin  // Register-Register ALU operation
                 ==>
410                alu_op_a_mux_sel_o = OP_A_REG_A;
411                alu_op_b_mux_sel_o = OP_B_REG_B;
                   -16-                                
412                regfile_we         = 1'b1;
413        
           ==>
414                if (instr[31]) begin
                   ==>
415                  illegal_insn = 1'b1;
                     ==>
416                end else begin
                   ==>
417                  unique case ({instr[30:25], instr[14:12]})
                     ==>
418                    // RV32I ALU operations
                       ==>
419                    {6'b00_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add
                       ==>
420                    {6'b10_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub
                       ==>
421                    {6'b00_0000, 3'b010}: alu_operator_o = ALU_SLT;   // Set Lower Than
                       ==>
422                    {6'b00_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned
                       ==>
423                    {6'b00_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor
424                    {6'b00_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or
425                    {6'b00_0000, 3'b111}: alu_operator_o = ALU_AND;   // And
426                    {6'b00_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical
                       ==>
427                    {6'b00_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical
428                    {6'b10_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic
429        
430                    // supported RV32M instructions
431                    {6'b00_0001, 3'b000}: begin // mul
432                      alu_operator_o        = ALU_ADD;
433                      multdiv_operator_o    = MD_OP_MULL;
                         ==>
434                      mult_en_o             = RV32M ? 1'b1 : 1'b0;
435                      multdiv_signed_mode_o = 2'b00;
436                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
437                    end
438                    {6'b00_0001, 3'b001}: begin // mulh
439                      alu_operator_o        = ALU_ADD;
440                      multdiv_operator_o    = MD_OP_MULH;
                         ==>
441                      mult_en_o             = RV32M ? 1'b1 : 1'b0;
442                      multdiv_signed_mode_o = 2'b11;
443                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
444                    end
445                    {6'b00_0001, 3'b010}: begin // mulhsu
446                      alu_operator_o        = ALU_ADD;
447                      multdiv_operator_o    = MD_OP_MULH;
                         ==>
448                      mult_en_o             = RV32M ? 1'b1 : 1'b0;
449                      multdiv_signed_mode_o = 2'b01;
450                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
451                    end
452                    {6'b00_0001, 3'b011}: begin // mulhu
453                      alu_operator_o        = ALU_ADD;
454                      multdiv_operator_o    = MD_OP_MULH;
                         ==>
455                      mult_en_o             = RV32M ? 1'b1 : 1'b0;
456                      multdiv_signed_mode_o = 2'b00;
457                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
458                    end
459                    {6'b00_0001, 3'b100}: begin // div
460                      alu_operator_o        = ALU_ADD;
461                      multdiv_operator_o    = MD_OP_DIV;
                         ==>
462                      div_en_o              = RV32M ? 1'b1 : 1'b0;
463                      multdiv_signed_mode_o = 2'b11;
464                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
465                    end
466                    {6'b00_0001, 3'b101}: begin // divu
467                      alu_operator_o        = ALU_ADD;
468                      multdiv_operator_o    = MD_OP_DIV;
                         ==>
469                      div_en_o              = RV32M ? 1'b1 : 1'b0;
470                      multdiv_signed_mode_o = 2'b00;
471                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
472                    end
473                    {6'b00_0001, 3'b110}: begin // rem
474                      alu_operator_o        = ALU_ADD;
475                      multdiv_operator_o    = MD_OP_REM;
                         ==>
476                      div_en_o              = RV32M ? 1'b1 : 1'b0;
477                      multdiv_signed_mode_o = 2'b11;
478                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
479                    end
480                    {6'b00_0001, 3'b111}: begin // remu
481                      alu_operator_o        = ALU_ADD;
482                      multdiv_operator_o    = MD_OP_REM;
                         ==>
483                      div_en_o              = RV32M ? 1'b1 : 1'b0;
484                      multdiv_signed_mode_o = 2'b00;
485                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
486                    end
487                    default: begin
488                      illegal_insn = 1'b1;
489                    end
490                  endcase
491                end
492              end
493        
494              /////////////
495              // Special //
496              /////////////
                              -17-
497        
498              OPCODE_MISC_MEM: begin
                 ==>
499                // For now, treat the FENCE (funct3 == 000) instruction as a NOP.  This may not be correct
500                // in a system with caches and should be revisited.
501                // FENCE.I will flush the IF stage and prefetch buffer but nothing else.
502                unique case (instr[14:12])
503                  3'b000: begin
504                    alu_operator_o     = ALU_ADD; // nop
505                    alu_op_a_mux_sel_o = OP_A_REG_A;
506                    alu_op_b_mux_sel_o = OP_B_IMM;
507                    regfile_we         = 1'b0;
508                  end
509                  3'b001: begin
510                    // FENCE.I is implemented as a jump to the next PC, this gives the required flushing
511                    // behaviour (iside prefetch buffer flushed and response to any outstanding iside
512                    // requests will be ignored).
513                    jump_in_dec_o      = 1'b1;
514        
515                    alu_op_a_mux_sel_o = OP_A_CURRPC;
                       -18-                                 
516                    alu_op_b_mux_sel_o = OP_B_IMM;
                       ==>
517                    imm_b_mux_sel_o    = IMM_B_INCR_PC;
                       MISSING_ELSE
                       ==>
518                    alu_operator_o     = ALU_ADD;
519                    regfile_we         = 1'b0;
520        
           ==>
521                    if (instr_new_i) begin
522                      jump_set_o       = 1'b1;
523                    end
524                  end
525                  default: begin
526                    illegal_insn       = 1'b1;
                       -19-                          
527                  end
528                endcase
529              end
530        
           -20-
531              OPCODE_SYSTEM: begin
532                if (instr[14:12] == 3'b000) begin
533                  // non CSR related SYSTEM instructions
                     ==>
534                  alu_op_a_mux_sel_o = OP_A_REG_A;
535                  alu_op_b_mux_sel_o = OP_B_IMM;
536                  unique case (instr[31:20])
537                    12'h000:  // ECALL
                       ==>
538                      // environment (system) call
539                      ecall_insn_o = 1'b1;
540        
           ==>
541                    12'h001:  // ebreak
542                      // debugger trap
543                      ebrk_insn_o = 1'b1;
                         ==>
544        
545                    12'h302:  // mret
546                      mret_insn_o = 1'b1;
                         ==>
547        
548                    12'h7b2:  // dret
549                      dret_insn_o = 1'b1;
                         ==>
550        
551                    12'h105:  // wfi
552                      wfi_insn_o = 1'b1;
553        
           -21-
554                    default:
                       ==>
555                      illegal_insn = 1'b1;
                         MISSING_ELSE
                         ==>
556                  endcase
557        
558                  // rs1 and rd must be 0
559                  if (instr[`REG_S1] != 5'b0 || instr[`REG_D] != 5'b0) begin
560                    illegal_insn = 1'b1;
561                  end
562                end else begin
563                  // instruction to read/modify CSR
564                  csr_access_o        = 1'b1;
565                  regfile_wdata_sel_o = RF_WD_CSR;
                     -22-                                
566                  regfile_we          = 1'b1;
567                  alu_op_b_mux_sel_o  = OP_B_IMM;
                     ==>
568                  imm_a_mux_sel_o     = IMM_A_Z;
569                  imm_b_mux_sel_o     = IMM_B_I;  // CSR address is encoded in I imm
                     ==>
570        
571                  if (instr[14]) begin
572                    // rs1 field is used as immediate
                                                        -23-
573                    alu_op_a_mux_sel_o = OP_A_IMM;
                       ==>
574                  end else begin
                     ==>
575                    alu_op_a_mux_sel_o = OP_A_REG_A;
                       ==>
576                  end
                     ==>
577        
578                  unique case (instr[13:12])
579                    2'b01:   csr_op = CSR_OP_WRITE;
580                    2'b10:   csr_op = CSR_OP_SET;
581                    2'b11:   csr_op = CSR_OP_CLEAR;
582                    default: csr_illegal = 1'b1;
583                  endcase
584        
           ==>

Branches:

-1-              -2- -3- -4- -5-     -6- -7- -8-     -9-     -10- -11-    -12- -13- -14- -15- -16-                 -17-    -18- -19- -20-     -21- -22- -23-    Status      
OPCODE_JAL       1   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JAL       0   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JALR      -   1   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JALR      -   0   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JALR      -   -   1   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JALR      -   -   0   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b000  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b001  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b100  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b101  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b110  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b111  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   default -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   -       1   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   -       0   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   1   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   0   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   -   2'b00   -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   -   2'b01   -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   -   2'b10   -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   -   default -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LOAD      -   -   -   -       -   -   -       2'b00   -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LOAD      -   -   -   -       -   -   -       2'b01   -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LOAD      -   -   -   -       -   -   -       2'b10   1    -       -    -    -    -    -                    -       -    -    -        -    -    -       Not Covered 
OPCODE_LOAD      -   -   -   -       -   -   -       2'b10   0    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LOAD      -   -   -   -       -   -   -       default -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LUI       -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_AUIPC     -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b000  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b010  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b011  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b100  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b110  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b111  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b001  1    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b001  0    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b101  -    1    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b101  -    0    1    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b101  -    0    0    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    default -    -    -    -    -                    -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    1    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b0}         -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b100000, 3'b0}    -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b010}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b011}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b100}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b110}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b111}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b1}         -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b101}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b100000, 3'b101}  -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b0}         -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b1}         -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b010}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b011}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b100}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b101}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b110}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b111}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    default              -       -    -    -        -    -    -       Covered     
OPCODE_MISC_MEM  -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    3'b000  -    -    -        -    -    -       Covered     
OPCODE_MISC_MEM  -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    3'b001  1    -    -        -    -    -       Covered     
OPCODE_MISC_MEM  -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    3'b001  0    -    -        -    -    -       Covered     
OPCODE_MISC_MEM  -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    default -    -    -        -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h000  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h001  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h302  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h7b2  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h105  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    default  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    -        1    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    -        0    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    1    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    0    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    -    2'b01   Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    -    2'b10   Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    -    2'b11   Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    -    default Covered     
default          -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     


589              default: begin
                 -1-              
590                illegal_insn = 1'b1;
                   ==>
591              end
                 MISSING_ELSE
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


598        
           -1-
599            // make sure illegal instructions detected in the decoder do not propagate from decoder
               ==>
600            // into register file, LSU, EX, WB, CSRs, PC
601            // NOTE: instructions can also be detected to be illegal inside the CSRs (upon accesses with
602            // insufficient privileges), or when accessing non-available registers in RV32E,
603            // these cases are not handled here
604            if (illegal_insn) begin
605              regfile_we      = 1'b0;
606              data_req_o      = 1'b0;
607              data_we_o       = 1'b0;
608              mult_en_o       = 1'b0;
                 MISSING_ELSE
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.id_stage_i.decoder_i(x)
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 98.69  99.61 --     --      97.78 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 98.69  99.61 --     --      97.78 --     


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME         
 98.50  99.22 --     --      97.78 --     ibex_decoder 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME       
100.00 100.00 --     --     100.00 100.00 id_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.id_stage_i.decoder_i(x)

             Line No.   Total   Covered  Percent
TOTAL                      255      254    99.61
ALWAYS            133        3        3   100.00
ALWAYS            147        7        7   100.00
ALWAYS            174      245      244    99.59

132                         assign illegal_reg_rv32e = 1'b0;
133        1/1            end
134                     
135                       ///////////////////////
136                       // CSR operand check //
137        1/1            ///////////////////////
138                       always_comb begin : csr_operand_check
139        1/1              csr_op_o = csr_op;
140                     
                        MISSING_ELSE
141                         // CSRRSI/CSRRCI must not write 0 to CSRs (uimm[4:0]=='0)
142                         // CSRRS/CSRRC must not write from x0 to CSRs (rs1=='0)
143                         if ((csr_op == CSR_OP_SET || csr_op == CSR_OP_CLEAR) &&
144                             instr[`REG_S1] == '0) begin
145                           csr_op_o = CSR_OP_READ;
146                         end
147        1/1            end
148                     
149                       /////////////////////////////////
150                       // CSR-related pipline flushes //
151                       /////////////////////////////////
152                       always_comb begin : csr_pipeline_flushes
153                         csr_pipe_flush_o = 1'b0;
154        1/1          
155        1/1              // A pipeline flush is needed to let the controller react after modifying certain CSRs:
156                         // - When enabling interrupts, pending IRQs become visible to the controller only during
157        1/1              //   the next cycle. If during that cycle the core disables interrupts again, it does not
158                         //   see any pending IRQs and consequently does not start to handle interrupts.
                        MISSING_ELSE
159        1/1              // - When modifying debug CSRs - TODO: Check if this is really needed
160        1/1              if (csr_access_o == 1'b1 && (csr_op_o == CSR_OP_WRITE || csr_op_o == CSR_OP_SET)) begin
161                           if (csr_num_e'(instr[31:20]) == CSR_MSTATUS   ||
162                               csr_num_e'(instr[31:20]) == CSR_MIE) begin
163                             csr_pipe_flush_o = 1'b1;
164        1/1                end
165                         end else if (csr_access_o == 1'b1 && csr_op_o != CSR_OP_READ) begin
                        MISSING_ELSE
166                           if (csr_num_e'(instr[31:20]) == CSR_DCSR      ||
                        MISSING_ELSE
167                               csr_num_e'(instr[31:20]) == CSR_DPC       ||
168                               csr_num_e'(instr[31:20]) == CSR_DSCRATCH0 ||
169                               csr_num_e'(instr[31:20]) == CSR_DSCRATCH1) begin
170                             csr_pipe_flush_o = 1'b1;
171                           end
172                         end
173                       end
174        1/1          
175        1/1            /////////////
176        1/1            // Decoder //
177        1/1            /////////////
178        1/1          
179        1/1            always_comb begin
180                         jump_in_dec_o               = 1'b0;
181        1/1              jump_set_o                  = 1'b0;
182        1/1              branch_in_dec_o             = 1'b0;
183                         alu_operator_o              = ALU_SLTU;
184        1/1              alu_op_a_mux_sel_o          = OP_A_IMM;
185        1/1              alu_op_b_mux_sel_o          = OP_B_IMM;
186        1/1          
187        1/1              imm_a_mux_sel_o             = IMM_A_ZERO;
188                         imm_b_mux_sel_o             = IMM_B_I;
189        1/1          
190        1/1              mult_en_o                   = 1'b0;
191                         div_en_o                    = 1'b0;
192        1/1              multdiv_operator_o          = MD_OP_MULL;
193        1/1              multdiv_signed_mode_o       = 2'b00;
194        1/1          
195                         regfile_wdata_sel_o         = RF_WD_EX;
196        1/1              regfile_we                  = 1'b0;
197        1/1          
198        1/1              csr_access_o                = 1'b0;
199        1/1              csr_illegal                 = 1'b0;
200                         csr_op                      = CSR_OP_READ;
201        1/1          
202        1/1              data_we_o                   = 1'b0;
203        1/1              data_type_o                 = 2'b00;
204        1/1              data_sign_extension_o       = 1'b0;
205        1/1              data_req_o                  = 1'b0;
206        1/1          
207                         illegal_insn                = 1'b0;
208        1/1              ebrk_insn_o                 = 1'b0;
209                         mret_insn_o                 = 1'b0;
210        1/1              dret_insn_o                 = 1'b0;
211                         ecall_insn_o                = 1'b0;
212                         wfi_insn_o                  = 1'b0;
213                     
214                         opcode                      = opcode_e'(instr[6:0]);
215                     
216                         unique case (opcode)
217        1/1          
218        1/1                ///////////
219                           // Jumps //
220        1/1                ///////////
221        1/1          
222        1/1                OPCODE_JAL: begin   // Jump and Link
223        1/1                  jump_in_dec_o         = 1'b1;
224        1/1                  if (instr_new_i) begin
225        1/1                    // Calculate jump target
226                               alu_op_a_mux_sel_o  = OP_A_CURRPC;
227                               alu_op_b_mux_sel_o  = OP_B_IMM;
228        1/1                    imm_b_mux_sel_o     = IMM_B_J;
229        1/1                    alu_operator_o      = ALU_ADD;
230        1/1                    regfile_we          = 1'b0;
231        1/1                    jump_set_o          = 1'b1;
232        1/1                  end else begin
233                               // Calculate and store PC+4
234                               alu_op_a_mux_sel_o  = OP_A_CURRPC;
235                               alu_op_b_mux_sel_o  = OP_B_IMM;
236                               imm_b_mux_sel_o     = IMM_B_INCR_PC;
237        1/1                    alu_operator_o      = ALU_ADD;
238        1/1                    regfile_we          = 1'b1;
239                             end
240        1/1                end
241        1/1          
242        1/1                OPCODE_JALR: begin  // Jump and Link Register
243        1/1                  jump_in_dec_o         = 1'b1;
244        1/1                  if (instr_new_i) begin
245        1/1                    // Calculate jump target
246                               alu_op_a_mux_sel_o  = OP_A_REG_A;
247                               alu_op_b_mux_sel_o  = OP_B_IMM;
248        1/1                    imm_b_mux_sel_o     = IMM_B_I;
249        1/1                    alu_operator_o      = ALU_ADD;
250        1/1                    regfile_we          = 1'b0;
251        1/1                    jump_set_o          = 1'b1;
252        1/1                  end else begin
253                               // Calculate and store PC+4
254        1/1                    alu_op_a_mux_sel_o  = OP_A_CURRPC;
255        1/1                    alu_op_b_mux_sel_o  = OP_B_IMM;
256                               imm_b_mux_sel_o     = IMM_B_INCR_PC;
                        MISSING_ELSE
257                               alu_operator_o      = ALU_ADD;
258                               regfile_we          = 1'b1;
259                             end
260        1/1                  if (instr[14:12] != 3'b0) begin
261                               illegal_insn = 1'b1;
262        1/1                  end
263        1/1                end
264        1/1          
265        1/1                OPCODE_BRANCH: begin // Branch
266        1/1                  branch_in_dec_o       = 1'b1;
267        1/1                  // Check branch condition selection
268        1/1                  unique case (instr[14:12])
269        1/1                    3'b000:  alu_operator_o = ALU_EQ;
270                               3'b001:  alu_operator_o = ALU_NE;
271        1/1                    3'b100:  alu_operator_o = ALU_LT;
272                               3'b101:  alu_operator_o = ALU_GE;
273        1/1                    3'b110:  alu_operator_o = ALU_LTU;
274        1/1                    3'b111:  alu_operator_o = ALU_GEU;
275                               default: illegal_insn   = 1'b1;
276                             endcase
277        1/1                  if (instr_new_i) begin
278        1/1                    // Evaluate branch condition
279        1/1                    alu_op_a_mux_sel_o  = OP_A_REG_A;
280        1/1                    alu_op_b_mux_sel_o  = OP_B_REG_B;
281        1/1                  end else begin
282                               // Calculate jump target in EX
283                               alu_op_a_mux_sel_o  = OP_A_CURRPC;
284                               alu_op_b_mux_sel_o  = OP_B_IMM;
285                               imm_b_mux_sel_o     = IMM_B_B;
286                               alu_operator_o      = ALU_ADD;
287                               regfile_we          = 1'b0;
288                             end
289                           end
290        1/1          
291        1/1                ////////////////
292        1/1                // Load/store //
293        1/1                ////////////////
294        1/1          
295                           OPCODE_STORE: begin
296        1/1                  alu_op_a_mux_sel_o = OP_A_REG_A;
297                             alu_op_b_mux_sel_o = OP_B_REG_B;
298        1/1                  data_req_o         = 1'b1;
299        1/1                  data_we_o          = 1'b1;
300                             alu_operator_o     = ALU_ADD;
301                     
302        1/1                  if (!instr[14]) begin
303                               // offset from immediate
304                               imm_b_mux_sel_o     = IMM_B_S;
305                               alu_op_b_mux_sel_o  = OP_B_IMM;
306        1/1                  end else begin
307        1/1                    // Register offset is illegal since no register c available
308        1/1                    illegal_insn = 1'b1;
309        1/1                  end
310        1/1          
311                             // store size
312                             unique case (instr[13:12])
313                               2'b00:   data_type_o  = 2'b10; // SB
314                               2'b01:   data_type_o  = 2'b01; // SH
315        1/1                    2'b10:   data_type_o  = 2'b00; // SW
316        1/1                    default: illegal_insn = 1'b1;
317        1/1                  endcase
318        1/1                end
319        1/1          
320                           OPCODE_LOAD: begin
321                             alu_op_a_mux_sel_o  = OP_A_REG_A;
322        1/1                  data_req_o          = 1'b1;
323        1/1                  regfile_wdata_sel_o = RF_WD_LSU;
324        1/1                  regfile_we          = 1'b1;
325                             data_type_o         = 2'b00;
326                     
327        1/1                  // offset from immediate
328                             alu_operator_o      = ALU_ADD;
329                             alu_op_b_mux_sel_o  = OP_B_IMM;
330        1/1                  imm_b_mux_sel_o     = IMM_B_I;
331        1/1          
332        1/1                  // sign/zero extension
333                             data_sign_extension_o = ~instr[14];
334        1/1          
335        1/1                  // load size
336        0/1     ==>          unique case (instr[13:12])
337                               2'b00: data_type_o = 2'b10; // LB(U)
                        MISSING_ELSE
338                               2'b01: data_type_o = 2'b01; // LH(U)
339                               2'b10: begin
340        1/1                      data_type_o = 2'b00;      // LW
341                                 if (instr[14]) begin
342                                   illegal_insn = 1'b1;    // LWU does not exist
343                                 end
344                               end
345                               default: begin
346                                 illegal_insn = 1'b1;
347                               end
348                             endcase
349                           end
350        1/1          
351        1/1                /////////
352        1/1                // ALU //
353        1/1                /////////
354        1/1          
355        1/1                OPCODE_LUI: begin  // Load Upper Immediate
356                             alu_op_a_mux_sel_o  = OP_A_IMM;
357                             alu_op_b_mux_sel_o  = OP_B_IMM;
358                             imm_a_mux_sel_o     = IMM_A_ZERO;
359        1/1                  imm_b_mux_sel_o     = IMM_B_U;
360        1/1                  alu_operator_o      = ALU_ADD;
361        1/1                  regfile_we          = 1'b1;
362        1/1                end
363        1/1          
364                           OPCODE_AUIPC: begin  // Add Upper Immediate to PC
365                             alu_op_a_mux_sel_o  = OP_A_CURRPC;
366                             alu_op_b_mux_sel_o  = OP_B_IMM;
367        1/1                  imm_b_mux_sel_o     = IMM_B_U;
368        1/1                  alu_operator_o      = ALU_ADD;
369        1/1                  regfile_we          = 1'b1;
370        1/1                end
371                     
372        1/1                OPCODE_OP_IMM: begin // Register-Immediate ALU Operations
373        1/1                  alu_op_a_mux_sel_o  = OP_A_REG_A;
374        1/1                  alu_op_b_mux_sel_o  = OP_B_IMM;
375        1/1                  imm_b_mux_sel_o     = IMM_B_I;
376        1/1                  regfile_we          = 1'b1;
377        1/1          
378        1/1                  unique case (instr[14:12])
379                               3'b000: alu_operator_o = ALU_ADD;  // Add Immediate
380                               3'b010: alu_operator_o = ALU_SLT;  // Set to one if Lower Than Immediate
381        1/1                    3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned
382        1/1                    3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate
383        1/1                    3'b110: alu_operator_o = ALU_OR;   // Or with Immediate
384                               3'b111: alu_operator_o = ALU_AND;  // And with Immediate
                        MISSING_ELSE
385                     
386                               3'b001: begin
387                                 alu_operator_o = ALU_SLL;  // Shift Left Logical by Immediate
388        1/1                      if (instr[31:25] != 7'b0) begin
389        1/1                        illegal_insn = 1'b1;
390        1/1                      end
391        1/1                    end
392                     
393        1/1                    3'b101: begin
394                                 if (instr[31:25] == 7'b0) begin
395                                   alu_operator_o = ALU_SRL;  // Shift Right Logical by Immediate
396                                 end else if (instr[31:25] == 7'b010_0000) begin
397                                   alu_operator_o = ALU_SRA;  // Shift Right Arithmetically by Immediate
398        excluded                 end else begin
399                                   illegal_insn   = 1'b1;
400                                 end
401                               end
402                     
403                               default: begin
404        1/1                      alu_operator_o = ALU_SLTU;
405        1/1                    end
406        1/1                  endcase
407                           end
408        1/1          
409        1/1                OPCODE_OP: begin  // Register-Register ALU operation
410                             alu_op_a_mux_sel_o = OP_A_REG_A;
411        1/1                  alu_op_b_mux_sel_o = OP_B_REG_B;
412                             regfile_we         = 1'b1;
413        1/1          
414        1/1                  if (instr[31]) begin
415        1/1                    illegal_insn = 1'b1;
416        1/1                  end else begin
417        1/1                    unique case ({instr[30:25], instr[14:12]})
418        1/1                      // RV32I ALU operations
419        1/1                      {6'b00_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add
420        1/1                      {6'b10_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub
421        1/1                      {6'b00_0000, 3'b010}: alu_operator_o = ALU_SLT;   // Set Lower Than
422        1/1                      {6'b00_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned
423                                 {6'b00_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor
424                                 {6'b00_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or
425                                 {6'b00_0000, 3'b111}: alu_operator_o = ALU_AND;   // And
426        1/1                      {6'b00_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical
427        1/1                      {6'b00_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical
428        1/1                      {6'b10_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic
429        1/1          
430        1/1                      // supported RV32M instructions
431                                 {6'b00_0001, 3'b000}: begin // mul
432                                   alu_operator_o        = ALU_ADD;
433        1/1                        multdiv_operator_o    = MD_OP_MULL;
434        1/1                        mult_en_o             = RV32M ? 1'b1 : 1'b0;
435        1/1                        multdiv_signed_mode_o = 2'b00;
436        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
437        1/1                      end
438                                 {6'b00_0001, 3'b001}: begin // mulh
439                                   alu_operator_o        = ALU_ADD;
440        1/1                        multdiv_operator_o    = MD_OP_MULH;
441        1/1                        mult_en_o             = RV32M ? 1'b1 : 1'b0;
442        1/1                        multdiv_signed_mode_o = 2'b11;
443        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
444        1/1                      end
445                                 {6'b00_0001, 3'b010}: begin // mulhsu
446                                   alu_operator_o        = ALU_ADD;
447        1/1                        multdiv_operator_o    = MD_OP_MULH;
448        1/1                        mult_en_o             = RV32M ? 1'b1 : 1'b0;
449        1/1                        multdiv_signed_mode_o = 2'b01;
450        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
451        1/1                      end
452                                 {6'b00_0001, 3'b011}: begin // mulhu
453                                   alu_operator_o        = ALU_ADD;
454        1/1                        multdiv_operator_o    = MD_OP_MULH;
455        1/1                        mult_en_o             = RV32M ? 1'b1 : 1'b0;
456        1/1                        multdiv_signed_mode_o = 2'b00;
457        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
458        1/1                      end
459                                 {6'b00_0001, 3'b100}: begin // div
460                                   alu_operator_o        = ALU_ADD;
461        1/1                        multdiv_operator_o    = MD_OP_DIV;
462        1/1                        div_en_o              = RV32M ? 1'b1 : 1'b0;
463        1/1                        multdiv_signed_mode_o = 2'b11;
464        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
465        1/1                      end
466                                 {6'b00_0001, 3'b101}: begin // divu
467                                   alu_operator_o        = ALU_ADD;
468        1/1                        multdiv_operator_o    = MD_OP_DIV;
469        1/1                        div_en_o              = RV32M ? 1'b1 : 1'b0;
470        1/1                        multdiv_signed_mode_o = 2'b00;
471        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
472        1/1                      end
473                                 {6'b00_0001, 3'b110}: begin // rem
474                                   alu_operator_o        = ALU_ADD;
475        1/1                        multdiv_operator_o    = MD_OP_REM;
476        1/1                        div_en_o              = RV32M ? 1'b1 : 1'b0;
477        1/1                        multdiv_signed_mode_o = 2'b11;
478        1/1                        illegal_insn          = RV32M ? 1'b0 : 1'b1;
479        1/1                      end
480                                 {6'b00_0001, 3'b111}: begin // remu
481                                   alu_operator_o        = ALU_ADD;
482        1/1                        multdiv_operator_o    = MD_OP_REM;
483                                   div_en_o              = RV32M ? 1'b1 : 1'b0;
484                                   multdiv_signed_mode_o = 2'b00;
485                                   illegal_insn          = RV32M ? 1'b0 : 1'b1;
486                                 end
487                                 default: begin
488                                   illegal_insn = 1'b1;
489                                 end
490                               endcase
491                             end
492                           end
493                     
494                           /////////////
495                           // Special //
496        1/1                /////////////
497                     
498        1/1                OPCODE_MISC_MEM: begin
499        1/1                  // For now, treat the FENCE (funct3 == 000) instruction as a NOP.  This may not be correct
500        1/1                  // in a system with caches and should be revisited.
501        1/1                  // FENCE.I will flush the IF stage and prefetch buffer but nothing else.
502                             unique case (instr[14:12])
503                               3'b000: begin
504                                 alu_operator_o     = ALU_ADD; // nop
505                                 alu_op_a_mux_sel_o = OP_A_REG_A;
506                                 alu_op_b_mux_sel_o = OP_B_IMM;
507        1/1                      regfile_we         = 1'b0;
508                               end
509        1/1                    3'b001: begin
510        1/1                      // FENCE.I is implemented as a jump to the next PC, this gives the required flushing
511        1/1                      // behaviour (iside prefetch buffer flushed and response to any outstanding iside
512        1/1                      // requests will be ignored).
513        1/1                      jump_in_dec_o      = 1'b1;
514                     
515        1/1                      alu_op_a_mux_sel_o = OP_A_CURRPC;
516        1/1                      alu_op_b_mux_sel_o = OP_B_IMM;
517                                 imm_b_mux_sel_o    = IMM_B_INCR_PC;
                        MISSING_ELSE
518                                 alu_operator_o     = ALU_ADD;
519                                 regfile_we         = 1'b0;
520        1/1          
521                                 if (instr_new_i) begin
522                                   jump_set_o       = 1'b1;
523                                 end
524                               end
525                               default: begin
526        1/1                      illegal_insn       = 1'b1;
527                               end
528        1/1                  endcase
529        1/1                end
530        1/1          
531                           OPCODE_SYSTEM: begin
532                             if (instr[14:12] == 3'b000) begin
533        1/1                    // non CSR related SYSTEM instructions
534                               alu_op_a_mux_sel_o = OP_A_REG_A;
535                               alu_op_b_mux_sel_o = OP_B_IMM;
536                               unique case (instr[31:20])
537        1/1                      12'h000:  // ECALL
538                                   // environment (system) call
539                                   ecall_insn_o = 1'b1;
540        1/1          
541                                 12'h001:  // ebreak
542                                   // debugger trap
543        1/1                        ebrk_insn_o = 1'b1;
544                     
545                                 12'h302:  // mret
546        1/1                        mret_insn_o = 1'b1;
547                     
548                                 12'h7b2:  // dret
549        1/1                        dret_insn_o = 1'b1;
550                     
551                                 12'h105:  // wfi
552                                   wfi_insn_o = 1'b1;
553        1/1          
554        1/1                      default:
555                                   illegal_insn = 1'b1;
                        MISSING_ELSE
556                               endcase
557                     
558        1/1                    // rs1 and rd must be 0
559        1/1                    if (instr[`REG_S1] != 5'b0 || instr[`REG_D] != 5'b0) begin
560        1/1                      illegal_insn = 1'b1;
561        1/1                    end
562        1/1                  end else begin
563        1/1                    // instruction to read/modify CSR
564                               csr_access_o        = 1'b1;
565        1/1                    regfile_wdata_sel_o = RF_WD_CSR;
566                               regfile_we          = 1'b1;
567        1/1                    alu_op_b_mux_sel_o  = OP_B_IMM;
568                               imm_a_mux_sel_o     = IMM_A_Z;
569        1/1                    imm_b_mux_sel_o     = IMM_B_I;  // CSR address is encoded in I imm
570                     
571                               if (instr[14]) begin
572        1/1                      // rs1 field is used as immediate
573        1/1                      alu_op_a_mux_sel_o = OP_A_IMM;
574        1/1                    end else begin
575        1/1                      alu_op_a_mux_sel_o = OP_A_REG_A;
576        1/1                    end
577                     
578                               unique case (instr[13:12])
579        1/1                      2'b01:   csr_op = CSR_OP_WRITE;
580                                 2'b10:   csr_op = CSR_OP_SET;
581                                 2'b11:   csr_op = CSR_OP_CLEAR;
582                                 default: csr_illegal = 1'b1;
583                               endcase
584        1/1          
585                               illegal_insn = csr_illegal;
586                             end
587                     
588                           end
589        1/1                default: begin
590        1/1                  illegal_insn = 1'b1;
591                           end
                        MISSING_ELSE
592                         endcase
593                     
594                         // make sure illegal compressed instructions cause illegal instruction exceptions
595                         if (illegal_c_insn_i) begin
596                           illegal_insn = 1'b1;
597                         end
598        1/1          
599        1/1              // make sure illegal instructions detected in the decoder do not propagate from decoder
600        1/1              // into register file, LSU, EX, WB, CSRs, PC
601        1/1              // NOTE: instructions can also be detected to be illegal inside the CSRs (upon accesses with
602        1/1              // insufficient privileges), or when accessing non-available registers in RV32E,
603        1/1              // these cases are not handled here
604        1/1              if (illegal_insn) begin
605        1/1                regfile_we      = 1'b0;
606        1/1                data_req_o      = 1'b0;
607        1/1                data_we_o       = 1'b0;
608                           mult_en_o       = 1'b0;
                        MISSING_ELSE

-------------------------------------------------------------------------------
Branch Coverage for Instance : core_ibex_tb_top.dut.u_ibex_core.id_stage_i.decoder_i(x)
         Line No. Total Covered Percent 
Branches          90    88      97.78   
IF       137      2     2       100.00  
IF       154      5     5       100.00  
CASE     210      79    77      97.47   
IF       589      2     2       100.00  
IF       598      2     2       100.00  


137          ///////////////////////
                                    -1-
138          always_comb begin : csr_operand_check
139            csr_op_o = csr_op;
               ==>
140        
           MISSING_ELSE
           ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


154        
           -1-
155            // A pipeline flush is needed to let the controller react after modifying certain CSRs:
                                                                                                      -2-
156            // - When enabling interrupts, pending IRQs become visible to the controller only during
157            //   the next cycle. If during that cycle the core disables interrupts again, it does not
               ==>
158            //   see any pending IRQs and consequently does not start to handle interrupts.
               MISSING_ELSE
               ==>
159            // - When modifying debug CSRs - TODO: Check if this is really needed
                                                                                    -3-
160            if (csr_access_o == 1'b1 && (csr_op_o == CSR_OP_WRITE || csr_op_o == CSR_OP_SET)) begin
               -4-  
161              if (csr_num_e'(instr[31:20]) == CSR_MSTATUS   ||
162                  csr_num_e'(instr[31:20]) == CSR_MIE) begin
163                csr_pipe_flush_o = 1'b1;
164              end
                 ==>
165            end else if (csr_access_o == 1'b1 && csr_op_o != CSR_OP_READ) begin
               MISSING_ELSE
               ==>
166              if (csr_num_e'(instr[31:20]) == CSR_DCSR      ||
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- Status  
1   1   -   -   Covered 
1   0   -   -   Covered 
0   -   1   1   Covered 
0   -   1   0   Covered 
0   -   0   -   Covered 


210            dret_insn_o                 = 1'b0;
               -1-                                   
211            ecall_insn_o                = 1'b0;
212            wfi_insn_o                  = 1'b0;
213        
214            opcode                      = opcode_e'(instr[6:0]);
215        
216            unique case (opcode)
217        
218              ///////////
                            -2-
219              // Jumps //
220              ///////////
                 ==>
221        
222              OPCODE_JAL: begin   // Jump and Link
223                jump_in_dec_o         = 1'b1;
224                if (instr_new_i) begin
225                  // Calculate jump target
226                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
227                  alu_op_b_mux_sel_o  = OP_B_IMM;
228                  imm_b_mux_sel_o     = IMM_B_J;
                     ==>
229                  alu_operator_o      = ALU_ADD;
230                  regfile_we          = 1'b0;
231                  jump_set_o          = 1'b1;
232                end else begin
233                  // Calculate and store PC+4
234                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
235                  alu_op_b_mux_sel_o  = OP_B_IMM;
236                  imm_b_mux_sel_o     = IMM_B_INCR_PC;
237                  alu_operator_o      = ALU_ADD;
238                  regfile_we          = 1'b1;
                     -3-                           
239                end
240              end
                 ==>
241        
242              OPCODE_JALR: begin  // Jump and Link Register
243                jump_in_dec_o         = 1'b1;
244                if (instr_new_i) begin
245                  // Calculate jump target
246                  alu_op_a_mux_sel_o  = OP_A_REG_A;
247                  alu_op_b_mux_sel_o  = OP_B_IMM;
248                  imm_b_mux_sel_o     = IMM_B_I;
                     ==>
249                  alu_operator_o      = ALU_ADD;
250                  regfile_we          = 1'b0;
251                  jump_set_o          = 1'b1;
252                end else begin
253                  // Calculate and store PC+4
254                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
                     -4-                                  
255                  alu_op_b_mux_sel_o  = OP_B_IMM;
                     ==>
256                  imm_b_mux_sel_o     = IMM_B_INCR_PC;
                     MISSING_ELSE
                     ==>
257                  alu_operator_o      = ALU_ADD;
258                  regfile_we          = 1'b1;
259                end
260                if (instr[14:12] != 3'b0) begin
261                  illegal_insn = 1'b1;
262                end
                   -5-   
263              end
                 ==>
264        
           ==>
265              OPCODE_BRANCH: begin // Branch
                 ==>
266                branch_in_dec_o       = 1'b1;
                   ==>
267                // Check branch condition selection
                   ==>
268                unique case (instr[14:12])
                   ==>
269                  3'b000:  alu_operator_o = ALU_EQ;
                     ==>
270                  3'b001:  alu_operator_o = ALU_NE;
271                  3'b100:  alu_operator_o = ALU_LT;
                     -6-                                 
272                  3'b101:  alu_operator_o = ALU_GE;
273                  3'b110:  alu_operator_o = ALU_LTU;
                     ==>
274                  3'b111:  alu_operator_o = ALU_GEU;
275                  default: illegal_insn   = 1'b1;
276                endcase
277                if (instr_new_i) begin
                   ==>
278                  // Evaluate branch condition
279                  alu_op_a_mux_sel_o  = OP_A_REG_A;
280                  alu_op_b_mux_sel_o  = OP_B_REG_B;
281                end else begin
282                  // Calculate jump target in EX
283                  alu_op_a_mux_sel_o  = OP_A_CURRPC;
284                  alu_op_b_mux_sel_o  = OP_B_IMM;
285                  imm_b_mux_sel_o     = IMM_B_B;
286                  alu_operator_o      = ALU_ADD;
287                  regfile_we          = 1'b0;
288                end
289              end
290        
291              ////////////////
292              // Load/store //
293              ////////////////
294        
295              OPCODE_STORE: begin
296                alu_op_a_mux_sel_o = OP_A_REG_A;
                   -7-                                
297                alu_op_b_mux_sel_o = OP_B_REG_B;
298                data_req_o         = 1'b1;
                   ==>
299                data_we_o          = 1'b1;
300                alu_operator_o     = ALU_ADD;
301        
302                if (!instr[14]) begin
                   ==>
303                  // offset from immediate
304                  imm_b_mux_sel_o     = IMM_B_S;
305                  alu_op_b_mux_sel_o  = OP_B_IMM;
306                end else begin
                   -8-              
307                  // Register offset is illegal since no register c available
                     ==>
308                  illegal_insn = 1'b1;
                     ==>
309                end
                   ==>
310        
           ==>
311                // store size
312                unique case (instr[13:12])
313                  2'b00:   data_type_o  = 2'b10; // SB
314                  2'b01:   data_type_o  = 2'b01; // SH
315                  2'b10:   data_type_o  = 2'b00; // SW
316                  default: illegal_insn = 1'b1;
317                endcase
318              end
319        
320              OPCODE_LOAD: begin
321                alu_op_a_mux_sel_o  = OP_A_REG_A;
322                data_req_o          = 1'b1;
323                regfile_wdata_sel_o = RF_WD_LSU;
324                regfile_we          = 1'b1;
325                data_type_o         = 2'b00;
326        
327                // offset from immediate
328                alu_operator_o      = ALU_ADD;
329                alu_op_b_mux_sel_o  = OP_B_IMM;
330                imm_b_mux_sel_o     = IMM_B_I;
                   -9-                              
331        
           ==>
332                // sign/zero extension
                   ==>
333                data_sign_extension_o = ~instr[14];
334        
335                // load size
                               -10-
336                unique case (instr[13:12])
                   ==>
337                  2'b00: data_type_o = 2'b10; // LB(U)
                     MISSING_ELSE
                     ==>
338                  2'b01: data_type_o = 2'b01; // LH(U)
339                  2'b10: begin
340                    data_type_o = 2'b00;      // LW
                       ==>
341                    if (instr[14]) begin
342                      illegal_insn = 1'b1;    // LWU does not exist
343                    end
344                  end
345                  default: begin
346                    illegal_insn = 1'b1;
347                  end
348                endcase
349              end
350        
           ==>
351              /////////
352              // ALU //
353              /////////
354        
355              OPCODE_LUI: begin  // Load Upper Immediate
356                alu_op_a_mux_sel_o  = OP_A_IMM;
357                alu_op_b_mux_sel_o  = OP_B_IMM;
358                imm_a_mux_sel_o     = IMM_A_ZERO;
359                imm_b_mux_sel_o     = IMM_B_U;
                   ==>
360                alu_operator_o      = ALU_ADD;
361                regfile_we          = 1'b1;
362              end
363        
364              OPCODE_AUIPC: begin  // Add Upper Immediate to PC
365                alu_op_a_mux_sel_o  = OP_A_CURRPC;
366                alu_op_b_mux_sel_o  = OP_B_IMM;
367                imm_b_mux_sel_o     = IMM_B_U;
368                alu_operator_o      = ALU_ADD;
369                regfile_we          = 1'b1;
370              end
371        
372              OPCODE_OP_IMM: begin // Register-Immediate ALU Operations
                 -11-                                                         
373                alu_op_a_mux_sel_o  = OP_A_REG_A;
                   ==>
374                alu_op_b_mux_sel_o  = OP_B_IMM;
                   ==>
375                imm_b_mux_sel_o     = IMM_B_I;
                   ==>
376                regfile_we          = 1'b1;
                   ==>
377        
           ==>
378                unique case (instr[14:12])
                   ==>
379                  3'b000: alu_operator_o = ALU_ADD;  // Add Immediate
380                  3'b010: alu_operator_o = ALU_SLT;  // Set to one if Lower Than Immediate
381                  3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned
382                  3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate
                     -12-                                                                 
383                  3'b110: alu_operator_o = ALU_OR;   // Or with Immediate
                     ==>
384                  3'b111: alu_operator_o = ALU_AND;  // And with Immediate
                     MISSING_ELSE
                     ==>
385        
386                  3'b001: begin
387                    alu_operator_o = ALU_SLL;  // Shift Left Logical by Immediate
388                    if (instr[31:25] != 7'b0) begin
                       -13-  
389                      illegal_insn = 1'b1;
                         ==>
390                    end
                       -14-   
391                  end
                     ==>
392        
393                  3'b101: begin
                     ==>
394                    if (instr[31:25] == 7'b0) begin
395                      alu_operator_o = ALU_SRL;  // Shift Right Logical by Immediate
396                    end else if (instr[31:25] == 7'b010_0000) begin
397                      alu_operator_o = ALU_SRA;  // Shift Right Arithmetically by Immediate
398                    end else begin
                       ==>
399                      illegal_insn   = 1'b1;
400                    end
401                  end
402        
403                  default: begin
404                    alu_operator_o = ALU_SLTU;
405                  end
406                endcase
407              end
408        
           -15-
409              OPCODE_OP: begin  // Register-Register ALU operation
                 ==>
410                alu_op_a_mux_sel_o = OP_A_REG_A;
411                alu_op_b_mux_sel_o = OP_B_REG_B;
                   -16-                                
412                regfile_we         = 1'b1;
413        
           ==>
414                if (instr[31]) begin
                   ==>
415                  illegal_insn = 1'b1;
                     ==>
416                end else begin
                   ==>
417                  unique case ({instr[30:25], instr[14:12]})
                     ==>
418                    // RV32I ALU operations
                       ==>
419                    {6'b00_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add
                       ==>
420                    {6'b10_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub
                       ==>
421                    {6'b00_0000, 3'b010}: alu_operator_o = ALU_SLT;   // Set Lower Than
                       ==>
422                    {6'b00_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned
                       ==>
423                    {6'b00_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor
424                    {6'b00_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or
425                    {6'b00_0000, 3'b111}: alu_operator_o = ALU_AND;   // And
426                    {6'b00_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical
                       ==>
427                    {6'b00_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical
428                    {6'b10_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic
429        
430                    // supported RV32M instructions
431                    {6'b00_0001, 3'b000}: begin // mul
432                      alu_operator_o        = ALU_ADD;
433                      multdiv_operator_o    = MD_OP_MULL;
                         ==>
434                      mult_en_o             = RV32M ? 1'b1 : 1'b0;
435                      multdiv_signed_mode_o = 2'b00;
436                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
437                    end
438                    {6'b00_0001, 3'b001}: begin // mulh
439                      alu_operator_o        = ALU_ADD;
440                      multdiv_operator_o    = MD_OP_MULH;
                         ==>
441                      mult_en_o             = RV32M ? 1'b1 : 1'b0;
442                      multdiv_signed_mode_o = 2'b11;
443                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
444                    end
445                    {6'b00_0001, 3'b010}: begin // mulhsu
446                      alu_operator_o        = ALU_ADD;
447                      multdiv_operator_o    = MD_OP_MULH;
                         ==>
448                      mult_en_o             = RV32M ? 1'b1 : 1'b0;
449                      multdiv_signed_mode_o = 2'b01;
450                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
451                    end
452                    {6'b00_0001, 3'b011}: begin // mulhu
453                      alu_operator_o        = ALU_ADD;
454                      multdiv_operator_o    = MD_OP_MULH;
                         ==>
455                      mult_en_o             = RV32M ? 1'b1 : 1'b0;
456                      multdiv_signed_mode_o = 2'b00;
457                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
458                    end
459                    {6'b00_0001, 3'b100}: begin // div
460                      alu_operator_o        = ALU_ADD;
461                      multdiv_operator_o    = MD_OP_DIV;
                         ==>
462                      div_en_o              = RV32M ? 1'b1 : 1'b0;
463                      multdiv_signed_mode_o = 2'b11;
464                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
465                    end
466                    {6'b00_0001, 3'b101}: begin // divu
467                      alu_operator_o        = ALU_ADD;
468                      multdiv_operator_o    = MD_OP_DIV;
                         ==>
469                      div_en_o              = RV32M ? 1'b1 : 1'b0;
470                      multdiv_signed_mode_o = 2'b00;
471                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
472                    end
473                    {6'b00_0001, 3'b110}: begin // rem
474                      alu_operator_o        = ALU_ADD;
475                      multdiv_operator_o    = MD_OP_REM;
                         ==>
476                      div_en_o              = RV32M ? 1'b1 : 1'b0;
477                      multdiv_signed_mode_o = 2'b11;
478                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
479                    end
480                    {6'b00_0001, 3'b111}: begin // remu
481                      alu_operator_o        = ALU_ADD;
482                      multdiv_operator_o    = MD_OP_REM;
                         ==>
483                      div_en_o              = RV32M ? 1'b1 : 1'b0;
484                      multdiv_signed_mode_o = 2'b00;
485                      illegal_insn          = RV32M ? 1'b0 : 1'b1;
486                    end
487                    default: begin
488                      illegal_insn = 1'b1;
489                    end
490                  endcase
491                end
492              end
493        
494              /////////////
495              // Special //
496              /////////////
                              -17-
497        
498              OPCODE_MISC_MEM: begin
                 ==>
499                // For now, treat the FENCE (funct3 == 000) instruction as a NOP.  This may not be correct
500                // in a system with caches and should be revisited.
501                // FENCE.I will flush the IF stage and prefetch buffer but nothing else.
502                unique case (instr[14:12])
503                  3'b000: begin
504                    alu_operator_o     = ALU_ADD; // nop
505                    alu_op_a_mux_sel_o = OP_A_REG_A;
506                    alu_op_b_mux_sel_o = OP_B_IMM;
507                    regfile_we         = 1'b0;
508                  end
509                  3'b001: begin
510                    // FENCE.I is implemented as a jump to the next PC, this gives the required flushing
511                    // behaviour (iside prefetch buffer flushed and response to any outstanding iside
512                    // requests will be ignored).
513                    jump_in_dec_o      = 1'b1;
514        
515                    alu_op_a_mux_sel_o = OP_A_CURRPC;
                       -18-                                 
516                    alu_op_b_mux_sel_o = OP_B_IMM;
                       ==>
517                    imm_b_mux_sel_o    = IMM_B_INCR_PC;
                       MISSING_ELSE
                       ==>
518                    alu_operator_o     = ALU_ADD;
519                    regfile_we         = 1'b0;
520        
           ==>
521                    if (instr_new_i) begin
522                      jump_set_o       = 1'b1;
523                    end
524                  end
525                  default: begin
526                    illegal_insn       = 1'b1;
                       -19-                          
527                  end
528                endcase
529              end
530        
           -20-
531              OPCODE_SYSTEM: begin
532                if (instr[14:12] == 3'b000) begin
533                  // non CSR related SYSTEM instructions
                     ==>
534                  alu_op_a_mux_sel_o = OP_A_REG_A;
535                  alu_op_b_mux_sel_o = OP_B_IMM;
536                  unique case (instr[31:20])
537                    12'h000:  // ECALL
                       ==>
538                      // environment (system) call
539                      ecall_insn_o = 1'b1;
540        
           ==>
541                    12'h001:  // ebreak
542                      // debugger trap
543                      ebrk_insn_o = 1'b1;
                         ==>
544        
545                    12'h302:  // mret
546                      mret_insn_o = 1'b1;
                         ==>
547        
548                    12'h7b2:  // dret
549                      dret_insn_o = 1'b1;
                         ==>
550        
551                    12'h105:  // wfi
552                      wfi_insn_o = 1'b1;
553        
           -21-
554                    default:
                       ==>
555                      illegal_insn = 1'b1;
                         MISSING_ELSE
                         ==>
556                  endcase
557        
558                  // rs1 and rd must be 0
559                  if (instr[`REG_S1] != 5'b0 || instr[`REG_D] != 5'b0) begin
560                    illegal_insn = 1'b1;
561                  end
562                end else begin
563                  // instruction to read/modify CSR
564                  csr_access_o        = 1'b1;
565                  regfile_wdata_sel_o = RF_WD_CSR;
                     -22-                                
566                  regfile_we          = 1'b1;
567                  alu_op_b_mux_sel_o  = OP_B_IMM;
                     ==>
568                  imm_a_mux_sel_o     = IMM_A_Z;
569                  imm_b_mux_sel_o     = IMM_B_I;  // CSR address is encoded in I imm
                     ==>
570        
571                  if (instr[14]) begin
572                    // rs1 field is used as immediate
                                                        -23-
573                    alu_op_a_mux_sel_o = OP_A_IMM;
                       ==>
574                  end else begin
                     ==>
575                    alu_op_a_mux_sel_o = OP_A_REG_A;
                       ==>
576                  end
                     ==>
577        
578                  unique case (instr[13:12])
579                    2'b01:   csr_op = CSR_OP_WRITE;
580                    2'b10:   csr_op = CSR_OP_SET;
581                    2'b11:   csr_op = CSR_OP_CLEAR;
582                    default: csr_illegal = 1'b1;
583                  endcase
584        
           ==>

Branches:

-1-              -2- -3- -4- -5-     -6- -7- -8-     -9-     -10- -11-    -12- -13- -14- -15- -16-                 -17-    -18- -19- -20-     -21- -22- -23-    Status      
OPCODE_JAL       1   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JAL       0   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JALR      -   1   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JALR      -   0   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JALR      -   -   1   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_JALR      -   -   0   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b000  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b001  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b100  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b101  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b110  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   3'b111  -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   default -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   -       1   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_BRANCH    -   -   -   -       0   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   1   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   0   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   -   2'b00   -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   -   2'b01   -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   -   2'b10   -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_STORE     -   -   -   -       -   -   default -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LOAD      -   -   -   -       -   -   -       2'b00   -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LOAD      -   -   -   -       -   -   -       2'b01   -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LOAD      -   -   -   -       -   -   -       2'b10   1    -       -    -    -    -    -                    -       -    -    -        -    -    -       Not Covered 
OPCODE_LOAD      -   -   -   -       -   -   -       2'b10   0    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LOAD      -   -   -   -       -   -   -       default -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_LUI       -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_AUIPC     -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b000  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b010  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b011  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b100  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b110  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b111  -    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b001  1    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b001  0    -    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b101  -    1    -    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b101  -    0    1    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    3'b101  -    0    0    -    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP_IMM    -   -   -   -       -   -   -       -       -    default -    -    -    -    -                    -       -    -    -        -    -    -       Not Covered 
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    1    -                    -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b0}         -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b100000, 3'b0}    -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b010}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b011}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b100}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b110}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b111}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b1}         -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b0, 3'b101}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b100000, 3'b101}  -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b0}         -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b1}         -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b010}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b011}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b100}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b101}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b110}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    {6'b1, 3'b111}       -       -    -    -        -    -    -       Covered     
OPCODE_OP        -   -   -   -       -   -   -       -       -    -       -    -    -    0    default              -       -    -    -        -    -    -       Covered     
OPCODE_MISC_MEM  -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    3'b000  -    -    -        -    -    -       Covered     
OPCODE_MISC_MEM  -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    3'b001  1    -    -        -    -    -       Covered     
OPCODE_MISC_MEM  -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    3'b001  0    -    -        -    -    -       Covered     
OPCODE_MISC_MEM  -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    default -    -    -        -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h000  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h001  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h302  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h7b2  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    12'h105  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    default  -    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    -        1    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    1    -        0    -    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    1    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    0    -       Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    -    2'b01   Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    -    2'b10   Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    -    2'b11   Covered     
OPCODE_SYSTEM    -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    0    -        -    -    default Covered     
default          -   -   -   -       -   -   -       -       -    -       -    -    -    -    -                    -       -    -    -        -    -    -       Covered     


589              default: begin
                 -1-              
590                illegal_insn = 1'b1;
                   ==>
591              end
                 MISSING_ELSE
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


598        
           -1-
599            // make sure illegal instructions detected in the decoder do not propagate from decoder
               ==>
600            // into register file, LSU, EX, WB, CSRs, PC
601            // NOTE: instructions can also be detected to be illegal inside the CSRs (upon accesses with
602            // insufficient privileges), or when accessing non-available registers in RV32E,
603            // these cases are not handled here
604            if (illegal_insn) begin
605              regfile_we      = 1'b0;
606              data_req_o      = 1'b0;
607              data_we_o       = 1'b0;
608              mult_en_o       = 1'b0;
                 MISSING_ELSE
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


===============================================================================
Module : ibex_fetch_fifo
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 100.00 

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_fetch_fifo.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                                                 
100.00 100.00 --     --     100.00 100.00 core_ibex_tb_top.dut.u_ibex_core.if_stage_i.prefetch_buffer_i.fifo_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_fetch_fifo

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS            102        9        9   100.00
ALWAYS            137        2        2   100.00
ALWAYS            203        3        3   100.00
ALWAYS            212        3        3   100.00
ALWAYS            212        3        3   100.00
ALWAYS            212        3        3   100.00

101                       always_comb begin
102        1/1              if (out_addr_o[1]) begin
103                           // unaligned case
104        1/1                out_rdata_o = rdata_unaligned;
105        1/1                out_err_o   = err_unaligned;
106                     
107        1/1                if (unaligned_is_compressed) begin
108        1/1                  out_valid_o = valid;
109                           end else begin
110        1/1                  out_valid_o = valid_unaligned;
111                           end
112                         end else begin
113                           // aligned case
114        1/1                out_rdata_o = rdata;
115        1/1                out_err_o   = err;
116        1/1                out_valid_o = valid;
117                         end
118                       end
119                     
120                       /////////////////////////
121                       // Instruction address //
122                       /////////////////////////
123                     
124                       // Update the address on branches and every time an instruction is driven
125                       assign instr_addr_en = clear_i | (out_ready_i & out_valid_o);
126                     
127                       // Increment the address by two every time a compressed instruction is popped
128                       assign addr_incr_two = instr_addr_q[1] ? unaligned_is_compressed :
129                                                                aligned_is_compressed;
130                     
131                       assign instr_addr_d = clear_i ? in_addr_i[31:1] :
132                                                       (instr_addr_q[31:1] +
133                                                        // Increment address by 4 or 2
134                                                        {29'd0,~addr_incr_two,addr_incr_two});
135                     
136                       always_ff @(posedge clk_i) begin
137        1/1              if (instr_addr_en) begin
138        1/1                instr_addr_q <= instr_addr_d;
139                         end
                        MISSING_ELSE
140                       end
141                     
142                       assign out_addr_o[31:1] = instr_addr_q[31:1];
143                       assign out_addr_o[0]    = 1'b0;
144                     
145                       // The LSB of the address is unused, since all addresses are halfword aligned
146                       assign unused_addr_in = in_addr_i[0];
147                     
148                       ////////////////
149                       // input port //
150                       ////////////////
151                     
152                       // Accept data as long as our FIFO has space to accept the maximum number of outstanding
153                       // requests. Note that the prefetch buffer does not count how many requests are actually
154                       // outstanding, so space must be reserved for the maximum number.
155                       assign in_ready_o = ~valid_q[DEPTH-NUM_REQS];
156                     
157                       /////////////////////
158                       // FIFO management //
159                       /////////////////////
160                     
161                       // Since an entry can contain unaligned instructions, popping an entry can leave the entry valid
162                       assign pop_fifo = out_ready_i & out_valid_o & (~aligned_is_compressed | out_addr_o[1]);
163                     
164                       for (genvar i = 0; i < (DEPTH - 1); i++) begin : g_fifo_next
165                         // Calculate lowest free entry (write pointer)
166                         if (i == 0) begin : g_ent0
167                           assign lowest_free_entry[i] = ~valid_q[i];
168                         end else begin : g_ent_others
169                           assign lowest_free_entry[i] = ~valid_q[i] & valid_q[i-1];
170                         end
171                     
172                         // An entry is set when an incoming request chooses the lowest available entry
173                         assign valid_pushed[i] = (in_valid_i & lowest_free_entry[i]) |
174                                                  valid_q[i];
175                         // Popping the FIFO shifts all entries down
176                         assign valid_popped[i] = pop_fifo ? valid_pushed[i+1] : valid_pushed[i];
177                         // All entries are wiped out on a clear
178                         assign valid_d[i] = valid_popped[i] & ~clear_i;
179                     
180                         // data flops are enabled if there is new data to shift into it, or
181                         assign entry_en[i] = (valid_pushed[i+1] & pop_fifo) |
182                                              // a new request is incoming and this is the lowest free entry
183                                              (in_valid_i & lowest_free_entry[i] & ~pop_fifo);
184                     
185                         // take the next entry or the incoming data
186                         assign rdata_d[i]  = valid_q[i+1] ? rdata_q[i+1] : in_rdata_i;
187                         assign err_d  [i]  = valid_q[i+1] ? err_q  [i+1] : in_err_i;
188                       end
189                       // The top entry is similar but with simpler muxing
190                       assign lowest_free_entry[DEPTH-1] = ~valid_q[DEPTH-1] & valid_q[DEPTH-2];
191                       assign valid_pushed     [DEPTH-1] = valid_q[DEPTH-1] | (in_valid_i & lowest_free_entry[DEPTH-1]);
192                       assign valid_popped     [DEPTH-1] = pop_fifo ? 1'b0 : valid_pushed[DEPTH-1];
193                       assign valid_d [DEPTH-1]          = valid_popped[DEPTH-1] & ~clear_i;
194                       assign entry_en[DEPTH-1]          = in_valid_i & lowest_free_entry[DEPTH-1];
195                       assign rdata_d [DEPTH-1]          = in_rdata_i;
196                       assign err_d   [DEPTH-1]          = in_err_i;
197                     
198                       ////////////////////
199                       // FIFO registers //
200                       ////////////////////
201                     
202                       always_ff @(posedge clk_i or negedge rst_ni) begin
203        1/1              if (!rst_ni) begin
204        1/1                valid_q <= '0;
205                         end else begin
206        1/1                valid_q <= valid_d;
207                         end
208                       end
209                     
210                       for (genvar i = 0; i < DEPTH; i++) begin : g_fifo_regs
211                         always_ff @(posedge clk_i) begin
212        1/1                if (entry_en[i]) begin
213        1/1                  rdata_q[i]   <= rdata_d[i];
214        1/1                  err_q[i]     <= err_d[i];
215                           end
                        MISSING_ELSE
***repeat 1
212        1/1                if (entry_en[i]) begin
213        1/1                  rdata_q[i]   <= rdata_d[i];
214        1/1                  err_q[i]     <= err_d[i];
215                           end
                        MISSING_ELSE
***repeat 2
212        1/1                if (entry_en[i]) begin
213        1/1                  rdata_q[i]   <= rdata_d[i];
214        1/1                  err_q[i]     <= err_d[i];
215                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_fetch_fifo
         Line No. Total Covered Percent 
Branches          41    41      100.00  
TERNARY  62       2     2       100.00  
TERNARY  63       2     2       100.00  
TERNARY  78       2     2       100.00  
TERNARY  86       2     2       100.00  
TERNARY  91       2     2       100.00  
TERNARY  128      2     2       100.00  
TERNARY  131      2     2       100.00  
TERNARY  192      2     2       100.00  
TERNARY  176      2     2       100.00  
TERNARY  186      2     2       100.00  
TERNARY  187      2     2       100.00  
TERNARY  176      2     2       100.00  
TERNARY  186      2     2       100.00  
TERNARY  187      2     2       100.00  
IF       102      3     3       100.00  
IF       137      2     2       100.00  
IF       203      2     2       100.00  
IF       212      2     2       100.00  
IF       212      2     2       100.00  
IF       212      2     2       100.00  


62           assign rdata = valid_q[0] ? rdata_q[0] : in_rdata_i;
                                       -1-  
                                       ==>  
                                       ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


63           assign err   = valid_q[0] ? err_q[0]   : in_err_i;
                                       -1-  
                                       ==>  
                                       ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


78           assign rdata_unaligned = valid_q[1] ? {rdata_q[1][15:0], rdata[31:16]} :
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


86           assign err_unaligned   = valid_q[1] ? ((err_q[1] & ~unaligned_is_compressed) | err_q[0]) :
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


91           assign valid_unaligned = valid_q[1] ? 1'b1 :
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


128          assign addr_incr_two = instr_addr_q[1] ? unaligned_is_compressed :
                                                    -1-  
                                                    ==>  
                                                    ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


131          assign instr_addr_d = clear_i ? in_addr_i[31:1] :
                                           -1-  
                                           ==>  
                                           ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


192          assign valid_popped     [DEPTH-1] = pop_fifo ? 1'b0 : valid_pushed[DEPTH-1];
                                                          -1-  
                                                          ==>  
                                                          ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


176            assign valid_popped[i] = pop_fifo ? valid_pushed[i+1] : valid_pushed[i];
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


186            assign rdata_d[i]  = valid_q[i+1] ? rdata_q[i+1] : in_rdata_i;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


187            assign err_d  [i]  = valid_q[i+1] ? err_q  [i+1] : in_err_i;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


176            assign valid_popped[i] = pop_fifo ? valid_pushed[i+1] : valid_pushed[i];
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


186            assign rdata_d[i]  = valid_q[i+1] ? rdata_q[i+1] : in_rdata_i;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


187            assign err_d  [i]  = valid_q[i+1] ? err_q  [i+1] : in_err_i;
                                                 -1-  
                                                 ==>  
                                                 ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


102            if (out_addr_o[1]) begin
               -1-  
103              // unaligned case
104              out_rdata_o = rdata_unaligned;
105              out_err_o   = err_unaligned;
106        
107              if (unaligned_is_compressed) begin
                 -2-  
108                out_valid_o = valid;
                   ==>
109              end else begin
110                out_valid_o = valid_unaligned;
                   ==>
111              end
112            end else begin
113              // aligned case
114              out_rdata_o = rdata;
                 ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


137            if (instr_addr_en) begin
               -1-  
138              instr_addr_q <= instr_addr_d;
                 ==>
139            end
               MISSING_ELSE
               ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


203            if (!rst_ni) begin
               -1-  
204              valid_q <= '0;
                 ==>
205            end else begin
206              valid_q <= valid_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


212              if (entry_en[i]) begin
                 -1-  
213                rdata_q[i]   <= rdata_d[i];
                   ==>
214                err_q[i]     <= err_d[i];
215              end
                 MISSING_ELSE
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


212              if (entry_en[i]) begin
                 -1-  
213                rdata_q[i]   <= rdata_d[i];
                   ==>
214                err_q[i]     <= err_d[i];
215              end
                 MISSING_ELSE
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


212              if (entry_en[i]) begin
                 -1-  
213                rdata_q[i]   <= rdata_d[i];
                   ==>
214                err_q[i]     <= err_d[i];
215              end
                 MISSING_ELSE
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_fetch_fifo
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       2     2         100.00  2                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            2     2         100.00  2                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name         Attempts  Real Successes Failures Incomplete 
unnamed$$_10 159095193 6939424        0        0          
unnamed$$_11 159095193 12904223       0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.if_stage_i.prefetch_buffer_i.fifo_i
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 100.00 


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 --     --     100.00 100.00 ibex_fetch_fifo 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME              
100.00 100.00 --     --     100.00 --     prefetch_buffer_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_core_tracing
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 --     --     --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_core_tracing.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                 
100.00 --     100.00 --     --     --     core_ibex_tb_top.dut 



-------------------------------------------------------------------------------
Toggle Coverage for Module : ibex_core_tracing
                Total Covered Percent 
Totals          25    25      100.00  
Total Bits      386   386     100.00  
Total Bits 0->1 193   193     100.00  
Total Bits 1->0 193   193     100.00  

                              
Ports          25  25  100.00 
Port Bits      386 386 100.00 
Port Bits 0->1 193 193 100.00 
Port Bits 1->0 193 193 100.00 

Port Details
                    Toggle      Toggle 1->0 Toggle 0->1 Direction 
clk_i               Yes         Yes         Yes         INPUT     
rst_ni              Yes         Yes         Yes         INPUT     
test_en_i           Unreachable Unreachable Unreachable INPUT     
hart_id_i[31:0]     Unreachable Unreachable Unreachable INPUT     
boot_addr_i[31:0]   Unreachable Unreachable Unreachable INPUT     
instr_req_o         Yes         Yes         Yes         OUTPUT    
instr_gnt_i         Yes         Yes         Yes         INPUT     
instr_rvalid_i      Yes         Yes         Yes         INPUT     
instr_addr_o[1:0]   Unreachable Unreachable Unreachable OUTPUT    
instr_addr_o[31:2]  Yes         Yes         Yes         OUTPUT    
instr_rdata_i[31:0] Yes         Yes         Yes         INPUT     
instr_err_i         Yes         Yes         Yes         INPUT     
data_req_o          Yes         Yes         Yes         OUTPUT    
data_gnt_i          Yes         Yes         Yes         INPUT     
data_rvalid_i       Yes         Yes         Yes         INPUT     
data_we_o           Yes         Yes         Yes         OUTPUT    
data_be_o[3:0]      Yes         Yes         Yes         OUTPUT    
data_addr_o[1:0]    Unreachable Unreachable Unreachable OUTPUT    
data_addr_o[31:2]   Yes         Yes         Yes         OUTPUT    
data_wdata_o[31:0]  Yes         Yes         Yes         OUTPUT    
data_rdata_i[31:0]  Yes         Yes         Yes         INPUT     
data_err_i          Yes         Yes         Yes         INPUT     
irq_software_i      Yes         Yes         Yes         INPUT     
irq_timer_i         Yes         Yes         Yes         INPUT     
irq_external_i      Yes         Yes         Yes         INPUT     
irq_fast_i[14:0]    Yes         Yes         Yes         INPUT     
irq_nm_i            Yes         Yes         Yes         INPUT     
debug_req_i         Yes         Yes         Yes         INPUT     
fetch_enable_i      Yes         Yes         Yes         INPUT     
core_sleep_o        Yes         Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 95.63  99.01 100.00  81.97  97.15 100.00 


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME              
100.00 --     100.00 --     --     --     ibex_core_tracing 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                
--     --     --     --     --     --     core_ibex_tb_top(X) 


Subtrees :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME        
 94.53  99.01 --      81.97  97.15 100.00 u_ibex_core 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_register_file
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_register_file_ff.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                                    
100.00 100.00 --     --     100.00 --     core_ibex_tb_top.dut.u_ibex_core.id_stage_i.registers_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_register_file

             Line No.   Total   Covered  Percent
TOTAL                        7        7   100.00
ALWAYS             47        0        0
ALWAYS             47        2        2   100.00
ALWAYS             54        5        5   100.00

46                        always_comb begin : we_a_decoder
47         1/1              for (int unsigned i = 1; i < NUM_WORDS; i++) begin
48         1/1                we_a_dec[i] = (waddr_a_i == 5'(i)) ?  we_a_i : 1'b0;
49                          end
50                        end
51                      
52                        // loop from 1 to NUM_WORDS-1 as R0 is nil
53                        always_ff @(posedge clk_i or negedge rst_ni) begin
54         1/1              if (!rst_ni) begin
55         1/1                rf_reg_tmp <= '{default:'0};
56                          end else begin
57         1/1                for (int r = 1; r < NUM_WORDS; r++) begin
58         2/2                  if (we_a_dec[r]) rf_reg_tmp[r] <= wdata_a_i;
                        MISSING_ELSE

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_register_file
         Line No. Total Covered Percent 
Branches          2     2       100.00  
IF       54       2     2       100.00  


54             if (!rst_ni) begin
               -1-  
55               rf_reg_tmp <= '{default:'0};
                 ==>
56             end else begin
57               for (int r = 1; r < NUM_WORDS; r++) begin
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.id_stage_i.registers_i
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME               
100.00 100.00 --     --     100.00 --     ibex_register_file 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME       
100.00 100.00 --     --     100.00 100.00 id_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : prim_clock_gating
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/shared/rtl/prim_clock_gating.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                               
100.00 100.00 --     --     100.00 --     core_ibex_tb_top.dut.u_ibex_core.core_clock_gate_i 



-------------------------------------------------------------------------------
Line Coverage for Module : prim_clock_gating

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
ALWAYS             17        2        2   100.00

16                        always_latch begin
17         1/1              if (clk_i == 1'b0) begin
18         1/1                clk_en <= en_i | test_en_i;
19                          end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Branch Coverage for Module : prim_clock_gating
         Line No. Total Covered Percent 
Branches          2     2       100.00  
IF       17       2     2       100.00  


17             if (clk_i == 1'b0) begin
               -1-  
18               clk_en <= en_i | test_en_i;
                 ==>
19             end
               MISSING_ELSE
               ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.core_clock_gate_i
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME              
100.00 100.00 --     --     100.00 --     prim_clock_gating 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME        
 98.10  99.07 --     --      97.14 --     u_ibex_core 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_ex_block
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     100.00 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_ex_block.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                        
100.00 --     --     --     100.00 --     core_ibex_tb_top.dut.u_ibex_core.ex_block_i 



-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_ex_block
         Line No. Total Covered Percent 
Branches          4     4       100.00  
TERNARY  63       2     2       100.00  
TERNARY  130      2     2       100.00  


63           assign regfile_wdata_ex_o = multdiv_en ? multdiv_result : alu_result;
                                                    -1-  
                                                    ==>  
                                                    ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


130          assign ex_valid_o = multdiv_en ? multdiv_valid : 1'b1;
                                            -1-  
                                            ==>  
                                            ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.ex_block_i
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     100.00 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 96.26  99.32 --      89.47 100.00 --     


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME          
100.00 --     --     --     100.00 --     ibex_ex_block 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME        
 98.10  99.07 --     --      97.14 --     u_ibex_core 


Subtrees :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                          
 98.15  96.30 --     --     100.00 --     alu_i(x)                      
 96.49 100.00 --      89.47 100.00 --     gen_multdiv_fast.multdiv_i(x) 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_prefetch_buffer
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_prefetch_buffer.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                                          
100.00 100.00 --     --     100.00 --     core_ibex_tb_top.dut.u_ibex_core.if_stage_i.prefetch_buffer_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_prefetch_buffer

             Line No.   Total   Covered  Percent
TOTAL                       15       15   100.00
ALWAYS            150        2        2   100.00
ALWAYS            166        2        2   100.00
ALWAYS            229       11       11   100.00

149                       always_ff @(posedge clk_i) begin
150        1/1              if (stored_addr_en) begin
151        1/1                stored_addr_q <= stored_addr_d;
152                         end
                        MISSING_ELSE
153                       end
154                     
155                       // 2. fetch_addr_q
156                     
157                       // Update on a branch or as soon as a request is issued
158                       assign fetch_addr_en = branch_i | (valid_new_req & ~valid_req_q);
159                     
160                       assign fetch_addr_d = (branch_i ? addr_i : 
161                                                         {fetch_addr_q[31:2], 2'b00}) +
162                                             // Current address + 4
163                                             {{29{1'b0}},(valid_new_req & ~valid_req_q),2'b00};
164                     
165                       always_ff @(posedge clk_i) begin
166        1/1              if (fetch_addr_en) begin
167        1/1                fetch_addr_q <= fetch_addr_d;
168                         end
                        MISSING_ELSE
169                       end
170                     
171                       // Address mux
172                       assign instr_addr = valid_req_q ? stored_addr_q :
173                                           branch_i    ? addr_i :
174                                                         fetch_addr_q;
175                     
176                       assign instr_addr_w_aligned = {instr_addr[31:2], 2'b00};
177                     
178                       ///////////////////////////////
179                       // Request outstanding queue //
180                       ///////////////////////////////
181                     
182                       for (genvar i = 0; i < NUM_REQS; i++) begin : g_outstanding_reqs
183                         // Request 0 (always the oldest outstanding request)
184                         if (i == 0) begin : g_req0
185                           // A request becomes outstanding once granted, and is cleared once the rvalid is received.
186                           // Outstanding requests shift down the queue towards entry 0.
187                           assign rdata_outstanding_n[i] = (valid_req & gnt_or_pmp_err) |
188                                                           rdata_outstanding_q[i];
189                           // If a branch is received at any point while a request is outstanding, it must be tracked
190                           // to ensure we discard the data once received
191                           assign branch_discard_n[i]    = (valid_req & gnt_or_pmp_err & discard_req_d) |
192                                                           (branch_i & rdata_outstanding_q[i]) | branch_discard_q[i];
193                           // Record whether this request received a PMP error
194                           assign rdata_pmp_err_n[i]     = (valid_req & ~rdata_outstanding_q[i] & instr_pmp_err_i) |
195                                                           rdata_pmp_err_q[i];
196                     
197                         end else begin : g_reqtop
198                         // Entries > 0 consider the FIFO fill state to calculate their next state (by checking
199                         // whether the previous entry is valid)
200                     
201                           assign rdata_outstanding_n[i] = (valid_req & gnt_or_pmp_err &
202                                                            rdata_outstanding_q[i-1]) |
203                                                           rdata_outstanding_q[i];
204                           assign branch_discard_n[i]    = (valid_req & gnt_or_pmp_err & discard_req_d &
205                                                            rdata_outstanding_q[i-1]) |
206                                                           (branch_i & rdata_outstanding_q[i]) | branch_discard_q[i];
207                           assign rdata_pmp_err_n[i]     = (valid_req & ~rdata_outstanding_q[i] & instr_pmp_err_i &
208                                                            rdata_outstanding_q[i-1]) |
209                                                           rdata_pmp_err_q[i];
210                         end
211                       end
212                     
213                       // Shift the entries down on each instr_rvalid_i
214                       assign rdata_outstanding_s = rvalid_or_pmp_err ? {1'b0,rdata_outstanding_n[NUM_REQS-1:1]} :
215                                                                        rdata_outstanding_n;
216                       assign branch_discard_s    = rvalid_or_pmp_err ? {1'b0,branch_discard_n[NUM_REQS-1:1]} :
217                                                                        branch_discard_n;
218                       assign rdata_pmp_err_s     = rvalid_or_pmp_err ? {1'b0,rdata_pmp_err_n[NUM_REQS-1:1]} :
219                                                                        rdata_pmp_err_n;
220                     
221                       // Push a new entry to the FIFO once complete (and not cancelled by a branch)
222                       assign fifo_valid = rvalid_or_pmp_err & ~branch_discard_q[0];
223                     
224                       ///////////////
225                       // Registers //
226                       ///////////////
227                     
228                       always_ff @(posedge clk_i or negedge rst_ni) begin
229        1/1              if (!rst_ni) begin
230        1/1                valid_req_q          <= 1'b0;
231        1/1                discard_req_q        <= 1'b0;
232        1/1                rdata_outstanding_q  <= 'b0;
233        1/1                branch_discard_q     <= 'b0;
234        1/1                rdata_pmp_err_q      <= 'b0;
235                         end else begin
236        1/1                valid_req_q          <= valid_req_d;
237        1/1                discard_req_q        <= discard_req_d;
238        1/1                rdata_outstanding_q  <= rdata_outstanding_s;
239        1/1                branch_discard_q     <= branch_discard_s;
240        1/1                rdata_pmp_err_q      <= rdata_pmp_err_s;

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_prefetch_buffer
         Line No. Total Covered Percent 
Branches          15    15      100.00  
TERNARY  172      3     3       100.00  
TERNARY  214      2     2       100.00  
TERNARY  216      2     2       100.00  
TERNARY  218      2     2       100.00  
IF       150      2     2       100.00  
IF       166      2     2       100.00  
IF       229      2     2       100.00  


172          assign instr_addr = valid_req_q ? stored_addr_q :
                                             -1-  
                                             ==>  
173                              branch_i    ? addr_i :
                                             -2-  
                                             ==>  
                                             ==>  

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


214          assign rdata_outstanding_s = rvalid_or_pmp_err ? {1'b0,rdata_outstanding_n[NUM_REQS-1:1]} :
                                                            -1-  
                                                            ==>  
                                                            ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


216          assign branch_discard_s    = rvalid_or_pmp_err ? {1'b0,branch_discard_n[NUM_REQS-1:1]} :
                                                            -1-  
                                                            ==>  
                                                            ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


218          assign rdata_pmp_err_s     = rvalid_or_pmp_err ? {1'b0,rdata_pmp_err_n[NUM_REQS-1:1]} :
                                                            -1-  
                                                            ==>  
                                                            ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


150            if (stored_addr_en) begin
               -1-  
151              stored_addr_q <= stored_addr_d;
                 ==>
152            end
               MISSING_ELSE
               ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


166            if (fetch_addr_en) begin
               -1-  
167              fetch_addr_q <= fetch_addr_d;
                 ==>
168            end
               MISSING_ELSE
               ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


229            if (!rst_ni) begin
               -1-  
230              valid_req_q          <= 1'b0;
                 ==>
231              discard_req_q        <= 1'b0;
232              rdata_outstanding_q  <= 'b0;
233              branch_discard_q     <= 'b0;
234              rdata_pmp_err_q      <= 'b0;
235            end else begin
236              valid_req_q          <= valid_req_d;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.if_stage_i.prefetch_buffer_i
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 100.00 


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                 
100.00 100.00 --     --     100.00 --     ibex_prefetch_buffer 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME          
100.00 100.00 --     --     100.00 100.00 if_stage_i(x) 


Subtrees :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME   
100.00 100.00 --     --     100.00 100.00 fifo_i 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ibex_id_stage
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 100.00 

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/rtl/ibex_id_stage.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                                        
100.00 100.00 --     --     100.00 100.00 core_ibex_tb_top.dut.u_ibex_core.id_stage_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ibex_id_stage

             Line No.   Total   Covered  Percent
TOTAL                       68       68   100.00
ALWAYS            231        6        6   100.00
ALWAYS            246        9        9   100.00
ALWAYS            272        6        6   100.00
ALWAYS            519        7        7   100.00
ALWAYS            535       40       40   100.00

230                       always_comb begin : alu_operand_a_mux
231        1/1              unique case (alu_op_a_mux_sel)
232        1/1                OP_A_REG_A:  alu_operand_a = regfile_rdata_a;
233        1/1                OP_A_FWD:    alu_operand_a = lsu_addr_last_i;
234        1/1                OP_A_CURRPC: alu_operand_a = pc_id_i;
235        1/1                OP_A_IMM:    alu_operand_a = imm_a;
236        1/1                default:     alu_operand_a = pc_id_i;
237                         endcase
238                       end
239                     
240                       ///////////////////
241                       // Operand B MUX //
242                       ///////////////////
243                     
244                       // Immediate MUX for Operand B
245                       always_comb begin : immediate_b_mux
246        1/1              unique case (imm_b_mux_sel)
247        1/1                IMM_B_I:         imm_b = imm_i_type;
248        1/1                IMM_B_S:         imm_b = imm_s_type;
249        1/1                IMM_B_B:         imm_b = imm_b_type;
250        1/1                IMM_B_U:         imm_b = imm_u_type;
251        1/1                IMM_B_J:         imm_b = imm_j_type;
252        1/1                IMM_B_INCR_PC:   imm_b = instr_is_compressed_i ? 32'h2 : 32'h4;
253        1/1                IMM_B_INCR_ADDR: imm_b = 32'h4;
254        1/1                default:         imm_b = 32'h4;
255                         endcase
256                       end
257                     
258                       // ALU MUX for Operand B
259                       assign alu_operand_b = (alu_op_b_mux_sel == OP_B_IMM) ? imm_b : regfile_rdata_b;
260                     
261                       ///////////////////////
262                       // Register File MUX //
263                       ///////////////////////
264                     
265                       // Register file write enable mux - do not propagate illegal CSR ops, do not write when idle,
266                       // for loads/stores and multdiv operations write when the data is ready only
267                       assign regfile_we = (illegal_csr_insn_i || !instr_executing) ? 1'b0          :
268                                           (data_req_dec || multdiv_en_dec)         ? regfile_we_wb : regfile_we_dec;
269                     
270                       // Register file write data mux
271                       always_comb begin : regfile_wdata_mux
272        1/1              unique case (regfile_wdata_sel)
273        1/1                RF_WD_EX:  regfile_wdata = regfile_wdata_ex_i;
274        1/1                RF_WD_LSU: regfile_wdata = regfile_wdata_lsu_i;
275        1/1                RF_WD_CSR: regfile_wdata = csr_rdata_i;
276        1/1                default:   regfile_wdata = regfile_wdata_ex_i;
277        1/1              endcase
278                       end
279                     
280                       ///////////////////
281                       // Register File //
282                       ///////////////////
283                     
284                       ibex_register_file #( .RV32E ( RV32E ) ) registers_i (
285                           .clk_i        ( clk_i           ),
286                           .rst_ni       ( rst_ni          ),
287                     
288                           .test_en_i    ( test_en_i       ),
289                     
290                           // Read port a
291                           .raddr_a_i    ( regfile_raddr_a ),
292                           .rdata_a_o    ( regfile_rdata_a ),
293                           // Read port b
294                           .raddr_b_i    ( regfile_raddr_b ),
295                           .rdata_b_o    ( regfile_rdata_b ),
296                           // write port
297                           .waddr_a_i    ( regfile_waddr   ),
298                           .wdata_a_i    ( regfile_wdata   ),
299                           .we_a_i       ( regfile_we      )
300                       );
301                     
302                     `ifdef RVFI
303                       assign rfvi_reg_raddr_ra_o = regfile_raddr_a;
304                       assign rfvi_reg_rdata_ra_o = regfile_rdata_a;
305                       assign rfvi_reg_raddr_rb_o = regfile_raddr_b;
306                       assign rfvi_reg_rdata_rb_o = regfile_rdata_b;
307                       assign rfvi_reg_waddr_rd_o = regfile_waddr;
308                       assign rfvi_reg_wdata_rd_o = regfile_wdata;
309                       assign rfvi_reg_we_o       = regfile_we;
310                     `endif
311                     
312                       /////////////
313                       // Decoder //
314                       /////////////
315                     
316                       ibex_decoder #(
317                           .RV32E ( RV32E ),
318                           .RV32M ( RV32M )
319                       ) decoder_i (
320                           .clk_i                           ( clk_i                ),
321                           .rst_ni                          ( rst_ni               ),
322                     
323                           // controller
324                           .illegal_insn_o                  ( illegal_insn_dec     ),
325                           .ebrk_insn_o                     ( ebrk_insn            ),
326                           .mret_insn_o                     ( mret_insn_dec        ),
327                           .dret_insn_o                     ( dret_insn_dec        ),
328                           .ecall_insn_o                    ( ecall_insn_dec       ),
329                           .wfi_insn_o                      ( wfi_insn_dec         ),
330                           .jump_set_o                      ( jump_set             ),
331                     
332                           // from IF-ID pipeline register
333                           .instr_new_i                     ( instr_new_i          ),
334                           .instr_rdata_i                   ( instr_rdata_i        ),
335                           .illegal_c_insn_i                ( illegal_c_insn_i     ),
336                     
337                           // immediates
338                           .imm_a_mux_sel_o                 ( imm_a_mux_sel        ),
339                           .imm_b_mux_sel_o                 ( imm_b_mux_sel_dec    ),
340                     
341                           .imm_i_type_o                    ( imm_i_type           ),
342                           .imm_s_type_o                    ( imm_s_type           ),
343                           .imm_b_type_o                    ( imm_b_type           ),
344                           .imm_u_type_o                    ( imm_u_type           ),
345                           .imm_j_type_o                    ( imm_j_type           ),
346                           .zimm_rs1_type_o                 ( zimm_rs1_type        ),
347                     
348                           // register file
349                           .regfile_wdata_sel_o             ( regfile_wdata_sel    ),
350                           .regfile_we_o                    ( regfile_we_dec       ),
351                     
352                           .regfile_raddr_a_o               ( regfile_raddr_a      ),
353                           .regfile_raddr_b_o               ( regfile_raddr_b      ),
354                           .regfile_waddr_o                 ( regfile_waddr        ),
355                     
356                           // ALU
357                           .alu_operator_o                  ( alu_operator         ),
358                           .alu_op_a_mux_sel_o              ( alu_op_a_mux_sel_dec ),
359                           .alu_op_b_mux_sel_o              ( alu_op_b_mux_sel_dec ),
360                     
361                           // MULT & DIV
362                           .mult_en_o                       ( mult_en_dec          ),
363                           .div_en_o                        ( div_en_dec           ),
364                           .multdiv_operator_o              ( multdiv_operator     ),
365                           .multdiv_signed_mode_o           ( multdiv_signed_mode  ),
366                     
367                           // CSRs
368                           .csr_access_o                    ( csr_access_o         ),
369                           .csr_op_o                        ( csr_op_o             ),
370                           .csr_pipe_flush_o                ( csr_pipe_flush       ),
371                     
372                           // LSU
373                           .data_req_o                      ( data_req_dec         ),
374                           .data_we_o                       ( data_we_id           ),
375                           .data_type_o                     ( data_type_id         ),
376                           .data_sign_extension_o           ( data_sign_ext_id     ),
377                     
378                           // jump/branches
379                           .jump_in_dec_o                   ( jump_in_dec          ),
380                           .branch_in_dec_o                 ( branch_in_dec        )
381                       );
382                     
383                       ////////////////
384                       // Controller //
385                       ////////////////
386                     
387                       assign illegal_insn_o = instr_valid_i & (illegal_insn_dec | illegal_csr_insn_i);
388                     
389                       ibex_controller controller_i (
390                           .clk_i                          ( clk_i                  ),
391                           .rst_ni                         ( rst_ni                 ),
392                     
393                           .fetch_enable_i                 ( fetch_enable_i         ),
394                           .ctrl_busy_o                    ( ctrl_busy_o            ),
395                     
396                           // decoder related signals
397                           .illegal_insn_i                 ( illegal_insn_o         ),
398                           .ecall_insn_i                   ( ecall_insn_dec         ),
399                           .mret_insn_i                    ( mret_insn_dec          ),
400                           .dret_insn_i                    ( dret_insn_dec          ),
401                           .wfi_insn_i                     ( wfi_insn_dec           ),
402                           .ebrk_insn_i                    ( ebrk_insn              ),
403                           .csr_pipe_flush_i               ( csr_pipe_flush         ),
404                     
405                           // from IF-ID pipeline
406                           .instr_valid_i                  ( instr_valid_i          ),
407                           .instr_i                        ( instr_rdata_i          ),
408                           .instr_compressed_i             ( instr_rdata_c_i        ),
409                           .instr_is_compressed_i          ( instr_is_compressed_i  ),
410                           .instr_fetch_err_i              ( instr_fetch_err_i      ),
411                           .pc_id_i                        ( pc_id_i                ),
412                     
413                           // to IF-ID pipeline
414                           .instr_valid_clear_o            ( instr_valid_clear_o    ),
415                           .id_in_ready_o                  ( id_in_ready_o          ),
416                     
417                           // to prefetcher
418                           .instr_req_o                    ( instr_req_o            ),
419                           .pc_set_o                       ( pc_set_o               ),
420                           .pc_mux_o                       ( pc_mux_o               ),
421                           .exc_pc_mux_o                   ( exc_pc_mux_o           ),
422                           .exc_cause_o                    ( exc_cause_o            ),
423                     
424                           // LSU
425                           .lsu_addr_last_i                ( lsu_addr_last_i        ),
426                           .load_err_i                     ( lsu_load_err_i         ),
427                           .store_err_i                    ( lsu_store_err_i        ),
428                     
429                           // jump/branch control
430                           .branch_set_i                   ( branch_set_q           ),
431                           .jump_set_i                     ( jump_set               ),
432                     
433                           // interrupt signals
434                           .csr_mstatus_mie_i              ( csr_mstatus_mie_i      ),
435                           .csr_msip_i                     ( csr_msip_i             ),
436                           .csr_mtip_i                     ( csr_mtip_i             ),
437                           .csr_meip_i                     ( csr_meip_i             ),
438                           .csr_mfip_i                     ( csr_mfip_i             ),
439                           .irq_pending_i                  ( irq_pending_i          ),
440                           .irq_nm_i                       ( irq_nm_i               ),
441                           .nmi_mode_o                     ( nmi_mode_o             ),
442                     
443                           // CSR Controller Signals
444                           .csr_save_if_o                  ( csr_save_if_o          ),
445                           .csr_save_id_o                  ( csr_save_id_o          ),
446                           .csr_restore_mret_id_o          ( csr_restore_mret_id_o  ),
447                           .csr_restore_dret_id_o          ( csr_restore_dret_id_o  ),
448                           .csr_save_cause_o               ( csr_save_cause_o       ),
449                           .csr_mtval_o                    ( csr_mtval_o            ),
450                           .priv_mode_i                    ( priv_mode_i            ),
451                           .csr_mstatus_tw_i               ( csr_mstatus_tw_i       ),
452                     
453                           // Debug Signal
454                           .debug_mode_o                   ( debug_mode_o           ),
455                           .debug_cause_o                  ( debug_cause_o          ),
456                           .debug_csr_save_o               ( debug_csr_save_o       ),
457                           .debug_req_i                    ( debug_req_i            ),
458                           .debug_single_step_i            ( debug_single_step_i    ),
459                           .debug_ebreakm_i                ( debug_ebreakm_i        ),
460                           .debug_ebreaku_i                ( debug_ebreaku_i        ),
461                           .trigger_match_i                ( trigger_match_i        ),
462                     
463                           // stall signals
464                           .stall_lsu_i                    ( stall_lsu              ),
465                           .stall_multdiv_i                ( stall_multdiv          ),
466                           .stall_jump_i                   ( stall_jump             ),
467                           .stall_branch_i                 ( stall_branch           ),
468                     
469                           // Performance Counters
470                           .perf_jump_o                    ( perf_jump_o            ),
471                           .perf_tbranch_o                 ( perf_tbranch_o         )
472                       );
473                     
474                       //////////////
475                       // ID-EX/WB //
476                       //////////////
477                     
478                       assign multdiv_en_dec   = mult_en_dec | div_en_dec;
479                       assign instr_multicycle = data_req_dec | multdiv_en_dec | branch_in_dec | jump_in_dec;
480                     
481                       // Forward decoder output to EX, WB and controller only if current instr is still
482                       // being executed. This is the case if the current instr is either:
483                       // - a new instr (not yet done)
484                       // - a multicycle instr that is not yet done
485                       // An instruction error will suppress any requests or register writes
486                       assign instr_executing = (instr_new_i | (instr_multicycle & ~instr_multicycle_done_q)) &
487                                                ~instr_fetch_err_i;
488                       assign data_req_id     = instr_executing ? data_req_dec  : 1'b0;
489                       assign mult_en_id      = instr_executing ? mult_en_dec   : 1'b0;
490                       assign div_en_id       = instr_executing ? div_en_dec    : 1'b0;
491                     
492                       ///////////
493                       // ID-EX //
494                       ///////////
495                     
496                       assign data_req_ex_o               = data_req_id;
497                       assign data_we_ex_o                = data_we_id;
498                       assign data_type_ex_o              = data_type_id;
499                       assign data_sign_ext_ex_o          = data_sign_ext_id;
500                       assign data_wdata_ex_o             = regfile_rdata_b;
501                     
502                       assign alu_operator_ex_o           = alu_operator;
503                       assign alu_operand_a_ex_o          = alu_operand_a;
504                       assign alu_operand_b_ex_o          = alu_operand_b;
505                     
506                       assign mult_en_ex_o                = mult_en_id;
507                       assign div_en_ex_o                 = div_en_id;
508                     
509                       assign multdiv_operator_ex_o       = multdiv_operator;
510                       assign multdiv_signed_mode_ex_o    = multdiv_signed_mode;
511                       assign multdiv_operand_a_ex_o      = regfile_rdata_a;
512                       assign multdiv_operand_b_ex_o      = regfile_rdata_b;
513                     
514                       typedef enum logic { IDLE, WAIT_MULTICYCLE } id_fsm_e;
515                       id_fsm_e id_wb_fsm_cs, id_wb_fsm_ns;
516                     
517                       ////////////////////////////////
518                       // ID-EX/WB Pipeline Register //
519        1/1            ////////////////////////////////
520        1/1          
521        1/1            always_ff @(posedge clk_i or negedge rst_ni) begin : id_wb_pipeline_reg
522        1/1              if (!rst_ni) begin
523                           id_wb_fsm_cs            <= IDLE;
524        1/1                branch_set_q            <= 1'b0;
525        1/1                instr_multicycle_done_q <= 1'b0;
526        1/1              end else begin
527                           id_wb_fsm_cs            <= id_wb_fsm_ns;
528                           branch_set_q            <= branch_set_n;
529                           instr_multicycle_done_q <= instr_multicycle_done_n;
530                         end
531                       end
532                     
533                       //////////////////
534                       // ID-EX/WB FSM //
535        1/1            //////////////////
536        1/1          
537        1/1            always_comb begin : id_wb_fsm
538        1/1              id_wb_fsm_ns            = id_wb_fsm_cs;
539        1/1              instr_multicycle_done_n = instr_multicycle_done_q;
540        1/1              regfile_we_wb           = 1'b0;
541        1/1              stall_lsu               = 1'b0;
542        1/1              stall_multdiv           = 1'b0;
543        1/1              stall_jump              = 1'b0;
544        1/1              stall_branch            = 1'b0;
545                         branch_set_n            = 1'b0;
546        1/1              perf_branch_o           = 1'b0;
547                         instr_ret_o             = 1'b0;
548                     
549                         unique case (id_wb_fsm_cs)
550                     
551        1/1                IDLE: begin
552        1/1                  // only detect multicycle when instruction is new, do not re-detect after
553                             // execution (when waiting for next instruction from IF stage)
554                             if (instr_new_i & ~instr_fetch_err_i) begin
555        1/1                    unique case (1'b1)
556        1/1                      data_req_dec: begin
557        1/1                        // LSU operation
558                                   id_wb_fsm_ns            = WAIT_MULTICYCLE;
559                                   stall_lsu               = 1'b1;
560                                   instr_multicycle_done_n = 1'b0;
561        1/1                      end
562        1/1                      multdiv_en_dec: begin
563        1/1                        // MUL or DIV operation
564                                   id_wb_fsm_ns            = WAIT_MULTICYCLE;
565                                   stall_multdiv           = 1'b1;
566                                   instr_multicycle_done_n = 1'b0;
567        1/1                      end
568        1/1                      branch_in_dec: begin
569        1/1                        // cond branch operation
570        1/1                        id_wb_fsm_ns            =  branch_decision_i ? WAIT_MULTICYCLE : IDLE;
571        1/1                        stall_branch            =  branch_decision_i;
572        1/1                        instr_multicycle_done_n = ~branch_decision_i;
573                                   branch_set_n            =  branch_decision_i;
574                                   perf_branch_o           =  1'b1;
575                                   instr_ret_o             = ~branch_decision_i;
576        1/1                      end
577        1/1                      jump_in_dec: begin
578        1/1                        // uncond branch operation
579                                   id_wb_fsm_ns            = WAIT_MULTICYCLE;
580                                   stall_jump              = 1'b1;
581        1/1                        instr_multicycle_done_n = 1'b0;
582        1/1                      end
583                                 default: begin
584                                   instr_multicycle_done_n = 1'b0;
585                                   instr_ret_o             = 1'b1;
                        MISSING_ELSE
586                                 end
587                               endcase
588                             end
589        1/1                end
590        1/1          
591        1/1                WAIT_MULTICYCLE: begin
592        1/1                  if ((data_req_dec & lsu_valid_i) | (~data_req_dec & ex_valid_i)) begin
593        1/1                    id_wb_fsm_ns            = IDLE;
594                               instr_multicycle_done_n = 1'b1;
595        1/1                    regfile_we_wb           = regfile_we_dec & ~lsu_load_err_i;
596        1/1                    instr_ret_o             = 1'b1;
597        1/1                  end else begin
598        1/1                    stall_lsu               = data_req_dec;
599                               stall_multdiv           = multdiv_en_dec;
600                               stall_branch            = branch_in_dec;
601                               stall_jump              = jump_in_dec;
602                             end
603        1/1                end

-------------------------------------------------------------------------------
Branch Coverage for Module : ibex_id_stage
         Line No. Total Covered Percent 
Branches          49    49      100.00  
TERNARY  218      2     2       100.00  
TERNARY  219      2     2       100.00  
TERNARY  220      2     2       100.00  
TERNARY  227      2     2       100.00  
TERNARY  259      2     2       100.00  
TERNARY  267      3     3       100.00  
TERNARY  485      2     2       100.00  
TERNARY  486      2     2       100.00  
TERNARY  487      2     2       100.00  
CASE     231      5     5       100.00  
CASE     246      9     9       100.00  
CASE     272      4     4       100.00  
IF       519      2     2       100.00  
CASE     546      10    10      100.00  


218          assign alu_op_a_mux_sel = lsu_addr_incr_req_i ? OP_A_FWD        : alu_op_a_mux_sel_dec;
                                                           -1-  
                                                           ==>  
                                                           ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


219          assign alu_op_b_mux_sel = lsu_addr_incr_req_i ? OP_B_IMM        : alu_op_b_mux_sel_dec;
                                                           -1-  
                                                           ==>  
                                                           ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


220          assign imm_b_mux_sel    = lsu_addr_incr_req_i ? IMM_B_INCR_ADDR : imm_b_mux_sel_dec;
                                                           -1-  
                                                           ==>  
                                                           ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


227          assign imm_a = (imm_a_mux_sel == IMM_A_Z) ? zimm_rs1_type : '0;
                                                       -1-  
                                                       ==>  
                                                       ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


259          assign alu_operand_b = (alu_op_b_mux_sel == OP_B_IMM) ? imm_b : regfile_rdata_b;
                                                                   -1-  
                                                                   ==>  
                                                                   ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


267          assign regfile_we = (illegal_csr_insn_i || !instr_executing) ? 1'b0          :
                                                                          -1-  
                                                                          ==>  
268                              (data_req_dec || multdiv_en_dec)         ? regfile_we_wb : regfile_we_dec;
                                                                          -2-  
                                                                          ==>  
                                                                          ==>  

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


485          // An instruction error will suppress any requests or register writes
                                                                                  
486          assign instr_executing = (instr_new_i | (instr_multicycle & ~instr_multicycle_done_q)) &
                                                                                                     
487                                   ~instr_fetch_err_i;
                                                         
488          assign data_req_id     = instr_executing ? data_req_dec  : 1'b0;
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


486          assign instr_executing = (instr_new_i | (instr_multicycle & ~instr_multicycle_done_q)) &
                                                                                                     
487                                   ~instr_fetch_err_i;
                                                         
488          assign data_req_id     = instr_executing ? data_req_dec  : 1'b0;
                                                      -1-  
                                                      ==>  
                                                      ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


487                                   ~instr_fetch_err_i;
                                                         
           Warning: the following expressions can not be annotated
           -1- (instr_executing) ? ...;  
           

Branches:

-1- Status  
1   Covered 
0   Covered 


231            unique case (alu_op_a_mux_sel)
                      -1-  
232              OP_A_REG_A:  alu_operand_a = regfile_rdata_a;
                 ==>
233              OP_A_FWD:    alu_operand_a = lsu_addr_last_i;
                 ==>
234              OP_A_CURRPC: alu_operand_a = pc_id_i;
                 ==>
235              OP_A_IMM:    alu_operand_a = imm_a;
                 ==>
236              default:     alu_operand_a = pc_id_i;
                 ==>

Branches:

-1-          Status  
OP_A_REG_A   Covered 
OP_A_FWD     Covered 
OP_A_CURRPC  Covered 
OP_A_IMM     Covered 
default      Covered 


246            unique case (imm_b_mux_sel)
                      -1-  
247              IMM_B_I:         imm_b = imm_i_type;
                 ==>
248              IMM_B_S:         imm_b = imm_s_type;
                 ==>
249              IMM_B_B:         imm_b = imm_b_type;
                 ==>
250              IMM_B_U:         imm_b = imm_u_type;
                 ==>
251              IMM_B_J:         imm_b = imm_j_type;
                 ==>
252              IMM_B_INCR_PC:   imm_b = instr_is_compressed_i ? 32'h2 : 32'h4;
                                                                -2-  
                                                                ==>  
                                                                ==>  
253              IMM_B_INCR_ADDR: imm_b = 32'h4;
                 ==>
254              default:         imm_b = 32'h4;
                 ==>

Branches:

-1-              -2- Status  
IMM_B_I          -   Covered 
IMM_B_S          -   Covered 
IMM_B_B          -   Covered 
IMM_B_U          -   Covered 
IMM_B_J          -   Covered 
IMM_B_INCR_PC    1   Covered 
IMM_B_INCR_PC    0   Covered 
IMM_B_INCR_ADDR  -   Covered 
default          -   Covered 


272            unique case (regfile_wdata_sel)
                      -1-  
273              RF_WD_EX:  regfile_wdata = regfile_wdata_ex_i;
                 ==>
274              RF_WD_LSU: regfile_wdata = regfile_wdata_lsu_i;
                 ==>
275              RF_WD_CSR: regfile_wdata = csr_rdata_i;
                 ==>
276              default:   regfile_wdata = regfile_wdata_ex_i;
                 ==>

Branches:

-1-        Status  
RF_WD_EX   Covered 
RF_WD_LSU  Covered 
RF_WD_CSR  Covered 
default    Covered 


519          ////////////////////////////////
                                             -1-
520        
           ==>
521          always_ff @(posedge clk_i or negedge rst_ni) begin : id_wb_pipeline_reg
522            if (!rst_ni) begin
523              id_wb_fsm_cs            <= IDLE;
524              branch_set_q            <= 1'b0;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


546            perf_branch_o           = 1'b0;
               -1-                               
547            instr_ret_o             = 1'b0;
548        
549            unique case (id_wb_fsm_cs)
550        
551              IDLE: begin
                 -2-           
552                // only detect multicycle when instruction is new, do not re-detect after
                                                                                            -3-
553                // execution (when waiting for next instruction from IF stage)
554                if (instr_new_i & ~instr_fetch_err_i) begin
555                  unique case (1'b1)
                     ==>
556                    data_req_dec: begin
557                      // LSU operation
558                      id_wb_fsm_ns            = WAIT_MULTICYCLE;
559                      stall_lsu               = 1'b1;
560                      instr_multicycle_done_n = 1'b0;
561                    end
                       ==>
562                    multdiv_en_dec: begin
563                      // MUL or DIV operation
564                      id_wb_fsm_ns            = WAIT_MULTICYCLE;
565                      stall_multdiv           = 1'b1;
566                      instr_multicycle_done_n = 1'b0;
567                    end
                          
568                    branch_in_dec: begin
                                           
569                      // cond branch operation
                                                 
570                      id_wb_fsm_ns            =  branch_decision_i ? WAIT_MULTICYCLE : IDLE;
                                                                      -4-  
                                                                      ==>  
                                                                      ==>  
571                      stall_branch            =  branch_decision_i;
572                      instr_multicycle_done_n = ~branch_decision_i;
573                      branch_set_n            =  branch_decision_i;
574                      perf_branch_o           =  1'b1;
575                      instr_ret_o             = ~branch_decision_i;
576                    end
                       ==>
577                    jump_in_dec: begin
578                      // uncond branch operation
579                      id_wb_fsm_ns            = WAIT_MULTICYCLE;
580                      stall_jump              = 1'b1;
581                      instr_multicycle_done_n = 1'b0;
                         ==>
582                    end
583                    default: begin
584                      instr_multicycle_done_n = 1'b0;
585                      instr_ret_o             = 1'b1;
                         MISSING_ELSE
                         ==>
586                    end
587                  endcase
588                end
589              end
                 -5-   
590        
           ==>
591              WAIT_MULTICYCLE: begin
592                if ((data_req_dec & lsu_valid_i) | (~data_req_dec & ex_valid_i)) begin
593                  id_wb_fsm_ns            = IDLE;
594                  instr_multicycle_done_n = 1'b1;
595                  regfile_we_wb           = regfile_we_dec & ~lsu_load_err_i;
                     ==>
596                  instr_ret_o             = 1'b1;
597                end else begin
598                  stall_lsu               = data_req_dec;
599                  stall_multdiv           = multdiv_en_dec;
600                  stall_branch            = branch_in_dec;
601                  stall_jump              = jump_in_dec;
602                end
603              end
                 ==>

Branches:

-1-              -2- -3-             -4- -5- Status  
IDLE             1   data_req_dec    -   -   Covered 
IDLE             1   multdiv_en_dec  -   -   Covered 
IDLE             1   branch_in_dec   1   -   Covered 
IDLE             1   branch_in_dec   0   -   Covered 
IDLE             1   jump_in_dec     -   -   Covered 
IDLE             1   default         -   -   Covered 
IDLE             0   -               -   -   Covered 
WAIT_MULTICYCLE  -   -               -   1   Covered 
WAIT_MULTICYCLE  -   -               -   0   Covered 
default          -   -               -   -   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : ibex_id_stage
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       3     3         100.00  3                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            3     3         100.00  3                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name        Attempts  Real Successes Failures Incomplete 
unnamed$$_0 159095193 159002193      0        0          
unnamed$$_1 159095193 83899918       0        0          
unnamed$$_2 159095193 159002193      0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top.dut.u_ibex_core.id_stage_i
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     --     100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 90.39  99.07 --      66.67  95.83 100.00 


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME          
100.00 100.00 --     --     100.00 100.00 ibex_id_stage 


Parent : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME        
 98.10  99.07 --     --      97.14 --     u_ibex_core 


Subtrees :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME         
 85.13  98.07 --      66.67  90.67 --     controller_i 
 98.69  99.61 --     --      97.78 --     decoder_i(x) 
100.00 100.00 --     --     100.00 --     registers_i  



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : core_ibex_tb_top(X)
===============================================================================
SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     

Source File(s) : 

/usr/local/google/home/udij/opentitan/ibex/dv/uvm/tb/core_ibex_tb_top.sv

Module self-instances :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                
--     --     --     --     --     --     core_ibex_tb_top(X) 



-------------------------------------------------------------------------------
===============================================================================
Module Instance : core_ibex_tb_top(X)
===============================================================================

Instance :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     


Instance's subtree :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT 
 95.63  99.01 100.00  81.97  97.15 100.00 


Module : 

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME                
--     --     --     --     --     --     core_ibex_tb_top(X) 


Parent : 

none
----------------


Subtrees :

SCORE  LINE   TOGGLE FSM    BRANCH ASSERT NAME 
 95.63  99.01 100.00  81.97  97.15 100.00 dut  



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
